{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p> <p>FastAPI implemention of the STAC API spec.</p> </p> <p> </p> <p>Documentation: https://stac-utils.github.io/stac-fastapi/</p> <p>Source Code: stac-utils/stac-fastapi</p> <p>Python library for building a STAC-compliant FastAPI application.  </p> <p><code>stac-fastapi</code> was initially developed by arturo-ai.</p> <p>The project contains several namespace packages:</p> Package Description Version stac_fastapi.api An API layer which enforces the stac-api-spec. stac_fastapi.extensions Abstract base classes for STAC API extensions and third-party extensions. stac_fastapi.types Shared types and abstract base classes used by the library."},{"location":"#backends","title":"Backends","text":"<p>In addition to the packages in this repository, a server implemention will also require the selection of a backend to connect with a database for STAC metadata storage. There are several different backend options, and each has their own repository.</p> <p>The two most widely-used and supported backends are:</p> <ul> <li>stac-fastapi-pgstac: PostgreSQL + PostGIS via PgSTAC.</li> <li>stac-fastapi-elasticsearch-opensearch: Elasticsearch or OpenSearch</li> </ul> <p>Other implementations include:</p> <ul> <li>stac-fastapi-mongo: MongoDB</li> <li>stac-fastapi-geoparquet): GeoParquet via stacrs (experimental)</li> <li>stac-fastapi-duckdb: DuckDB (experimental)</li> <li>stac-fastapi-sqlalchemy: PostgreSQL + PostGIS via SQLAlchemy (abandoned in favor of stac-fastapi-pgstac)</li> </ul>"},{"location":"#response-model-validation","title":"Response Model Validation","text":"<p>A common question when using this package is how request and response types are validated?</p> <p>This package uses <code>stac-pydantic</code> to validate and document STAC objects. However, by default, validation of response types is turned off and the API will simply forward responses without validating them against the Pydantic model first. This decision was made with the assumption that responses usually come from a (typed) database and can be considered safe. Extra validation would only increase latency, in particular for large payloads.</p> <p>To turn on response validation, set <code>ENABLE_RESPONSE_MODELS</code> to <code>True</code>. Either as an environment variable or directly in the <code>ApiSettings</code>.</p> <p>With the introduction of Pydantic 2, the extra time it takes to validate models became negatable. While <code>ENABLE_RESPONSE_MODELS</code> still defaults to <code>False</code> there should be no penalty for users to turn on this feature but users discretion is advised.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># Install from PyPI\npython -m pip install stac-fastapi.types stac-fastapi.api stac-fastapi.extensions\n\n# Install a backend of your choice\npython -m pip install stac-fastapi.pgstac\n</code></pre> <p>Other backends may be available from other sources, search PyPI for more.</p>"},{"location":"#development","title":"Development","text":"<p>Install the packages in editable mode:</p> <p>We recommand using <code>uv</code> as project manager for development.</p> <p>See docs.astral.sh/uv/getting-started/installation/ for installation </p> <pre><code>uv sync --dev\n</code></pre> <p>To run the tests:</p> <pre><code>uv run pytest\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>See CONTRIBUTING.md. for detailed contribution instructions.</p>"},{"location":"#releasing","title":"Releasing","text":"<p>See RELEASING.md.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Issues and pull requests are more than welcome.</p> <p>We recommand using <code>uv</code> as project manager for development.</p> <p>See docs.astral.sh/uv/getting-started/installation/ for installation </p> <p>dev install</p> <pre><code>git clone https://github.com/stac-utils/stac-fastapi.git\ncd stac-fastapi\nuv sync --dev\n</code></pre> <p>pre-commit</p> <p>This repo is set to use <code>pre-commit</code> to run ruff, pydocstring and mypy when committing new code.</p> <pre><code>uv run pre-commit install \n\n# If needed, you can run pre-commit script manually \nuv run pre-commit run --all-files \n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<pre><code>git clone https://github.com/stac-utils/stac-fastapi.git\ncd stac-fastapi\n# Build docs\nuv run --group docs mkdocs build -f docs/mkdocs.yml\n</code></pre> <p>Hot-reloading docs:</p> <pre><code>uv run --group docs mkdocs serve -f docs/mkdocs.yml --livereload\n</code></pre> <p>To manually deploy docs (note you should never need to do this because GitHub Actions deploys automatically for new commits.):</p> <pre><code># deploy\nuv run --group docs mkdocs gh-deploy -f docs/mkdocs.yml\n</code></pre>"},{"location":"release-notes/","title":"Changelog","text":""},{"location":"release-notes/#unreleased","title":"Unreleased","text":""},{"location":"release-notes/#621-2026-02-10","title":"6.2.1 - 2026-02-10","text":""},{"location":"release-notes/#fixed","title":"Fixed","text":"<ul> <li>swap usage of vendored <code>CORSMiddleware</code> for the official one from starlette</li> <li>add deprecatation warning for <code>stac_fastapi.api.middleware.CORSMiddleware</code></li> </ul>"},{"location":"release-notes/#620-2026-01-13","title":"6.2.0 - 2026-01-13","text":""},{"location":"release-notes/#removed","title":"Removed","text":"<ul> <li>support for python 3.9 and 3.10</li> </ul>"},{"location":"release-notes/#615-2026-01-12","title":"6.1.5 - 2026-01-12","text":""},{"location":"release-notes/#fixed_1","title":"Fixed","text":"<ul> <li>default port handling in ProxyHeaderMiddleware for forwarded headers (#852)</li> </ul>"},{"location":"release-notes/#614-2025-12-12","title":"6.1.4 - 2025-12-12","text":""},{"location":"release-notes/#fixed_2","title":"Fixed","text":"<ul> <li>improve type hints</li> <li><code>api.app.StacAPI.search_get_request_model</code> now defined as <code>Type[APIRequest]</code></li> <li><code>api.app.StacAPI.search_post_request_model</code> now defined as <code>Type[BaseModel]</code></li> </ul>"},{"location":"release-notes/#613-2025-12-09","title":"6.1.3 - 2025-12-09","text":""},{"location":"release-notes/#fixed_3","title":"Fixed","text":"<ul> <li>fixed type hints</li> </ul>"},{"location":"release-notes/#612-2025-12-09","title":"6.1.2 - 2025-12-09","text":""},{"location":"release-notes/#fixed_4","title":"Fixed","text":"<ul> <li>fixed output type for <code>api.models.create_request_model</code> and <code>api.models.create_get_request_model</code> methods</li> </ul>"},{"location":"release-notes/#611-2025-11-23","title":"6.1.1 - 2025-11-23","text":""},{"location":"release-notes/#fixed_5","title":"Fixed","text":"<ul> <li>better support async/sync health check functions</li> </ul>"},{"location":"release-notes/#610-2025-10-30","title":"6.1.0 - 2025-10-30","text":""},{"location":"release-notes/#fixed_6","title":"Fixed","text":"<ul> <li>fixed typing of base_model and mixins parameters (#852)</li> <li>fixed FastAPI 0.119.0+ compatibility by updating <code>request_response</code> import from starlette to fastapi and removing upper version constraint (#856)</li> </ul>"},{"location":"release-notes/#changed","title":"Changed","text":"<ul> <li>switch to pyproject.toml for package metadata</li> <li>use <code>uv</code> for project managment</li> <li>add python 3.14 support</li> </ul>"},{"location":"release-notes/#600-2025-06-19","title":"6.0.0 - 2025-06-19","text":""},{"location":"release-notes/#changed_1","title":"Changed","text":"<ul> <li>move <code>transaction</code> clients and models to <code>stac_fastapi.extension</code> sub-module</li> <li>Add Item and Collection <code>PATCH</code> endpoints with support for RFC 6902 and RFC 7396 in the <code>TransactionExtension</code></li> <li>remove support of <code>cql-json</code> in Filter extension (#840)</li> <li>rename filter extension <code>FilterConformanceClasses</code> values and change the URLs:</li> <li><code>BASIC_SPATIAL_OPERATORS</code> -&gt; <code>BASIC_SPATIAL_FUNCTIONS</code></li> <li><code>TEMPORAL_OPERATORS</code> -&gt; <code>TEMPORAL_FUNCTIONS</code></li> <li><code>SPATIAL_OPERATORS</code> -&gt; <code>SPATIAL_FUNCTIONS</code></li> <li><code>ARRAYS</code> -&gt; <code>ARRAY_FUNCTIONS</code></li> <li><code>ACCENT_CASE_INSENSITIVE_COMPARISON</code> -&gt; <code>CASE_INSENSITIVE_COMPARISON</code></li> </ul>"},{"location":"release-notes/#added","title":"Added","text":"<ul> <li>add new values to filter extension <code>FilterConformanceClasses</code></li> <li><code>ACCENT_INSENSITIVE_COMPARISON</code></li> <li><code>BASIC_SPATIAL_FUNCTIONS_PLUS</code></li> </ul>"},{"location":"release-notes/#fixed_7","title":"Fixed","text":"<ul> <li>add <code>py.typed</code> to package distributions (#842)</li> <li>update/fix type informations (#842)</li> <li>pin <code>stac_pydantic</code> to <code>&gt;=3.3.0</code> for the correct import path of <code>stac_pydantic.shared.SearchDatetime</code> (#844)</li> </ul>"},{"location":"release-notes/#521-2025-04-18","title":"5.2.1 - 2025-04-18","text":""},{"location":"release-notes/#fixed_8","title":"Fixed","text":"<ul> <li>avoid future deprecation for pydantic.Field and use <code>json_schema_extra</code> instead of <code>openapi_examples</code></li> <li>use <code>orjson</code> based JSONResponse when available</li> <li>changed from <code>AssertionError</code> to <code>HTTPException</code> for bbox parsing exceptions</li> <li>update <code>$schema</code> in Filter's extension client responses to match OGC Feature specification</li> </ul>"},{"location":"release-notes/#added_1","title":"Added","text":"<ul> <li>add response model for <code>/_mgmt/health</code> endpoint</li> </ul>"},{"location":"release-notes/#520-2025-04-18","title":"5.2.0 - 2025-04-18","text":""},{"location":"release-notes/#fixed_9","title":"Fixed","text":"<ul> <li>Remove defaults in OpenAPI schemas</li> <li>Type Hints for TypedDict</li> </ul>"},{"location":"release-notes/#added_2","title":"Added","text":"<ul> <li>add <code>enable_direct_response</code> settings to by-pass Pydantic validation and FastAPI serialization for responses</li> <li>add <code>/_mgmt/health</code> endpoint (<code>readiness</code>) and <code>health_check: Callable[[], [Dict]</code> optional attribute in <code>StacApi</code> class</li> </ul>"},{"location":"release-notes/#511-2025-03-17","title":"5.1.1 - 2025-03-17","text":""},{"location":"release-notes/#fixed_10","title":"Fixed","text":"<ul> <li>allow bbox with 6 coordinates (3D) in <code>GET</code> requests</li> </ul>"},{"location":"release-notes/#510-2025-03-07","title":"5.1.0 - 2025-03-07","text":""},{"location":"release-notes/#added_3","title":"Added","text":"<ul> <li>titles in <code>Landing</code> page links</li> </ul>"},{"location":"release-notes/#changed_2","title":"Changed","text":"<ul> <li>remove <code>child</code> links (<code>collections</code>) in landing page response</li> </ul>"},{"location":"release-notes/#503-2025-03-03","title":"5.0.3 - 2025-03-03","text":""},{"location":"release-notes/#added_4","title":"Added","text":"<ul> <li>added descriptive message to <code>types.search.str2bbox</code> length assert</li> </ul>"},{"location":"release-notes/#fixed_11","title":"Fixed","text":"<ul> <li>fix collection-search POST request model:</li> <li>fix pydantic model to make sure class variables <code>_start_date</code> and <code>_end_date</code> not edited (ported from stac-pydantic)</li> <li>fix bbox validation to allow anti-meridian crossing (ported from stac-pydantic)</li> </ul>"},{"location":"release-notes/#502-2025-01-30","title":"5.0.2 - 2025-01-30","text":""},{"location":"release-notes/#fixed_12","title":"Fixed","text":"<ul> <li>forward <code>prefix</code> to <code>ItemCollectionFilterExtension.router</code></li> </ul>"},{"location":"release-notes/#501-2025-01-30","title":"5.0.1 - 2025-01-30","text":""},{"location":"release-notes/#fixed_13","title":"Fixed","text":"<ul> <li>add <code>Queryables</code> links when <code>SearchFilterExtension</code> is enabled</li> </ul>"},{"location":"release-notes/#500-2025-01-30","title":"5.0.0 - 2025-01-30","text":""},{"location":"release-notes/#changed_3","title":"Changed","text":"<ul> <li> <p>refactored conformance classes for extensions</p> </li> <li> <p>renamed <code>collection_search.ConformanceClasses</code> -&gt; <code>collection_search.CollectionSearchConformanceClasses</code></p> </li> <li>removed <code>FREETEXT</code>, <code>FILTER</code>, <code>QUERY</code>, <code>SORT</code> and <code>FIELDS</code> entries from the <code>CollectionSearchConformanceClasses</code> Enum (and moved to each extension's Enum)</li> <li>changed <code>collection_search.CollectionSearchPostExtension.from_extension(ext)</code> to use the conformance classes from the input extensions to derive the output conformance classes.</li> <li>added <code>fields.FieldsConformanceClasses</code> Enum</li> <li>renamed <code>filter.FilterConformanceClasses.FEATURES_FILTER</code> -&gt; <code>filter.FilterConformanceClasses.ITEMS</code></li> <li>renamed <code>filter.FilterConformanceClasses.ITEM_SEARCH_FILTER</code> -&gt; <code>filter.FilterConformanceClasses.SEARCH</code></li> <li>added <code>filter.FilterConformanceClasses.COLLECTIONS</code></li> <li>added <code>filter.SearchFilterExtension</code>, <code>filter.ItemCollectionFilterExtension</code> and <code>filter.CollectionSearchFilterExtension</code> endpoint specific extensions</li> <li>removed <code>FreeTextConformanceClasses.COLLECTIONS</code> and <code>FreeTextConformanceClasses.ITEMS</code> in <code>FreeTextExtension</code> and <code>FreeTextAdvancedExtension</code> default conformances classes</li> <li>added <code>query.QueryConformanceClasses</code> Enum</li> <li> <p>added <code>SortConformanceClasses</code> Enum</p> </li> <li> <p>removed <code>StacApi.customize_openapi</code> method</p> </li> <li>reordered <code>StacApi</code> attributes (moved <code>title</code>, <code>api_version</code> and <code>description</code> before <code>app</code>)</li> </ul>"},{"location":"release-notes/#added_5","title":"Added","text":"<ul> <li>forward <code>StacApi.title</code>, <code>StacApi.api_version</code> and <code>Stac.Api.description</code> to the FastAPI application</li> </ul>"},{"location":"release-notes/#401-2025-01-23","title":"4.0.1 - 2025-01-23","text":""},{"location":"release-notes/#changed_4","title":"Changed","text":"<ul> <li>sort conformance classes</li> </ul>"},{"location":"release-notes/#fixed_14","title":"Fixed","text":"<ul> <li>support <code>forwarded</code> headers in <code>ProxyHeaderMiddleware</code> that do not contain a host key (#788)</li> </ul>"},{"location":"release-notes/#400-2025-01-17","title":"4.0.0 - 2025-01-17","text":""},{"location":"release-notes/#changed_5","title":"Changed","text":"<ul> <li>use <code>string</code> type instead of python <code>datetime.datetime</code> for datetime parameter in <code>BaseSearchGetRequest</code>, <code>ItemCollectionUri</code> and <code>BaseCollectionSearchGetRequest</code> GET models</li> <li>rename <code>filter</code> to <code>filter_expr</code> for <code>FilterExtensionGetRequest</code> and <code>FilterExtensionPostRequest</code> attributes to avoid conflict with python filter method</li> <li>remove deprecated <code>post_request_model</code> attribute in <code>BaseCoreClient</code> and <code>AsyncBaseCoreClient</code></li> <li>remove <code>python3.8</code> support</li> </ul>"},{"location":"release-notes/#fixed_15","title":"Fixed","text":"<ul> <li>Support multiple proxy servers in the <code>forwarded</code> header in <code>ProxyHeaderMiddleware</code> (#782)</li> </ul>"},{"location":"release-notes/#305-2025-01-10","title":"3.0.5 - 2025-01-10","text":""},{"location":"release-notes/#removed_1","title":"Removed","text":"<ul> <li>Remove <code>warnings</code> in <code>CollectionSearchExtension.from_extensions()</code> methods when passing <code>unknown</code> extensions</li> </ul>"},{"location":"release-notes/#304-2025-01-08","title":"3.0.4 - 2025-01-08","text":""},{"location":"release-notes/#removed_2","title":"Removed","text":"<ul> <li>Remove deprecated <code>context</code> property in <code>types.stac.ItemCollection</code> model</li> </ul>"},{"location":"release-notes/#added_6","title":"Added","text":"<ul> <li>Add <code>numberMatched</code> and <code>numberReturned</code> properties in <code>types.stac.ItemCollection</code> model</li> <li>Add <code>numberMatched</code> and <code>numberReturned</code> properties in <code>types.stac.Collections</code> model</li> <li>Add <code>root_path</code> to <code>stac_fastapi.types.config.ApiSettings</code> and use it in the default FastAPI application</li> <li>Add <code>python3.13</code> support</li> </ul>"},{"location":"release-notes/#changed_6","title":"Changed","text":"<ul> <li>Use <code>stac_pydantic.version.STAC_VERSION</code> instead of <code>stac_pydantic.api.version.STAC_API_VERSION</code> as application <code>stac_version</code></li> <li>Return more informations from pydantic validation errors</li> <li>Add deprecation notice for <code>post_request_model</code> attribute in <code>BaseCoreClient</code> and <code>AsyncBaseCoreClient</code></li> </ul>"},{"location":"release-notes/#303-2024-10-09","title":"3.0.3 - 2024-10-09","text":""},{"location":"release-notes/#removed_3","title":"Removed","text":"<ul> <li>Removed <code>cql2-text</code> in supported <code>filter-lang</code> for <code>FilterExtensionPostRequest</code> model (as per specification)</li> </ul>"},{"location":"release-notes/#added_7","title":"Added","text":"<ul> <li>Add <code>OffsetPaginationExtension</code> extension to add <code>offset</code> query/body parameter to endpoints</li> </ul>"},{"location":"release-notes/#302-2024-09-20","title":"3.0.2 - 2024-09-20","text":""},{"location":"release-notes/#added_8","title":"Added","text":"<ul> <li>Add <code>from_extensions()</code> method to <code>CollectionSearchExtension</code> and <code>CollectionSearchPostExtension</code> extensions to build the class based on a list of available extensions (#745)</li> </ul>"},{"location":"release-notes/#301-2024-08-27","title":"3.0.1 - 2024-08-27","text":""},{"location":"release-notes/#changed_7","title":"Changed","text":"<ul> <li>Update fastapi version to <code>&gt;=0.109.0</code></li> </ul>"},{"location":"release-notes/#300-2024-07-29","title":"3.0.0 - 2024-07-29","text":"<p>Full changelog: stac-utils.github.io/stac-fastapi/migrations/v3.0.0/#changelog Changes since 3.0.0b3:</p>"},{"location":"release-notes/#changed_8","title":"Changed","text":"<ul> <li>Add version pinning (<code>~=3.0</code>) for stac-fastapi submodules</li> <li>Moved <code>AsyncBaseFiltersClient</code> and <code>BaseFiltersClient</code> classes in <code>stac_fastapi.extensions.core.filter.client</code> submodule</li> </ul>"},{"location":"release-notes/#removed_4","title":"Removed","text":"<ul> <li>Removed the <code>Context</code> extension</li> <li>Removed deprecated <code>stac_fastapi.api.openapi.config_openapi</code> method and <code>stac_fastapi.api.openapi.VndOaiResponse</code> class</li> <li>Removed <code>response_class</code> argument in <code>stac_fastapi.api.routes.create_async_endpoint</code> method</li> <li>Removed <code>filter_fields</code> property in <code>stac_fastapi.extensions.core.fields.request.PostFieldsExtension</code> class</li> </ul>"},{"location":"release-notes/#300b3-2024-07-25","title":"3.0.0b3 - 2024-07-25","text":""},{"location":"release-notes/#changed_9","title":"Changed","text":"<ul> <li>Add more openapi metadata in input models (#734)</li> <li>Use same <code>Limit</code> (capped to <code>10_000</code>) for <code>/items</code> and <code>GET - /search</code> input models (#738)</li> </ul>"},{"location":"release-notes/#added_9","title":"Added","text":"<ul> <li>Add Free-text Extension (#655)</li> <li>Add Collection-Search Extension (#736, #739)</li> </ul>"},{"location":"release-notes/#300b2-2024-07-09","title":"3.0.0b2 - 2024-07-09","text":""},{"location":"release-notes/#changed_10","title":"Changed","text":"<ul> <li>move back to <code>@attrs</code> (instead of dataclass) for <code>APIRequest</code> (model for GET request) class type (#729)</li> </ul>"},{"location":"release-notes/#300b1-2024-07-05","title":"3.0.0b1 - 2024-07-05","text":""},{"location":"release-notes/#added_10","title":"Added","text":"<ul> <li>Add attributes to <code>stac_fastapi.api.app.StacApi</code> to enable customization of request model for:</li> <li><code>/collections</code>: collections_get_request_model, default to <code>EmptyRequest</code></li> <li><code>/collections/{collection_id}</code>: collection_get_request_model, default to <code>CollectionUri</code></li> <li><code>/collections/{collection_id}/items</code>: items_get_request_model, default to <code>ItemCollectionUri</code></li> <li><code>/collections/{collection_id}/items/{item_id}</code>: item_get_request_model, default to <code>ItemUri</code></li> </ul>"},{"location":"release-notes/#removed_5","title":"Removed","text":"<ul> <li>Removed the Filter Extension dependency from <code>AggregationExtensionPostRequest</code> and <code>AggregationExtensionGetRequest</code> (#716)</li> <li>Removed <code>pagination_extension</code> attribute in <code>stac_fastapi.api.app.StacApi</code></li> <li>Removed use of <code>pagination_extension</code> in <code>register_get_item_collection</code> function (User now need to construct the request model and pass it using <code>items_get_request_model</code> attribute)</li> <li>Removed use of <code>FieldsExtension</code> in <code>stac_fastapi.api.app.StacApi</code>. If users use <code>FieldsExtension</code>, they would have to handle overpassing the model validation step by returning a <code>JSONResponse</code> from the <code>post_search</code> and <code>get_search</code> client methods.</li> </ul>"},{"location":"release-notes/#changed_11","title":"Changed","text":"<ul> <li>Replaced <code>@attrs</code> with python <code>@dataclass</code> for <code>APIRequest</code> (model for GET request) class type (#714)</li> <li>Moved <code>GETPagination</code>, <code>POSTPagination</code>, <code>GETTokenPagination</code> and <code>POSTTokenPagination</code> to <code>stac_fastapi.extensions.core.pagination.request</code> submodule (#717)</li> <li>update FastAPI requirement to <code>&gt;=0.111.0</code></li> </ul>"},{"location":"release-notes/#300a4-2024-06-27","title":"3.0.0a4 - 2024-06-27","text":""},{"location":"release-notes/#fixed_16","title":"Fixed","text":"<ul> <li>Updated default filter language in filter extension's POST search request model to match the extension's documentation (#711)</li> </ul>"},{"location":"release-notes/#removed_6","title":"Removed","text":"<ul> <li>Removed the Filter Extension depenency from <code>AggregationExtensionPostRequest</code> and <code>AggregationExtensionGetRequest</code> (#716)</li> <li>Removed <code>add_middleware</code> method in <code>StacApi</code> object and let starlette handle the middleware stack creation (#721)</li> </ul>"},{"location":"release-notes/#300a3-2024-06-13","title":"3.0.0a3 - 2024-06-13","text":""},{"location":"release-notes/#added_11","title":"Added","text":"<ul> <li>Add base support for the Aggregation extension (#684)</li> </ul>"},{"location":"release-notes/#changed_12","title":"Changed","text":"<ul> <li>Added option for default route dependencies <code>*</code> can be used for <code>path</code> or <code>method</code> to match all allowed route. (#705)</li> <li>Moved <code>AsyncBaseFiltersClient</code> and <code>BaseFiltersClient</code> classes in <code>stac_fastapi.extensions.core.filter.client</code> submodule (#704)</li> <li>Removed <code>default_includes</code> from <code>stac_fastapi.types.config.ApiSettings</code> (#706)</li> <li>Deprecated Fields extension <code>PostFieldsExtension.filter_fields</code> property (#706)</li> </ul>"},{"location":"release-notes/#300a2-2024-05-31","title":"3.0.0a2 - 2024-05-31","text":""},{"location":"release-notes/#fixed_17","title":"Fixed","text":"<ul> <li>Fix missing default (<code>None</code>) for optional <code>query</code> attribute in <code>QueryExtensionPostRequest</code> model (#701)</li> </ul>"},{"location":"release-notes/#300a1-2024-05-22","title":"3.0.0a1 - 2024-05-22","text":""},{"location":"release-notes/#changed_13","title":"Changed","text":"<ul> <li>Switch from <code>fastapi</code> to <code>fastapi-slim</code> to avoid installing unwanted dependencies. (#687)</li> <li>Replace Enum with <code>Literal</code> for <code>FilterLang</code>. (#686)</li> <li>Update stac-pydantic requirement to <code>~3.1</code> (#697)</li> </ul>"},{"location":"release-notes/#removed_7","title":"Removed","text":"<ul> <li>Pystac as it was just used for a datetime to string function. (#690)</li> </ul>"},{"location":"release-notes/#fixed_18","title":"Fixed","text":"<ul> <li>Make <code>str_to_interval</code> not return a tuple for single-value input (fixing <code>datetime</code> argument as passed to <code>get_search</code>). (#692)</li> </ul>"},{"location":"release-notes/#300a0-2024-05-06","title":"3.0.0a0 - 2024-05-06","text":""},{"location":"release-notes/#added_12","title":"Added","text":"<ul> <li>Add enhanced middleware configuration to the StacApi class, enabling specific middleware options and dynamic addition post-application initialization. (#442)</li> <li>Add Response Model to OpenAPI, even if model validation is turned off (#625)</li> </ul>"},{"location":"release-notes/#changed_14","title":"Changed","text":"<ul> <li>Update to pydantic v2 and stac_pydantic v3 (#625)</li> <li>Removed internal Search and Operator Types in favor of stac_pydantic Types (#625)</li> <li>Fix response model validation (#625)</li> <li>Use status code 201 for Item/Collection creation (#625)</li> <li>Replace Black with Ruff Format (#625)</li> <li>add <code>response_class</code> in the route definitions for <code>FilterExtension</code></li> </ul>"},{"location":"release-notes/#255post1-2024-04-25","title":"2.5.5.post1 - 2024-04-25","text":""},{"location":"release-notes/#fixed_19","title":"Fixed","text":"<ul> <li>Fix <code>service-doc</code> and <code>service-desc</code> url in landing page when using router prefix for <code>AsyncBaseCoreClient</code>. (#675)</li> </ul>"},{"location":"release-notes/#255-2024-04-24","title":"2.5.5 - 2024-04-24","text":""},{"location":"release-notes/#fixed_20","title":"Fixed","text":"<ul> <li>Fix <code>service-doc</code> and <code>service-desc</code> url in landing page when using router prefix. (#673)</li> </ul>"},{"location":"release-notes/#254-2024-04-24","title":"2.5.4 - 2024-04-24","text":""},{"location":"release-notes/#fixed_21","title":"Fixed","text":"<ul> <li>Fix missing payload for the PUT <code>collection/{collection_id}</code> endpoint (#665)</li> <li>Return 400 for datetime errors (#670)</li> </ul>"},{"location":"release-notes/#253-2024-04-23","title":"2.5.3 - 2024-04-23","text":""},{"location":"release-notes/#fixed_22","title":"Fixed","text":"<ul> <li>Remove the str2list converter from intersection queries via BaseSearchGetRequest (#668)</li> <li>Apply datetime converter in ItemCollection endpoint model (#667)</li> </ul>"},{"location":"release-notes/#252-2024-04-19","title":"2.5.2 - 2024-04-19","text":""},{"location":"release-notes/#fixed_23","title":"Fixed","text":"<ul> <li>BaseSearchGetRequest datetime validator str_to_interval not allowing GET /search requests with datetime = None (#662)</li> </ul>"},{"location":"release-notes/#251-2024-04-18","title":"2.5.1 - 2024-04-18","text":""},{"location":"release-notes/#fixed_24","title":"Fixed","text":"<ul> <li>Fixed warnings.warn deprecation syntax for response class and the context extension (#660)</li> </ul>"},{"location":"release-notes/#250-2024-04-12","title":"2.5.0 - 2024-04-12","text":""},{"location":"release-notes/#added_13","title":"Added","text":"<ul> <li>Add benchmark in CI (#650)</li> <li>Add <code>/queryables</code> link to the landing page (#587)</li> <li><code>id</code>, <code>title</code>, <code>description</code> and <code>api_version</code> fields can be customized via env variables</li> <li>Add <code>DeprecationWarning</code> for the <code>ContextExtension</code></li> <li>Add support for Python 3.12</li> </ul>"},{"location":"release-notes/#changed_15","title":"Changed","text":"<ul> <li>Updated the collection update endpoint to match with the collection-transaction extension. (#630)</li> <li>Improve bbox and datetime typing (#490</li> <li>Add <code>items</code> link to inferred link relations (#634)</li> <li>Make sure FastAPI uses Pydantic validation and serialization by not wrapping endpoint output with a Response object (#650)</li> <li>Allow <code>GeometryCollections</code> for <code>intersects</code> parameter in POST search queries (#548)</li> </ul>"},{"location":"release-notes/#removed_8","title":"Removed","text":"<ul> <li>Deprecate <code>response_class</code> option in <code>stac_fastapi.api.routes.create_async_endpoint</code> method (#650)</li> </ul>"},{"location":"release-notes/#249-2023-11-17","title":"2.4.9 - 2023-11-17","text":""},{"location":"release-notes/#added_14","title":"Added","text":"<ul> <li>Add CQL2-json to filter conformance class (#611)</li> <li>Add Elasticsearch backend (#616)</li> </ul>"},{"location":"release-notes/#changed_16","title":"Changed","text":"<ul> <li>Forward <code>x-forwarded-host</code> (#586)</li> <li>Add <code>method</code> parameter to Bulk Transactions extension in order to support upserting bulk data (#614)</li> </ul>"},{"location":"release-notes/#248-2023-06-07","title":"2.4.8 - 2023-06-07","text":""},{"location":"release-notes/#changed_17","title":"Changed","text":"<ul> <li>Advertise STAC API v1.0.0 (#578)</li> </ul>"},{"location":"release-notes/#247-2023-05-16","title":"2.4.7 - 2023-05-16","text":""},{"location":"release-notes/#added_15","title":"Added","text":"<ul> <li>Add support for POSTing ItemCollections to the /items endpoint of the Transaction Extension (#547)</li> </ul>"},{"location":"release-notes/#changed_18","title":"Changed","text":"<ul> <li>flake8, isort, and pydocstyle replaced by ruff for pre-commit checks (#549)</li> </ul>"},{"location":"release-notes/#246-2023-05-09","title":"2.4.6 - 2023-05-09","text":""},{"location":"release-notes/#changed_19","title":"Changed","text":"<ul> <li>Backends are now hosted in their own repositories ([stac-utils/stac-fastapi!555]):</li> <li>stac-fastapi-pgstac</li> <li>stac-fastapi-sqlalchemy</li> </ul>"},{"location":"release-notes/#245-2023-04-04","title":"2.4.5 - 2023-04-04","text":""},{"location":"release-notes/#changed_20","title":"Changed","text":"<ul> <li>Default branch to main (#544)</li> </ul>"},{"location":"release-notes/#fixed_25","title":"Fixed","text":"<ul> <li>Use <code>V()</code> instead of f-strings for pgstac queries (#554)</li> </ul>"},{"location":"release-notes/#244-2023-03-09","title":"2.4.4 - 2023-03-09","text":""},{"location":"release-notes/#added_16","title":"Added","text":"<ul> <li>Nginx service as second docker-compose stack to demonstrate proxy (#503)</li> <li>Validation checks in CI using stac-api-validator (#508)</li> <li>Required links to the sqlalchemy ItemCollection endpoint (#508)</li> <li>Publication of docker images to GHCR (#525)</li> </ul>"},{"location":"release-notes/#changed_21","title":"Changed","text":"<ul> <li>Updated CI to test against pgstac v0.6.12 (#511)</li> <li>Reworked <code>update_openapi</code> and added a test for it (#523)</li> <li>Limit values above 10,000 are now replaced with 10,000 instead of returning a 400 error (#526)</li> <li>Updated pgstac to v0.7.1 (#535)</li> </ul>"},{"location":"release-notes/#removed_9","title":"Removed","text":"<ul> <li>Incorrect context STAC extension url from the landing page (#508)</li> </ul>"},{"location":"release-notes/#fixed_26","title":"Fixed","text":"<ul> <li>Allow url encoded values for <code>query</code> in GET requests (#504)</li> <li>Fix path in <code>register_update_item</code> docstring (#507)</li> <li><code>self</code> link rel for <code>/collections/{c_id}/items</code> (#508)</li> <li>Media type of the item collection endpoint (#508)</li> <li>Manually exclude non-truthy optional values from sqlalchemy serialization of Collections (#508)</li> <li>Support <code>intersects</code> in GET requests (#521)</li> <li>Deleting items that had repeated ids in other collections (#520)</li> <li>404 for missing collection on /items for sqlalchemy (#528)</li> <li>Conformance URIs for the filter extension (#540)</li> </ul>"},{"location":"release-notes/#deprecated","title":"Deprecated","text":"<ul> <li>Deprecated <code>VndOaiResponse</code> and <code>config_openapi</code>, will be removed in v3.0 (#523)</li> </ul>"},{"location":"release-notes/#243-2022-11-25","title":"2.4.3 - 2022-11-25","text":""},{"location":"release-notes/#added_17","title":"Added","text":"<ul> <li>Add the <code>ENABLED_EXTENSIONS</code> environment variable determining which extensions are enabled in the pgstac application, all extensions are enabled by default (#495)</li> </ul>"},{"location":"release-notes/#changed_22","title":"Changed","text":""},{"location":"release-notes/#removed_10","title":"Removed","text":""},{"location":"release-notes/#fixed_27","title":"Fixed","text":""},{"location":"release-notes/#242-2022-11-25","title":"2.4.2 - 2022-11-25","text":""},{"location":"release-notes/#added_18","title":"Added","text":"<ul> <li>Add support in pgstac backend for /queryables and /collections/{collection_id}/queryables endpoints with functions exposed in pgstac 0.6.8 (#474)</li> <li>Add <code>bbox</code> and <code>datetime</code> query parameters to <code>/collections/{collection_id}/items</code>. (#476, #380)</li> <li>Update pgstac requirement to 0.6.10</li> <li>Add <code>servers</code> and <code>description</code> to OpenAPI (#459)</li> </ul>"},{"location":"release-notes/#changed_23","title":"Changed","text":""},{"location":"release-notes/#removed_11","title":"Removed","text":"<ul> <li>Removed <code>stac_fastapi.api.routes.create_sync_endpoint</code> function to reduce code duplication (#471)</li> </ul>"},{"location":"release-notes/#fixed_28","title":"Fixed","text":"<ul> <li>Quote password in pgsql strings to accomodate special characters. (#455)</li> <li>Fix pgstac backend for /queryables endpoint to return 404 for non-existent collections (#482)</li> <li><code>/collection/{collection_id}/items</code> endpoints now return geojson media type (#488)</li> </ul>"},{"location":"release-notes/#241-2022-08-05","title":"2.4.1 - 2022-08-05","text":""},{"location":"release-notes/#added_19","title":"Added","text":""},{"location":"release-notes/#changed_24","title":"Changed","text":""},{"location":"release-notes/#removed_12","title":"Removed","text":""},{"location":"release-notes/#fixed_29","title":"Fixed","text":"<ul> <li><code>ciso8601</code> fails to build in some environments, instead use <code>pyiso8601</code> to parse datetimes.</li> </ul>"},{"location":"release-notes/#240-2022-08-04","title":"2.4.0 - 2022-08-04","text":""},{"location":"release-notes/#added_20","title":"Added","text":"<ul> <li>Add hook to allow adding dependencies to routes. (#295)</li> <li>Ability to POST an ItemCollection to the collections/{collectionId}/items route. (#367)</li> <li>Add STAC API - Collections conformance class. (383)</li> <li>Bulk item inserts for pgstac implementation. (411)</li> <li>Add APIRouter prefix support for pgstac implementation. (429)</li> <li>Respect <code>Forwarded</code> or <code>X-Forwarded-*</code> request headers when building links to better accommodate load balancers and proxies.</li> </ul>"},{"location":"release-notes/#changed_25","title":"Changed","text":"<ul> <li>Update FastAPI requirement to allow version &gt;=0.73 (#337)</li> <li>Bump version of PGStac to 0.4.5  (#346)</li> <li>Add support for PGStac Backend to use PyGeofilter to convert Get Request with cql2-text into cql2-json to send to PGStac backend (#346)</li> <li>Updated all conformance classes to 1.0.0-rc.1. (383)</li> <li>Bulk Transactions object Items iterator now returns the Item objects rather than the string IDs of the Item objects   (#355)</li> <li>docker-compose now runs uvicorn with hot-reloading enabled</li> <li>Bump version of PGStac to 0.6.2 that includes support for hydrating results in the API backed (#397)</li> <li>Make item geometry and bbox nullable in sqlalchemy backend. (#398)</li> <li>Transactions Extension update Item endpoint Item is now <code>/collections/{collection_id}/items/{item_id}</code> instead of   <code>/collections/{collection_id}/items</code> to align with STAC API   spec (#425)</li> </ul>"},{"location":"release-notes/#removed_13","title":"Removed","text":"<ul> <li>Remove the unused <code>router_middleware</code> function (#439)</li> </ul>"},{"location":"release-notes/#fixed_30","title":"Fixed","text":"<ul> <li>Bumped uvicorn version to 0.17 (from &gt;=0.12, &lt;=0.14) to resolve security vulnerability related to websockets dependency version (#343)</li> <li><code>AttributeError</code> and/or missing properties when requesting the complete <code>properties</code>-field in searches. Added test. (#339)</li> <li>Fixes issues (and adds tests) for issues caused by regression in pgstac (#345</li> <li>Update error response payloads to match the API spec. (#361)</li> <li>Fixed stray <code>/</code> before the <code>#</code> in several extension conformance class strings (383)</li> <li>SQLAlchemy backend bulk item insert now works (#356)</li> <li>PGStac Backend has stricter implementation of Fields Extension syntax (#397)</li> <li><code>/queryables</code> endpoint now has type <code>application/schema+json</code> instead of <code>application/json</code> (#421)</li> <li>Transactions Extension update Item endpoint validates that the <code>{collection_id}</code> path parameter matches the Item <code>\"collection\"</code> property   from the request body, if present, and falls back to using the path parameter if no <code>\"collection\"</code> property is found in the body   (#425)</li> <li>PGStac Backend Transactions endpoints return added Item/Collection instead of Item/Collection from request (#424)</li> <li>Application no longer breaks on startup when pagination extension is not included (#444)</li> </ul>"},{"location":"release-notes/#230-2022-01-18","title":"2.3.0 - 2022-01-18","text":""},{"location":"release-notes/#added_21","title":"Added","text":"<ul> <li>Add link with rel-type of 'service-doc', pointing to HTML API documentation (#298)</li> </ul>"},{"location":"release-notes/#changed_26","title":"Changed","text":"<ul> <li>Refactor to remove hardcoded search request models. Request models are now dynamically created based on the enabled extensions.   (#213)</li> <li>Change example data to use correct <code>type</code> for the example Joplin collection (#314)</li> <li>Changed the geometry type in the Item model from Polygon to Geometry.</li> <li>Upgrade pgstac backend to use version 0.4.2 (#321)</li> <li>STAC 1.0.0-beta.4 conformance classes updated (#298)</li> <li>Upgrade pgstac backend to use version 0.4.3 (#326)</li> </ul>"},{"location":"release-notes/#removed_14","title":"Removed","text":"<ul> <li>The tiles extension and all tiles links, added for demonstration purposes, have been removed. (#309)</li> </ul>"},{"location":"release-notes/#fixed_31","title":"Fixed","text":"<ul> <li>Import error using <code>importlib.util</code> (#325)</li> <li>Add environment variables required by upgraded pgstac container (#313)</li> <li>Enabled <code>ContextExtension</code> by default (#207)</li> <li>Content-type response headers for the /search endpoint now reflect the geojson response expected in the STAC api spec (#220)</li> <li>The minimum <code>limit</code> value for searches is now 1 (#296)</li> <li>Links stored with Collections and Items (e.g. license links) are now returned with those STAC objects (#282)</li> <li>Content-type response headers for the /api endpoint now reflect those expected in the STAC api spec (#287)</li> <li>Changed type options for datetime in BaseSearchGetRequest (#318)</li> <li>Expanded on tests to ensure properly testing get and post searches (#318)</li> <li>Ensure invalid datetimes result in 400s (#323)</li> </ul>"},{"location":"release-notes/#220-2021-10-19","title":"2.2.0 - 2021-10-19","text":""},{"location":"release-notes/#added_22","title":"Added","text":"<ul> <li>Add CQL2 support (#308)</li> <li>Add ability to override ItemCollectionUri and SearchGetRequest models (#271)</li> <li>Added <code>collections</code> attribute to list of default fields to include, so that we satisfy the STAC API spec, which requires a <code>collections</code> attribute to be output when an item is part of a collection (#276)</li> </ul>"},{"location":"release-notes/#changed_27","title":"Changed","text":"<ul> <li>Update pgstac to 0.4.0 (#308)</li> <li>Update get_item in sqlalchemy backend to allow for querying for items with same ids but in different collections. (#275)</li> </ul>"},{"location":"release-notes/#211-2021-09-23","title":"2.1.1 - 2021-09-23","text":""},{"location":"release-notes/#added_23","title":"Added","text":"<ul> <li>Add <code>middlewares</code> option in <code>stac_fastapi.api.StacApi</code> to allow custom middleware configuration (#267)</li> <li>Support non-interval datetime queries on sqlalchemy backend (#262)</li> <li>Restrict <code>limit</code> parameter in sqlalchemy backend to between 1 and 10,000. (#251)</li> <li>Fix OAS conformance URL (#263)</li> <li>Links to children collections from the landing pagge always have a title (#260)</li> <li>Fix collection links in the <code>all_collections</code> method in <code>pgstac</code> (#269)</li> </ul>"},{"location":"release-notes/#fixed_32","title":"Fixed","text":"<ul> <li>Pin FastAPI to 0.67 to avoid issues with rendering OpenAPI documentation (#246)</li> <li>Add <code>stac_version</code> to default search attributes (#268)</li> <li>pgstac backend specifies collection_id when fetching a single item (#279)</li> </ul>"},{"location":"release-notes/#210-2021-08-26","title":"2.1.0 - 2021-08-26","text":""},{"location":"release-notes/#added_24","title":"Added","text":"<ul> <li>Added filter extension. (#165)</li> <li>Add Support for CQL JSON to PGStac Backend (#209)</li> <li>Added item_serializer and item_table to BulkTransactionsClient in sqlalchemy backend (#210)</li> <li>Enable conformance class configuration (#214)</li> <li>Add/fix landing page links (#229)</li> <li>Correct response codes for bad/unusable bboxes (#235)</li> <li>Add a \"method\" field for search links (#236)</li> <li>Add extension schemas to landing (#237)</li> </ul>"},{"location":"release-notes/#removed_15","title":"Removed","text":"<ul> <li>Remove shapely from stac_fastapi.pgstac requirements (#225)</li> </ul>"},{"location":"release-notes/#changed_28","title":"Changed","text":"<ul> <li>Update to STAC API 1.0.0-beta.3 (#239)</li> </ul>"},{"location":"release-notes/#fixed_33","title":"Fixed","text":"<ul> <li>Make collection title optional in landing page links (#198)</li> <li>Preserve relative paths on link generation (#199)</li> <li>Fix collection endpoint return value to match spec (fixes regression) (#232)</li> <li>Return empty item collection instead of error when searching (#233)</li> <li>Correct response codes for bad/unusable bboxes (#235)</li> <li>Update pgstac to return 400 on invalid date parameter (#240)</li> </ul>"},{"location":"release-notes/#200-2021-07-26","title":"2.0.0 - 2021-07-26","text":"<ul> <li>Refactor stac-fastapi into submodules (#106stac-utils/stac-fastapi/pull/106)</li> <li>Add pgstac backend (#126)</li> <li>Upgrade to stac-pydantic 2.0.0 and stac-spec 1.0.0 (#181)</li> </ul>"},{"location":"release-notes/#110-2021-01-28","title":"1.1.0 - 2021-01-28","text":"<ul> <li>Improve how the library declares API extensions (#54)</li> <li>Add postgres bulk transactions client (#59)</li> <li>Update TiTiler version (#61)</li> <li>Use attrs instead of dataclasses (#73)</li> <li>Remove postgres database connection from API layer (#74)</li> <li>Fix <code>pre-commit</code> config (#75)</li> </ul>"},{"location":"release-notes/#100-2020-09-28","title":"1.0.0 - 2020-09-28","text":"<ul> <li>First PyPi release!</li> </ul>"},{"location":"tips-and-tricks/","title":"Tips and Tricks","text":"<p>This page contains a few 'tips and tricks' for getting stac-fastapi working in various situations.</p>"},{"location":"tips-and-tricks/#avoid-fastapi-slow-serialization","title":"Avoid FastAPI (slow) serialization","text":"<p>When not using Pydantic validation for responses, FastAPI will still use a complex (slow) serialization process.</p> <p>Starting with stac-fastapi <code>5.2.0</code>, we've added <code>ENABLE_DIRECT_RESPONSE</code> option to by-pass the default FastAPI serialization by wrapping the endpoint responses into <code>starlette.Response</code> classes.</p> <p>Ref: stac-utils/stac-fastapi-elasticsearch-opensearch#347</p>"},{"location":"tips-and-tricks/#application-middlewares","title":"Application Middlewares","text":"<p>By default the <code>StacApi</code> class will enable 3 Middlewares (<code>BrotliMiddleware</code>, <code>CORSMiddleware</code> and <code>ProxyHeaderMiddleware</code>). You may want to overwrite the defaults configuration by editing your backend's <code>app.py</code>:</p> <pre><code>from starlette.middleware import Middleware\n\nfrom stac_fastapi.api.app import StacApi\nfrom stac_fastapi.api.middleware import CORSMiddleware\n\napi = StacApi(\n    ...\n    middlewares=[\n        Middleware(CORSMiddleware, allow_origins=[\"https://myendpoints.io\"])\n    ],\n    ...\n)\n</code></pre>"},{"location":"tips-and-tricks/#set-api-title-description-and-version","title":"Set API title, description and version","text":"<p>For the landing page, you can set the API title, description and version using environment variables.</p> <ul> <li><code>STAC_FASTAPI_VERSION</code> (string) is the version number of your API instance (this is not the STAC version).</li> <li><code>STAC FASTAPI_TITLE</code> (string) should be a self-explanatory title for your API.</li> <li><code>STAC FASTAPI_DESCRIPTION</code> (string) should be a good description for your API. It can contain CommonMark.</li> <li><code>STAC_FASTAPI_LANDING_ID</code> (string) is a unique identifier for your Landing page.</li> </ul>"},{"location":"tips-and-tricks/#default-includes-in-fields-extension-post-request","title":"Default <code>includes</code> in Fields extension (POST request)","text":"<p>The Fields API extension enables to filter in/out STAC Items keys (e.g <code>geometry</code>). The default behavior is to not filter out anything, but this can be overridden by providing a custom <code>FieldsExtensionPostRequest</code> class:</p> <pre><code>from typing import Optional, Set\n\nimport attr\nfrom stac_fastapi.extensions.core import FieldsExtension as FieldsExtensionBase\nfrom stac_fastapi.extensions.core.fields import request\nfrom pydantic import BaseModel, Field\n\n\nclass PostFieldsExtension(requests.PostFieldsExtension):\n    include: Optional[Set[str]] = Field(\n        default_factory=lambda: {\n            \"id\",\n            \"type\",\n            \"stac_version\",\n            \"geometry\",\n            \"bbox\",\n            \"links\",\n            \"assets\",\n            \"properties.datetime\",\n            \"collection\",\n        }\n    )\n    exclude: Optional[Set[str]] = set()\n\n\nclass FieldsExtensionPostRequest(BaseModel):\n    \"\"\"Additional fields and schema for the POST request.\"\"\"\n\n    fields: Optional[PostFieldsExtension] = Field(PostFieldsExtension())\n\n\nclass FieldsExtension(FieldsExtensionBase):\n    \"\"\"Override the POST model\"\"\"\n\n    POST = FieldsExtensionPostRequest\n\n\nfrom stac_fastapi.api.app import StacApi\n\nstac = StacApi(\n    extensions=[\n        FieldsExtension()\n    ]\n)\n</code></pre>"},{"location":"api/stac_fastapi/","title":"Namespace stac_fastapi","text":""},{"location":"api/stac_fastapi/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.api</li> <li>stac_fastapi.extensions</li> <li>stac_fastapi.types</li> </ul>"},{"location":"api/stac_fastapi/api/","title":"Module stac_fastapi.api","text":"<p>Api submodule.</p>"},{"location":"api/stac_fastapi/api/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.api.app</li> <li>stac_fastapi.api.config</li> <li>stac_fastapi.api.errors</li> <li>stac_fastapi.api.middleware</li> <li>stac_fastapi.api.models</li> <li>stac_fastapi.api.openapi</li> <li>stac_fastapi.api.routes</li> </ul>"},{"location":"api/stac_fastapi/api/app/","title":"app","text":""},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app","title":"stac_fastapi.api.app","text":"<p>Fastapi app creation.</p>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi","title":"StacApi","text":"<p>StacApi factory.</p> <p>Factory for creating a STAC-compliant FastAPI application.  After instantation, the application is accessible from the <code>StacApi.app</code> attribute.</p> <p>Attributes:</p> <ul> <li> <code>settings</code>               (<code>ApiSettings</code>)           \u2013            <p>API settings and configuration, potentially using environment variables. See pydantic-docs.helpmanual.io/usage/settings/.</p> </li> <li> <code>client</code>               (<code>Union[AsyncBaseCoreClient, BaseCoreClient]</code>)           \u2013            <p>A subclass of <code>stac_api.clients.BaseCoreClient</code>.  Defines the application logic which is injected into the API.</p> </li> <li> <code>extensions</code>               (<code>List[ApiExtension]</code>)           \u2013            <p>API extensions to include with the application.  This may include official STAC extensions as well as third-party add ons.</p> </li> <li> <code>exceptions</code>               (<code>Dict[Type[Exception], int]</code>)           \u2013            <p>Defines a global mapping between exceptions and status codes, allowing configuration of response behavior on certain exceptions (fastapi.tiangolo.com/tutorial/handling-errors/#install-custom-exception-handlers).</p> </li> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>The FastAPI application, defaults to a fresh application.</p> </li> <li> <code>route_dependencies</code>               (<code>List[Tuple[List[Scope], List[Depends]]]</code>)           \u2013            <p>List of tuples of route scope dicts (eg <code>{'path': '/collections', 'method': 'POST'}</code>) and list of dependencies (e.g. <code>[Depends(oauth2_scheme)]</code>)).  Applies specified dependencies to specified routes. This is useful for applying custom auth requirements to routes defined elsewhere in the application.</p> </li> <li> <code>health_check</code>               (<code>Union[Callable[[], Dict], Callable[[], Awaitable[Dict]]]</code>)           \u2013            <p>A Callable which return application's <code>health</code> information. Defaults to <code>def health: return {\"status\": \"UP\"}</code></p> </li> </ul> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>@attr.s\nclass StacApi:\n    \"\"\"StacApi factory.\n\n    Factory for creating a STAC-compliant FastAPI application.  After\n    instantation, the application is accessible from the `StacApi.app` attribute.\n\n    Attributes:\n        settings:\n            API settings and configuration, potentially using environment\n            variables. See https://pydantic-docs.helpmanual.io/usage/settings/.\n        client:\n            A subclass of `stac_api.clients.BaseCoreClient`.  Defines the\n            application logic which is injected into the API.\n        extensions:\n            API extensions to include with the application.  This may include\n            official STAC extensions as well as third-party add ons.\n        exceptions:\n            Defines a global mapping between exceptions and status codes,\n            allowing configuration of response behavior on certain exceptions\n            (https://fastapi.tiangolo.com/tutorial/handling-errors/#install-custom-exception-handlers).\n        app:\n            The FastAPI application, defaults to a fresh application.\n        route_dependencies:\n            List of tuples of route scope dicts (eg `{'path':\n            '/collections', 'method': 'POST'}`) and list of dependencies (e.g.\n            `[Depends(oauth2_scheme)]`)).  Applies specified dependencies to\n            specified routes. This is useful\n            for applying custom auth requirements to routes defined elsewhere in\n            the application.\n        health_check:\n            A Callable which return application's `health` information.\n            Defaults to `def health: return {\"status\": \"UP\"}`\n\n    \"\"\"\n\n    settings: ApiSettings = attr.ib()\n    client: Union[AsyncBaseCoreClient, BaseCoreClient] = attr.ib()\n    extensions: List[ApiExtension] = attr.ib(default=attr.Factory(list))\n    exceptions: Dict[Type[Exception], int] = attr.ib(\n        default=attr.Factory(lambda: DEFAULT_STATUS_CODES)\n    )\n    title: str = attr.ib(\n        default=attr.Factory(\n            lambda self: self.settings.stac_fastapi_title, takes_self=True\n        )\n    )\n    api_version: str = attr.ib(\n        default=attr.Factory(\n            lambda self: self.settings.stac_fastapi_version, takes_self=True\n        )\n    )\n    stac_version: str = attr.ib(default=STAC_VERSION)\n    description: str = attr.ib(\n        default=attr.Factory(\n            lambda self: self.settings.stac_fastapi_description, takes_self=True\n        )\n    )\n    app: FastAPI = attr.ib(\n        default=attr.Factory(\n            lambda self: FastAPI(\n                openapi_url=self.settings.openapi_url,\n                docs_url=self.settings.docs_url,\n                redoc_url=None,\n                root_path=self.settings.root_path,\n                title=self.title,\n                version=self.api_version,\n                description=self.description,\n            ),\n            takes_self=True,\n        ),\n        converter=update_openapi,  # type: ignore\n    )\n    router: APIRouter = attr.ib(default=attr.Factory(APIRouter))\n    search_get_request_model: Type[APIRequest] = attr.ib(default=BaseSearchGetRequest)\n    search_post_request_model: Type[BaseModel] = attr.ib(default=BaseSearchPostRequest)\n    collections_get_request_model: Type[APIRequest] = attr.ib(default=EmptyRequest)\n    collection_get_request_model: Type[APIRequest] = attr.ib(default=CollectionUri)\n    items_get_request_model: Type[APIRequest] = attr.ib(default=ItemCollectionUri)\n    item_get_request_model: Type[APIRequest] = attr.ib(default=ItemUri)\n    response_class: Type[Response] = attr.ib(default=JSONResponse)\n    middlewares: List[Middleware] = attr.ib(\n        default=attr.Factory(\n            lambda: [\n                Middleware(BrotliMiddleware),\n                Middleware(\n                    CORSMiddleware,\n                    # Set CORS defaults to those recommended by the STAC API spec\n                    allow_origins=[\"*\"],\n                    allow_methods=[\"OPTIONS\", \"POST\", \"GET\"],\n                    allow_headers=[\"Content-Type\"],\n                    max_age=600,\n                ),\n                Middleware(ProxyHeaderMiddleware),\n            ]\n        )\n    )\n    route_dependencies: List[Tuple[List[Scope], List[Depends]]] = attr.ib(default=[])\n    health_check: Union[Callable[[], Dict], Callable[[], Awaitable[Dict]]] = attr.ib(\n        default=lambda: {\"status\": \"UP\"}\n    )\n\n    def get_extension(self, extension: Type[ApiExtension]) -&gt; Optional[ApiExtension]:\n        \"\"\"Get an extension.\n\n        Args:\n            extension: extension to check for.\n\n        Returns:\n            The extension instance, if it exists.\n        \"\"\"\n        for ext in self.extensions:\n            if isinstance(ext, extension):\n                return ext\n        return None\n\n    def register_landing_page(self) -&gt; None:\n        \"\"\"Register landing page (GET /).\"\"\"\n        self.router.add_api_route(\n            name=\"Landing Page\",\n            path=\"/\",\n            response_model=(\n                api.LandingPage if self.settings.enable_response_models else None\n            ),\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": api.LandingPage,\n                },\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=False,\n            response_model_exclude_none=True,\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(self.client.landing_page, EmptyRequest),\n        )\n\n    def register_conformance_classes(self) -&gt; None:\n        \"\"\"Register conformance classes (GET /conformance).\"\"\"\n        self.router.add_api_route(\n            name=\"Conformance Classes\",\n            path=\"/conformance\",\n            response_model=(\n                api.Conformance if self.settings.enable_response_models else None\n            ),\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": api.Conformance,\n                },\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(self.client.conformance, EmptyRequest),\n        )\n\n    def register_get_item(self) -&gt; None:\n        \"\"\"Register get item endpoint (GET /collections/{collection_id}/items/{item_id}).\"\"\"  # noqa: E501\n        self.router.add_api_route(\n            name=\"Get Item\",\n            path=\"/collections/{collection_id}/items/{item_id}\",\n            response_model=api.Item if self.settings.enable_response_models else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": api.Item,\n                },\n            },\n            response_class=GeoJSONResponse,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(\n                self.client.get_item, self.item_get_request_model\n            ),\n        )\n\n    def register_post_search(self) -&gt; None:\n        \"\"\"Register search endpoint (POST /search).\"\"\"\n        self.router.add_api_route(\n            name=\"Search\",\n            path=\"/search\",\n            response_model=api.ItemCollection\n            if self.settings.enable_response_models\n            else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": api.ItemCollection,\n                },\n            },\n            response_class=GeoJSONResponse,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"POST\"],\n            endpoint=create_async_endpoint(\n                self.client.post_search, self.search_post_request_model\n            ),\n        )\n\n    def register_get_search(self) -&gt; None:\n        \"\"\"Register search endpoint (GET /search).\"\"\"\n        self.router.add_api_route(\n            name=\"Search\",\n            path=\"/search\",\n            response_model=api.ItemCollection\n            if self.settings.enable_response_models\n            else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": api.ItemCollection,\n                },\n            },\n            response_class=GeoJSONResponse,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(\n                self.client.get_search, self.search_get_request_model\n            ),\n        )\n\n    def register_get_collections(self) -&gt; None:\n        \"\"\"Register get collections endpoint (GET /collections).\"\"\"\n        self.router.add_api_route(\n            name=\"Get Collections\",\n            path=\"/collections\",\n            response_model=(\n                api.Collections if self.settings.enable_response_models else None\n            ),\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": api.Collections,\n                },\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(\n                self.client.all_collections, self.collections_get_request_model\n            ),\n        )\n\n    def register_get_collection(self) -&gt; None:\n        \"\"\"Register get collection endpoint (GET /collection/{collection_id}).\"\"\"\n        self.router.add_api_route(\n            name=\"Get Collection\",\n            path=\"/collections/{collection_id}\",\n            response_model=api.Collection\n            if self.settings.enable_response_models\n            else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": api.Collection,\n                },\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(\n                self.client.get_collection, self.collection_get_request_model\n            ),\n        )\n\n    def register_get_item_collection(self) -&gt; None:\n        \"\"\"Register get item collection endpoint (GET /collection/{collection_id}/items).\"\"\"  # noqa: E501\n        self.router.add_api_route(\n            name=\"Get ItemCollection\",\n            path=\"/collections/{collection_id}/items\",\n            response_model=(\n                api.ItemCollection if self.settings.enable_response_models else None\n            ),\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": api.ItemCollection,\n                },\n            },\n            response_class=GeoJSONResponse,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(\n                self.client.item_collection, self.items_get_request_model\n            ),\n        )\n\n    def register_core(self) -&gt; None:\n        \"\"\"Register core STAC endpoints.\n\n            GET /\n            GET /conformance\n            GET /collections\n            GET /collections/{collection_id}\n            GET /collections/{collection_id}/items\n            GET /collection/{collection_id}/items/{item_id}\n            GET /search\n            POST /search\n\n        Injects application logic (StacApi.client) into the API layer.\n\n        \"\"\"\n        self.register_landing_page()\n        self.register_conformance_classes()\n        self.register_get_item()\n        self.register_post_search()\n        self.register_get_search()\n        self.register_get_collections()\n        self.register_get_collection()\n        self.register_get_item_collection()\n\n    def add_health_check(self) -&gt; None:\n        \"\"\"Add a health check.\"\"\"\n\n        mgmt_router = APIRouter(prefix=self.app.state.router_prefix)\n\n        async def ping():\n            \"\"\"Liveliness probe.\"\"\"\n            return {\"message\": \"PONG\"}\n\n        mgmt_router.add_api_route(\n            name=\"Ping\",\n            path=\"/_mgmt/ping\",\n            response_model=Dict,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                },\n            },\n            response_class=self.response_class,\n            methods=[\"GET\"],\n            endpoint=ping,\n        )\n\n        mgmt_router.add_api_route(\n            name=\"Health\",\n            path=\"/_mgmt/health\",\n            response_model=(\n                HealthCheck if self.settings.enable_response_models else None\n            ),\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": HealthCheck,\n                },\n            },\n            response_class=self.response_class,\n            methods=[\"GET\"],\n            endpoint=self.health_check\n            if inspect.iscoroutinefunction(self.health_check)\n            else sync_to_async(self.health_check),\n        )\n        self.app.include_router(mgmt_router, tags=[\"Liveliness/Readiness\"])\n\n    def add_route_dependencies(\n        self, scopes: List[Scope], dependencies: List[Depends]\n    ) -&gt; None:\n        \"\"\"Add custom dependencies to routes.\n\n        Args:\n            scopes: list of Scope.\n                Each scope should be a dict with a `path` and `method` property.\n            dependencies: list of fastapi.Depends\n                [FastAPI dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/)\n                to apply to each scope.\n\n        \"\"\"\n        return add_route_dependencies(self.app.router.routes, scopes, dependencies)\n\n    def __attrs_post_init__(self) -&gt; None:\n        \"\"\"Post-init hook.\n\n        Responsible for setting up the application upon instantiation of the class.\n\n        \"\"\"\n        # inject settings\n        self.client.extensions = self.extensions\n        self.client.stac_version = self.stac_version\n        self.client.title = self.title\n        self.client.description = self.description\n\n        Settings.set(self.settings)\n        self.app.state.settings = self.settings\n\n        # Register core STAC endpoints\n        self.register_core()\n        self.app.include_router(self.router)\n\n        # keep link to the router prefix value\n        router_prefix = self.router.prefix\n        self.app.state.router_prefix = router_prefix if router_prefix else \"\"\n\n        # register extensions\n        for ext in self.extensions:\n            ext.register(self.app)\n\n        # add health check\n        self.add_health_check()\n\n        # register exception handlers\n        add_exception_handlers(self.app, status_codes=self.exceptions)\n\n        # add middlewares\n        if self.middlewares and self.app.middleware_stack is not None:\n            raise RuntimeError(\"Cannot add middleware after an application has started\")\n\n        for middleware in self.middlewares:\n            self.app.user_middleware.insert(0, middleware)\n\n        # customize route dependencies\n        for scopes, dependencies in self.route_dependencies:\n            self.add_route_dependencies(scopes=scopes, dependencies=dependencies)\n\n        if self.app.state.settings.enable_direct_response:\n            add_direct_response(self.app)\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__() -&gt; None\n</code></pre> <p>Post-init hook.</p> <p>Responsible for setting up the application upon instantiation of the class.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def __attrs_post_init__(self) -&gt; None:\n    \"\"\"Post-init hook.\n\n    Responsible for setting up the application upon instantiation of the class.\n\n    \"\"\"\n    # inject settings\n    self.client.extensions = self.extensions\n    self.client.stac_version = self.stac_version\n    self.client.title = self.title\n    self.client.description = self.description\n\n    Settings.set(self.settings)\n    self.app.state.settings = self.settings\n\n    # Register core STAC endpoints\n    self.register_core()\n    self.app.include_router(self.router)\n\n    # keep link to the router prefix value\n    router_prefix = self.router.prefix\n    self.app.state.router_prefix = router_prefix if router_prefix else \"\"\n\n    # register extensions\n    for ext in self.extensions:\n        ext.register(self.app)\n\n    # add health check\n    self.add_health_check()\n\n    # register exception handlers\n    add_exception_handlers(self.app, status_codes=self.exceptions)\n\n    # add middlewares\n    if self.middlewares and self.app.middleware_stack is not None:\n        raise RuntimeError(\"Cannot add middleware after an application has started\")\n\n    for middleware in self.middlewares:\n        self.app.user_middleware.insert(0, middleware)\n\n    # customize route dependencies\n    for scopes, dependencies in self.route_dependencies:\n        self.add_route_dependencies(scopes=scopes, dependencies=dependencies)\n\n    if self.app.state.settings.enable_direct_response:\n        add_direct_response(self.app)\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.add_health_check","title":"add_health_check","text":"<pre><code>add_health_check() -&gt; None\n</code></pre> <p>Add a health check.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def add_health_check(self) -&gt; None:\n    \"\"\"Add a health check.\"\"\"\n\n    mgmt_router = APIRouter(prefix=self.app.state.router_prefix)\n\n    async def ping():\n        \"\"\"Liveliness probe.\"\"\"\n        return {\"message\": \"PONG\"}\n\n    mgmt_router.add_api_route(\n        name=\"Ping\",\n        path=\"/_mgmt/ping\",\n        response_model=Dict,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n            },\n        },\n        response_class=self.response_class,\n        methods=[\"GET\"],\n        endpoint=ping,\n    )\n\n    mgmt_router.add_api_route(\n        name=\"Health\",\n        path=\"/_mgmt/health\",\n        response_model=(\n            HealthCheck if self.settings.enable_response_models else None\n        ),\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": HealthCheck,\n            },\n        },\n        response_class=self.response_class,\n        methods=[\"GET\"],\n        endpoint=self.health_check\n        if inspect.iscoroutinefunction(self.health_check)\n        else sync_to_async(self.health_check),\n    )\n    self.app.include_router(mgmt_router, tags=[\"Liveliness/Readiness\"])\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.add_route_dependencies","title":"add_route_dependencies","text":"<pre><code>add_route_dependencies(scopes: List[Scope], dependencies: List[Depends]) -&gt; None\n</code></pre> <p>Add custom dependencies to routes.</p> <p>Parameters:</p> <ul> <li> <code>scopes</code>               (<code>List[Scope]</code>)           \u2013            <p>list of Scope. Each scope should be a dict with a <code>path</code> and <code>method</code> property.</p> </li> <li> <code>dependencies</code>               (<code>List[Depends]</code>)           \u2013            <p>list of fastapi.Depends FastAPI dependencies to apply to each scope.</p> </li> </ul> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def add_route_dependencies(\n    self, scopes: List[Scope], dependencies: List[Depends]\n) -&gt; None:\n    \"\"\"Add custom dependencies to routes.\n\n    Args:\n        scopes: list of Scope.\n            Each scope should be a dict with a `path` and `method` property.\n        dependencies: list of fastapi.Depends\n            [FastAPI dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/)\n            to apply to each scope.\n\n    \"\"\"\n    return add_route_dependencies(self.app.router.routes, scopes, dependencies)\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.get_extension","title":"get_extension","text":"<pre><code>get_extension(extension: Type[ApiExtension]) -&gt; Optional[ApiExtension]\n</code></pre> <p>Get an extension.</p> <p>Parameters:</p> <ul> <li> <code>extension</code>               (<code>Type[ApiExtension]</code>)           \u2013            <p>extension to check for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[ApiExtension]</code>           \u2013            <p>The extension instance, if it exists.</p> </li> </ul> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def get_extension(self, extension: Type[ApiExtension]) -&gt; Optional[ApiExtension]:\n    \"\"\"Get an extension.\n\n    Args:\n        extension: extension to check for.\n\n    Returns:\n        The extension instance, if it exists.\n    \"\"\"\n    for ext in self.extensions:\n        if isinstance(ext, extension):\n            return ext\n    return None\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_conformance_classes","title":"register_conformance_classes","text":"<pre><code>register_conformance_classes() -&gt; None\n</code></pre> <p>Register conformance classes (GET /conformance).</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_conformance_classes(self) -&gt; None:\n    \"\"\"Register conformance classes (GET /conformance).\"\"\"\n    self.router.add_api_route(\n        name=\"Conformance Classes\",\n        path=\"/conformance\",\n        response_model=(\n            api.Conformance if self.settings.enable_response_models else None\n        ),\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": api.Conformance,\n            },\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(self.client.conformance, EmptyRequest),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_core","title":"register_core","text":"<pre><code>register_core() -&gt; None\n</code></pre> <p>Register core STAC endpoints.</p> <pre><code>GET /\nGET /conformance\nGET /collections\nGET /collections/{collection_id}\nGET /collections/{collection_id}/items\nGET /collection/{collection_id}/items/{item_id}\nGET /search\nPOST /search\n</code></pre> <p>Injects application logic (StacApi.client) into the API layer.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_core(self) -&gt; None:\n    \"\"\"Register core STAC endpoints.\n\n        GET /\n        GET /conformance\n        GET /collections\n        GET /collections/{collection_id}\n        GET /collections/{collection_id}/items\n        GET /collection/{collection_id}/items/{item_id}\n        GET /search\n        POST /search\n\n    Injects application logic (StacApi.client) into the API layer.\n\n    \"\"\"\n    self.register_landing_page()\n    self.register_conformance_classes()\n    self.register_get_item()\n    self.register_post_search()\n    self.register_get_search()\n    self.register_get_collections()\n    self.register_get_collection()\n    self.register_get_item_collection()\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_get_collection","title":"register_get_collection","text":"<pre><code>register_get_collection() -&gt; None\n</code></pre> <p>Register get collection endpoint (GET /collection/{collection_id}).</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_get_collection(self) -&gt; None:\n    \"\"\"Register get collection endpoint (GET /collection/{collection_id}).\"\"\"\n    self.router.add_api_route(\n        name=\"Get Collection\",\n        path=\"/collections/{collection_id}\",\n        response_model=api.Collection\n        if self.settings.enable_response_models\n        else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": api.Collection,\n            },\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(\n            self.client.get_collection, self.collection_get_request_model\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_get_collections","title":"register_get_collections","text":"<pre><code>register_get_collections() -&gt; None\n</code></pre> <p>Register get collections endpoint (GET /collections).</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_get_collections(self) -&gt; None:\n    \"\"\"Register get collections endpoint (GET /collections).\"\"\"\n    self.router.add_api_route(\n        name=\"Get Collections\",\n        path=\"/collections\",\n        response_model=(\n            api.Collections if self.settings.enable_response_models else None\n        ),\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": api.Collections,\n            },\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(\n            self.client.all_collections, self.collections_get_request_model\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_get_item","title":"register_get_item","text":"<pre><code>register_get_item() -&gt; None\n</code></pre> <p>Register get item endpoint (GET /collections/{collection_id}/items/{item_id}).</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_get_item(self) -&gt; None:\n    \"\"\"Register get item endpoint (GET /collections/{collection_id}/items/{item_id}).\"\"\"  # noqa: E501\n    self.router.add_api_route(\n        name=\"Get Item\",\n        path=\"/collections/{collection_id}/items/{item_id}\",\n        response_model=api.Item if self.settings.enable_response_models else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": api.Item,\n            },\n        },\n        response_class=GeoJSONResponse,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(\n            self.client.get_item, self.item_get_request_model\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_get_item_collection","title":"register_get_item_collection","text":"<pre><code>register_get_item_collection() -&gt; None\n</code></pre> <p>Register get item collection endpoint (GET /collection/{collection_id}/items).</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_get_item_collection(self) -&gt; None:\n    \"\"\"Register get item collection endpoint (GET /collection/{collection_id}/items).\"\"\"  # noqa: E501\n    self.router.add_api_route(\n        name=\"Get ItemCollection\",\n        path=\"/collections/{collection_id}/items\",\n        response_model=(\n            api.ItemCollection if self.settings.enable_response_models else None\n        ),\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": api.ItemCollection,\n            },\n        },\n        response_class=GeoJSONResponse,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(\n            self.client.item_collection, self.items_get_request_model\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_get_search","title":"register_get_search","text":"<pre><code>register_get_search() -&gt; None\n</code></pre> <p>Register search endpoint (GET /search).</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_get_search(self) -&gt; None:\n    \"\"\"Register search endpoint (GET /search).\"\"\"\n    self.router.add_api_route(\n        name=\"Search\",\n        path=\"/search\",\n        response_model=api.ItemCollection\n        if self.settings.enable_response_models\n        else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": api.ItemCollection,\n            },\n        },\n        response_class=GeoJSONResponse,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(\n            self.client.get_search, self.search_get_request_model\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_landing_page","title":"register_landing_page","text":"<pre><code>register_landing_page() -&gt; None\n</code></pre> <p>Register landing page (GET /).</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_landing_page(self) -&gt; None:\n    \"\"\"Register landing page (GET /).\"\"\"\n    self.router.add_api_route(\n        name=\"Landing Page\",\n        path=\"/\",\n        response_model=(\n            api.LandingPage if self.settings.enable_response_models else None\n        ),\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": api.LandingPage,\n            },\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=False,\n        response_model_exclude_none=True,\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(self.client.landing_page, EmptyRequest),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/app/#stac_fastapi.api.app.StacApi.register_post_search","title":"register_post_search","text":"<pre><code>register_post_search() -&gt; None\n</code></pre> <p>Register search endpoint (POST /search).</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/app.py</code> <pre><code>def register_post_search(self) -&gt; None:\n    \"\"\"Register search endpoint (POST /search).\"\"\"\n    self.router.add_api_route(\n        name=\"Search\",\n        path=\"/search\",\n        response_model=api.ItemCollection\n        if self.settings.enable_response_models\n        else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": api.ItemCollection,\n            },\n        },\n        response_class=GeoJSONResponse,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"POST\"],\n        endpoint=create_async_endpoint(\n            self.client.post_search, self.search_post_request_model\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/config/","title":"config","text":""},{"location":"api/stac_fastapi/api/config/#stac_fastapi.api.config","title":"stac_fastapi.api.config","text":"<p>Application settings.</p>"},{"location":"api/stac_fastapi/api/config/#stac_fastapi.api.config.AddOns","title":"AddOns","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of available third party add ons.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/config.py</code> <pre><code>class AddOns(enum.Enum):\n    \"\"\"Enumeration of available third party add ons.\"\"\"\n\n    bulk_transaction = \"bulk-transaction\"\n</code></pre>"},{"location":"api/stac_fastapi/api/config/#stac_fastapi.api.config.ApiExtensions","title":"ApiExtensions","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of available stac api extensions.</p> <p>Ref: @stac-api-extensions</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/config.py</code> <pre><code>class ApiExtensions(enum.Enum):\n    \"\"\"Enumeration of available stac api extensions.\n\n    Ref: https://github.com/stac-api-extensions\n    \"\"\"\n\n    fields = \"fields\"\n    filter = \"filter\"\n    query = \"query\"\n    sort = \"sort\"\n    transaction = \"transaction\"\n    aggregation = \"aggregation\"\n    collection_search = \"collection-search\"\n    free_text = \"free-text\"\n</code></pre>"},{"location":"api/stac_fastapi/api/errors/","title":"errors","text":""},{"location":"api/stac_fastapi/api/errors/#stac_fastapi.api.errors","title":"stac_fastapi.api.errors","text":"<p>Error handling.</p>"},{"location":"api/stac_fastapi/api/errors/#stac_fastapi.api.errors.ErrorResponse","title":"ErrorResponse","text":"<p>               Bases: <code>TypedDict</code></p> <p>A JSON error response returned by the API.</p> <p>The STAC API spec expects that <code>code</code> and <code>description</code> are both present in the payload.</p> <p>Attributes:</p> <ul> <li> <code>code</code>               (<code>str</code>)           \u2013            <p>A code representing the error, semantics are up to implementor.</p> </li> <li> <code>description</code>               (<code>str</code>)           \u2013            <p>A description of the error.</p> </li> </ul> Source code in <code>stac_fastapi/api/stac_fastapi/api/errors.py</code> <pre><code>class ErrorResponse(TypedDict):\n    \"\"\"A JSON error response returned by the API.\n\n    The STAC API spec expects that `code` and `description` are both present in\n    the payload.\n\n    Attributes:\n        code: A code representing the error, semantics are up to implementor.\n        description: A description of the error.\n    \"\"\"\n\n    code: str\n    description: str\n</code></pre>"},{"location":"api/stac_fastapi/api/errors/#stac_fastapi.api.errors.add_exception_handlers","title":"add_exception_handlers","text":"<pre><code>add_exception_handlers(app: FastAPI, status_codes: Dict[Type[Exception], int]) -&gt; None\n</code></pre> <p>Add exception handlers to the FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>the FastAPI application.</p> </li> <li> <code>status_codes</code>               (<code>Dict[Type[Exception], int]</code>)           \u2013            <p>mapping between exceptions and status codes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/api/stac_fastapi/api/errors.py</code> <pre><code>def add_exception_handlers(\n    app: FastAPI, status_codes: Dict[Type[Exception], int]\n) -&gt; None:\n    \"\"\"Add exception handlers to the FastAPI application.\n\n    Args:\n        app: the FastAPI application.\n        status_codes: mapping between exceptions and status codes.\n\n    Returns:\n        None\n    \"\"\"\n    for exc, code in status_codes.items():\n        app.add_exception_handler(exc, exception_handler_factory(code))\n\n    # By default FastAPI will return 422 status codes for invalid requests\n    # But the STAC api spec suggests returning a 400 in this case\n    def request_validation_exception_handler(\n        request: Request, exc: RequestValidationError\n    ) -&gt; JSONResponse:\n        return JSONResponse(\n            content=jsonable_encoder({\"detail\": exc.errors(), \"body\": exc.body}),\n            status_code=status.HTTP_400_BAD_REQUEST,\n        )\n\n    # TODO: Argument 2 to \"add_exception_handler\" of \"Starlette\" has incompatible type\n    app.add_exception_handler(\n        RequestValidationError,\n        request_validation_exception_handler,  # type: ignore [arg-type]\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/errors/#stac_fastapi.api.errors.exception_handler_factory","title":"exception_handler_factory","text":"<pre><code>exception_handler_factory(status_code: int) -&gt; Callable\n</code></pre> <p>Create a FastAPI exception handler for a particular status code.</p> <p>Parameters:</p> <ul> <li> <code>status_code</code>               (<code>int</code>)           \u2013            <p>HTTP status code.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code> (              <code>Callable</code> )          \u2013            <p>an exception handler.</p> </li> </ul> Source code in <code>stac_fastapi/api/stac_fastapi/api/errors.py</code> <pre><code>def exception_handler_factory(status_code: int) -&gt; Callable:\n    \"\"\"Create a FastAPI exception handler for a particular status code.\n\n    Args:\n        status_code: HTTP status code.\n\n    Returns:\n        callable: an exception handler.\n    \"\"\"\n\n    def handler(request: Request, exc: Exception):\n        \"\"\"I handle exceptions!!.\"\"\"\n        logger.error(exc, exc_info=True)\n        return JSONResponse(\n            content=ErrorResponse(code=exc.__class__.__name__, description=str(exc)),\n            status_code=status_code,\n        )\n\n    return handler\n</code></pre>"},{"location":"api/stac_fastapi/api/middleware/","title":"middleware","text":""},{"location":"api/stac_fastapi/api/middleware/#stac_fastapi.api.middleware","title":"stac_fastapi.api.middleware","text":"<p>Api middleware.</p>"},{"location":"api/stac_fastapi/api/middleware/#stac_fastapi.api.middleware.CORSMiddleware","title":"CORSMiddleware","text":"<p>               Bases: <code>CORSMiddleware</code></p> <p>Subclass of Starlette's standard CORS middleware with default values set to those recommended by the STAC API spec.</p> <p>github.com/radiantearth/stac-api-spec/blob/914cf8108302e2ec734340080a45aaae4859bb63/implementation.md#cors</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/middleware.py</code> <pre><code>class CORSMiddleware(_CORSMiddleware):\n    \"\"\"Subclass of Starlette's standard CORS middleware with default values set to those\n    recommended by the STAC API spec.\n\n    https://github.com/radiantearth/stac-api-spec/blob/914cf8108302e2ec734340080a45aaae4859bb63/implementation.md#cors\n    \"\"\"\n\n    def __init__(\n        self,\n        app: ASGIApp,\n        allow_origins: typing.Sequence[str] = (\"*\",),\n        allow_methods: typing.Sequence[str] = (\n            \"OPTIONS\",\n            \"POST\",\n            \"GET\",\n        ),\n        allow_headers: typing.Sequence[str] = (\"Content-Type\",),\n        allow_credentials: bool = False,\n        allow_origin_regex: typing.Optional[str] = None,\n        expose_headers: typing.Sequence[str] = (),\n        max_age: int = 600,\n        **kwargs: typing.Any,\n    ) -&gt; None:\n        \"\"\"Create CORS middleware.\"\"\"\n        warnings.warn(\n            \"\"\"stac_fastapi.api.middleware.CORSMiddleware is deprecated and\n            will be removed in a future release.\n            Please use starlette.middleware.cors.CORSMiddleware instead.\"\"\",\n            DeprecationWarning,\n        )\n        super().__init__(\n            app,\n            allow_origins=allow_origins,\n            allow_methods=allow_methods,\n            allow_headers=allow_headers,\n            allow_credentials=allow_credentials,\n            allow_origin_regex=allow_origin_regex,\n            expose_headers=expose_headers,\n            max_age=max_age,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/stac_fastapi/api/middleware/#stac_fastapi.api.middleware.CORSMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(\n    app: ASGIApp,\n    allow_origins: Sequence[str] = (\"*\",),\n    allow_methods: Sequence[str] = (\"OPTIONS\", \"POST\", \"GET\"),\n    allow_headers: Sequence[str] = (\"Content-Type\",),\n    allow_credentials: bool = False,\n    allow_origin_regex: Optional[str] = None,\n    expose_headers: Sequence[str] = (),\n    max_age: int = 600,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Create CORS middleware.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/middleware.py</code> <pre><code>def __init__(\n    self,\n    app: ASGIApp,\n    allow_origins: typing.Sequence[str] = (\"*\",),\n    allow_methods: typing.Sequence[str] = (\n        \"OPTIONS\",\n        \"POST\",\n        \"GET\",\n    ),\n    allow_headers: typing.Sequence[str] = (\"Content-Type\",),\n    allow_credentials: bool = False,\n    allow_origin_regex: typing.Optional[str] = None,\n    expose_headers: typing.Sequence[str] = (),\n    max_age: int = 600,\n    **kwargs: typing.Any,\n) -&gt; None:\n    \"\"\"Create CORS middleware.\"\"\"\n    warnings.warn(\n        \"\"\"stac_fastapi.api.middleware.CORSMiddleware is deprecated and\n        will be removed in a future release.\n        Please use starlette.middleware.cors.CORSMiddleware instead.\"\"\",\n        DeprecationWarning,\n    )\n    super().__init__(\n        app,\n        allow_origins=allow_origins,\n        allow_methods=allow_methods,\n        allow_headers=allow_headers,\n        allow_credentials=allow_credentials,\n        allow_origin_regex=allow_origin_regex,\n        expose_headers=expose_headers,\n        max_age=max_age,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/stac_fastapi/api/middleware/#stac_fastapi.api.middleware.ProxyHeaderMiddleware","title":"ProxyHeaderMiddleware","text":"<p>Account for forwarding headers when deriving base URL.</p> <p>Prioritise standard Forwarded header, look for non-standard X-Forwarded-* if missing. Default to what can be derived from the URL if no headers provided. Middleware updates the host header that is interpreted by starlette when deriving Request.base_url.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/middleware.py</code> <pre><code>class ProxyHeaderMiddleware:\n    \"\"\"Account for forwarding headers when deriving base URL.\n\n    Prioritise standard Forwarded header, look for non-standard X-Forwarded-* if missing.\n    Default to what can be derived from the URL if no headers provided. Middleware updates\n    the host header that is interpreted by starlette when deriving Request.base_url.\n    \"\"\"\n\n    def __init__(self, app: ASGIApp):\n        \"\"\"Create proxy header middleware.\"\"\"\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Call from stac-fastapi framework.\"\"\"\n        if scope[\"type\"] == \"http\":\n            proto, domain, port = self._get_forwarded_url_parts(scope)\n            scope[\"scheme\"] = proto\n            if domain is not None:\n                port_suffix = \"\"\n                if port is not None:\n                    if (proto == \"http\" and port != HTTP_PORT) or (\n                        proto == \"https\" and port != HTTPS_PORT\n                    ):\n                        port_suffix = f\":{port}\"\n\n                scope[\"headers\"] = self._replace_header_value_by_name(\n                    scope,\n                    \"host\",\n                    f\"{domain}{port_suffix}\",\n                )\n\n        await self.app(scope, receive, send)\n\n    def _get_forwarded_url_parts(self, scope: Scope) -&gt; Tuple[str, str, int]:\n        proto = scope.get(\"scheme\", \"http\")\n        # Assume default port based on protocol, can be overridden later\n        port = 443 if proto == \"https\" else 80\n\n        if header_host := self._get_header_value_by_name(scope, \"host\"):\n            header_host_parts = header_host.split(\":\")\n            domain = header_host_parts[0]\n            if len(header_host_parts) == 2:\n                with contextlib.suppress(ValueError):\n                    port = int(header_host_parts[1])\n        else:\n            # Not sure when we would not have a host header, but fallback to server info\n            domain, port = scope[\"server\"]\n            port = int(port)\n\n        forwarded_port: Optional[str] = None\n        forwarding_occurred = any(\n            key\n            in [\n                b\"forwarded\",\n                b\"x-forwarded-proto\",\n                b\"x-forwarded-host\",\n                b\"x-forwarded-port\",\n            ]\n            for key, _ in scope[\"headers\"]\n        )\n\n        if forwarded := self._get_header_value_by_name(scope, \"forwarded\"):\n            for proxy in forwarded.split(\",\"):\n                if proto_expr := _PROTO_HEADER_REGEX.search(proxy):\n                    proto = proto_expr.group(\"proto\")\n                if host_expr := _HOST_HEADER_REGEX.search(proxy):\n                    domain = host_expr.group(\"host\")\n                    forwarded_port = host_expr.group(\"port\")  # None if not present\n\n        else:\n            domain = self._get_header_value_by_name(scope, \"x-forwarded-host\") or domain\n            proto = self._get_header_value_by_name(scope, \"x-forwarded-proto\") or proto\n            forwarded_port = self._get_header_value_by_name(scope, \"x-forwarded-port\")\n\n        if forwarding_occurred and not forwarded_port:\n            # If forwarding occurred but no port was specified, use protocol default\n            forwarded_port = \"443\" if proto == \"https\" else \"80\"\n\n        if forwarded_port:\n            # ignore ports that are not valid integers\n            with contextlib.suppress(ValueError):\n                port = int(forwarded_port)\n\n        return (proto, domain, port)\n\n    def _get_header_value_by_name(\n        self, scope: Scope, header_name: str, default_value: Optional[str] = None\n    ) -&gt; Optional[str]:\n        headers = scope[\"headers\"]\n        candidates = [\n            value.decode() for key, value in headers if key.decode() == header_name\n        ]\n        return candidates[0] if len(candidates) == 1 else default_value\n\n    @staticmethod\n    def _replace_header_value_by_name(\n        scope: Scope, header_name: str, new_value: str\n    ) -&gt; List[Tuple[str, str]]:\n        return [\n            (name, value)\n            for name, value in scope[\"headers\"]\n            if name.decode() != header_name\n        ] + [(str.encode(header_name), str.encode(new_value))]\n</code></pre>"},{"location":"api/stac_fastapi/api/middleware/#stac_fastapi.api.middleware.ProxyHeaderMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None\n</code></pre> <p>Call from stac-fastapi framework.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/middleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Call from stac-fastapi framework.\"\"\"\n    if scope[\"type\"] == \"http\":\n        proto, domain, port = self._get_forwarded_url_parts(scope)\n        scope[\"scheme\"] = proto\n        if domain is not None:\n            port_suffix = \"\"\n            if port is not None:\n                if (proto == \"http\" and port != HTTP_PORT) or (\n                    proto == \"https\" and port != HTTPS_PORT\n                ):\n                    port_suffix = f\":{port}\"\n\n            scope[\"headers\"] = self._replace_header_value_by_name(\n                scope,\n                \"host\",\n                f\"{domain}{port_suffix}\",\n            )\n\n    await self.app(scope, receive, send)\n</code></pre>"},{"location":"api/stac_fastapi/api/middleware/#stac_fastapi.api.middleware.ProxyHeaderMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app: ASGIApp)\n</code></pre> <p>Create proxy header middleware.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/middleware.py</code> <pre><code>def __init__(self, app: ASGIApp):\n    \"\"\"Create proxy header middleware.\"\"\"\n    self.app = app\n</code></pre>"},{"location":"api/stac_fastapi/api/models/","title":"models","text":""},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models","title":"stac_fastapi.api.models","text":"<p>Api request/response models.</p>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.CollectionUri","title":"CollectionUri","text":"<p>               Bases: <code>APIRequest</code></p> <p>Get or delete collection.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>@attr.s\nclass CollectionUri(APIRequest):\n    \"\"\"Get or delete collection.\"\"\"\n\n    collection_id: Annotated[str, Path(description=\"Collection ID\")] = attr.ib()\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.EmptyRequest","title":"EmptyRequest","text":"<p>               Bases: <code>APIRequest</code></p> <p>Empty request.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>@attr.s\nclass EmptyRequest(APIRequest):\n    \"\"\"Empty request.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.GeoJSONResponse","title":"GeoJSONResponse","text":"<p>               Bases: <code>JSONResponse</code></p> <p>JSON with custom, vendor content-type.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>class GeoJSONResponse(JSONResponse):\n    \"\"\"JSON with custom, vendor content-type.\"\"\"\n\n    media_type = \"application/geo+json\"\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.HealthCheck","title":"HealthCheck","text":"<p>               Bases: <code>BaseModel</code></p> <p>health check response model.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>class HealthCheck(BaseModel, extra=\"allow\"):\n    \"\"\"health check response model.\"\"\"\n\n    status: Literal[\"UP\", \"DOWN\"]\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.ItemCollectionUri","title":"ItemCollectionUri","text":"<p>               Bases: <code>APIRequest</code>, <code>DatetimeMixin</code></p> <p>Get item collection.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>@attr.s\nclass ItemCollectionUri(APIRequest, DatetimeMixin):\n    \"\"\"Get item collection.\"\"\"\n\n    collection_id: Annotated[str, Path(description=\"Collection ID\")] = attr.ib()\n    limit: Annotated[\n        Optional[Limit],\n        Query(\n            description=\"Limits the number of results that are included in each page of the response (capped to 10_000).\"  # noqa: E501\n        ),\n    ] = attr.ib(default=10)\n    bbox: Optional[BBox] = attr.ib(default=None, converter=_bbox_converter)  # type: ignore [misc]\n    datetime: DateTimeQueryType = attr.ib(default=None, validator=_validate_datetime)\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.ItemUri","title":"ItemUri","text":"<p>               Bases: <code>APIRequest</code></p> <p>Get or delete item.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>@attr.s\nclass ItemUri(APIRequest):\n    \"\"\"Get or delete item.\"\"\"\n\n    collection_id: Annotated[str, Path(description=\"Collection ID\")] = attr.ib()\n    item_id: Annotated[str, Path(description=\"Item ID\")] = attr.ib()\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.JSONSchemaResponse","title":"JSONSchemaResponse","text":"<p>               Bases: <code>JSONResponse</code></p> <p>JSON with custom, vendor content-type.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>class JSONSchemaResponse(JSONResponse):\n    \"\"\"JSON with custom, vendor content-type.\"\"\"\n\n    media_type = \"application/schema+json\"\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.create_get_request_model","title":"create_get_request_model","text":"<pre><code>create_get_request_model(\n    extensions: Optional[List[ApiExtension]], base_model: Type[APIRequest] = BaseSearchGetRequest\n) -&gt; Type[APIRequest]\n</code></pre> <p>Wrap create_request_model to create the GET request model.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>def create_get_request_model(\n    extensions: Optional[List[ApiExtension]],\n    base_model: Type[APIRequest] = BaseSearchGetRequest,\n) -&gt; Type[APIRequest]:\n    \"\"\"Wrap create_request_model to create the GET request model.\"\"\"\n    model = create_request_model(\n        \"SearchGetRequest\",\n        base_model=base_model,\n        extensions=extensions,\n        request_type=\"GET\",\n    )\n    return cast(Type[APIRequest], model)\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.create_post_request_model","title":"create_post_request_model","text":"<pre><code>create_post_request_model(\n    extensions: Optional[List[ApiExtension]], base_model: Type[BaseModel] = BaseSearchPostRequest\n) -&gt; Type[BaseModel]\n</code></pre> <p>Wrap create_request_model to create the POST request model.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>def create_post_request_model(\n    extensions: Optional[List[ApiExtension]],\n    base_model: Type[BaseModel] = BaseSearchPostRequest,\n) -&gt; Type[BaseModel]:\n    \"\"\"Wrap create_request_model to create the POST request model.\"\"\"\n    model = create_request_model(\n        \"SearchPostRequest\",\n        base_model=base_model,\n        extensions=extensions,\n        request_type=\"POST\",\n    )\n    return cast(Type[BaseModel], model)\n</code></pre>"},{"location":"api/stac_fastapi/api/models/#stac_fastapi.api.models.create_request_model","title":"create_request_model","text":"<pre><code>create_request_model(\n    model_name=\"SearchGetRequest\",\n    base_model: Union[Type[BaseModel], Type[APIRequest]] = BaseSearchGetRequest,\n    extensions: Optional[List[ApiExtension]] = None,\n    mixins: Optional[Union[List[Type[BaseModel]], List[Type[APIRequest]]]] = None,\n    request_type: str = \"GET\",\n) -&gt; Union[Type[BaseModel], Type[APIRequest]]\n</code></pre> <p>Create a pydantic model for validating request bodies.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/models.py</code> <pre><code>def create_request_model(\n    model_name=\"SearchGetRequest\",\n    base_model: Union[Type[BaseModel], Type[APIRequest]] = BaseSearchGetRequest,\n    extensions: Optional[List[ApiExtension]] = None,\n    mixins: Optional[Union[List[Type[BaseModel]], List[Type[APIRequest]]]] = None,\n    request_type: str = \"GET\",\n) -&gt; Union[Type[BaseModel], Type[APIRequest]]:\n    \"\"\"Create a pydantic model for validating request bodies.\"\"\"\n    fields = {}\n    extension_models: List[Union[Type[BaseModel], Type[APIRequest]]] = []\n\n    # Check extensions for additional parameters to search\n    for extension in extensions or []:\n        if extension_model := extension.get_request_model(request_type):\n            extension_models.append(extension_model)\n\n    mixins = mixins or []\n\n    models = [base_model] + extension_models + mixins\n\n    # Handle GET requests\n    if all([issubclass(m, APIRequest) for m in models]):\n        get_model = attr.make_class(model_name, attrs={}, bases=tuple(models))\n        return cast(Type[APIRequest], get_model)\n\n    # Handle POST requests\n    elif all([issubclass(m, BaseModel) for m in models]):\n        for model in models:\n            for k, field_info in model.model_fields.items():  # type: ignore\n                fields[k] = (field_info.annotation, field_info)\n\n        post_model = create_model(model_name, **fields, __base__=base_model)  # type: ignore\n        return cast(Type[BaseModel], post_model)\n\n    raise TypeError(\"Mixed Request Model types. Check extension request types.\")\n</code></pre>"},{"location":"api/stac_fastapi/api/openapi/","title":"openapi","text":""},{"location":"api/stac_fastapi/api/openapi/#stac_fastapi.api.openapi","title":"stac_fastapi.api.openapi","text":"<p>openapi.</p>"},{"location":"api/stac_fastapi/api/openapi/#stac_fastapi.api.openapi.update_openapi","title":"update_openapi","text":"<pre><code>update_openapi(app: FastAPI) -&gt; FastAPI\n</code></pre> <p>Update OpenAPI response content-type.</p> <p>This function modifies the openapi route to comply with the STAC API spec's required content-type response header.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/openapi.py</code> <pre><code>def update_openapi(app: FastAPI) -&gt; FastAPI:\n    \"\"\"Update OpenAPI response content-type.\n\n    This function modifies the openapi route to comply with the STAC API spec's required\n    content-type response header.\n    \"\"\"\n    # Find the route for the openapi_url in the app\n    # TODO: Type info is Route, while it shoukd maybe be APIRoute? Check FastAPI source.\n    openapi_route: Route = next(\n        route\n        for route in app.router.routes\n        if route.path == app.openapi_url  # type: ignore\n    )\n    # Store the old endpoint function so we can call it from the patched function\n    old_endpoint = openapi_route.endpoint\n\n    # Create a patched endpoint function that modifies the content type of the response\n    async def patched_openapi_endpoint(req: Request) -&gt; Response:\n        # Get the response from the old endpoint function\n        response = await old_endpoint(req)\n        # Update the content type header in place\n        response.headers[\"content-type\"] = \"application/vnd.oai.openapi+json;version=3.0\"\n        # Return the updated response\n        return response\n\n    # When a Route is accessed the `handle` function calls `self.app`. Which is\n    # the endpoint function wrapped with `request_response`. So we need to wrap\n    # our patched function and replace the existing app with it.\n    openapi_route.app = request_response(patched_openapi_endpoint)\n\n    # return the patched app\n    return app\n</code></pre>"},{"location":"api/stac_fastapi/api/routes/","title":"routes","text":""},{"location":"api/stac_fastapi/api/routes/#stac_fastapi.api.routes","title":"stac_fastapi.api.routes","text":"<p>Route factories.</p>"},{"location":"api/stac_fastapi/api/routes/#stac_fastapi.api.routes.Scope","title":"Scope","text":"<p>               Bases: <code>TypedDict</code></p> <p>More strict version of Starlette's Scope.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/routes.py</code> <pre><code>class Scope(TypedDict, total=False):\n    \"\"\"More strict version of Starlette's Scope.\"\"\"\n\n    # https://github.com/encode/starlette/blob/6af5c515e0a896cbf3f86ee043b88f6c24200bcf/starlette/types.py#L3\n    path: str\n    method: str\n    type: Optional[str]\n</code></pre>"},{"location":"api/stac_fastapi/api/routes/#stac_fastapi.api.routes.add_direct_response","title":"add_direct_response","text":"<pre><code>add_direct_response(app: FastAPI) -&gt; None\n</code></pre> <p>Setup FastAPI application's endpoints to return Response Object directly, avoiding Pydantic validation and FastAPI (slow) serialization.</p> <p>ref: gist.github.com/Zaczero/00f3a2679ebc0a25eb938ed82bc63553</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/routes.py</code> <pre><code>def add_direct_response(app: FastAPI) -&gt; None:\n    \"\"\"\n    Setup FastAPI application's endpoints to return Response Object directly, avoiding\n    Pydantic validation and FastAPI (slow) serialization.\n\n    ref: https://gist.github.com/Zaczero/00f3a2679ebc0a25eb938ed82bc63553\n    \"\"\"\n\n    def wrap_endpoint(endpoint: Callable, cls: Type[Response]):\n        @functools.wraps(endpoint)\n        async def wrapper(*args, **kwargs):\n            content = await endpoint(*args, **kwargs)\n            return content if isinstance(content, Response) else cls(content)\n\n        return wrapper\n\n    for route in app.routes:\n        if not isinstance(route, APIRoute):\n            continue\n\n        response_class = route.response_class\n        if isinstance(response_class, DefaultPlaceholder):\n            response_class = response_class.value\n\n        if issubclass(response_class, Response):\n            route.endpoint = wrap_endpoint(route.endpoint, response_class)\n            route.dependant = get_dependant(path=route.path_format, call=route.endpoint)\n            route.app = request_response(route.get_route_handler())\n</code></pre>"},{"location":"api/stac_fastapi/api/routes/#stac_fastapi.api.routes.add_route_dependencies","title":"add_route_dependencies","text":"<pre><code>add_route_dependencies(\n    routes: List[BaseRoute], scopes: List[Scope], dependencies: List[Depends]\n) -&gt; None\n</code></pre> <p>Add dependencies to routes.</p> <p>Allows a developer to add dependencies to a route after the route has been defined.</p> <p>\"*\" can be used for path or method to match all allowed routes.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/api/stac_fastapi/api/routes.py</code> <pre><code>def add_route_dependencies(\n    routes: List[BaseRoute], scopes: List[Scope], dependencies: List[params.Depends]\n) -&gt; None:\n    \"\"\"Add dependencies to routes.\n\n    Allows a developer to add dependencies to a route after the route has been\n    defined.\n\n    \"*\" can be used for path or method to match all allowed routes.\n\n    Returns:\n        None\n    \"\"\"\n    for scope in scopes:\n        _scope = copy.deepcopy(scope)\n        for route in routes:\n            if scope[\"path\"] == \"*\":\n                # NOTE: ignore type, because BaseRoute has no \"path\" attribute\n                # but APIRoute does.\n                _scope[\"path\"] = route.path  # type: ignore\n\n            # NOTE: ignore type, because BaseRoute has no \"method\" attribute\n            # but APIRoute does.\n            if scope[\"method\"] == \"*\":\n                _scope[\"method\"] = list(route.methods)[0]  # type: ignore\n\n            match, _ = route.matches({\"type\": \"http\", **_scope})\n            if match != Match.FULL:\n                continue\n\n            # Ignore paths without dependants, e.g. /api, /api.html, /docs/oauth2-redirect\n            if not hasattr(route, \"dependant\"):\n                continue\n\n            # Mimicking how APIRoute handles dependencies:\n            # https://github.com/tiangolo/fastapi/blob/1760da0efa55585c19835d81afa8ca386036c325/fastapi/routing.py#L408-L412\n            for depends in dependencies[::-1]:\n                route.dependant.dependencies.insert(\n                    0,\n                    get_parameterless_sub_dependant(\n                        # NOTE: ignore type, because BaseRoute has no \"path_format\"\n                        # attribute but APIRoute does.\n                        depends=depends,\n                        path=route.path_format,  # type: ignore\n                    ),\n                )\n\n            # Register dependencies directly on route so that they aren't ignored if\n            # the routes are later associated with an app (e.g.\n            # app.include_router(router))\n            # https://github.com/tiangolo/fastapi/blob/58ab733f19846b4875c5b79bfb1f4d1cb7f4823f/fastapi/applications.py#L337-L360\n            # https://github.com/tiangolo/fastapi/blob/58ab733f19846b4875c5b79bfb1f4d1cb7f4823f/fastapi/routing.py#L677-L678\n            # NOTE: ignore type, because BaseRoute has no \"dependencies\" attribute\n            # but APIRoute does.\n            route.dependencies.extend(dependencies)  # type: ignore\n</code></pre>"},{"location":"api/stac_fastapi/api/routes/#stac_fastapi.api.routes.create_async_endpoint","title":"create_async_endpoint","text":"<pre><code>create_async_endpoint(\n    func: Callable, request_model: Union[Type[APIRequest], Type[BaseModel], Dict]\n) -&gt; Callable[[Any, Any], Awaitable[Any]]\n</code></pre> <p>Wrap a function in a coroutine which may be used to create a FastAPI endpoint.</p> <p>Synchronous functions are executed asynchronously using a background thread.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/routes.py</code> <pre><code>def create_async_endpoint(\n    func: Callable,\n    request_model: Union[Type[APIRequest], Type[BaseModel], Dict],\n) -&gt; Callable[[Any, Any], Awaitable[Any]]:\n    \"\"\"Wrap a function in a coroutine which may be used to create a FastAPI endpoint.\n\n    Synchronous functions are executed asynchronously using a background thread.\n    \"\"\"\n\n    if not inspect.iscoroutinefunction(func):\n        func = sync_to_async(func)\n\n    _endpoint: Callable[[Any, Any], Awaitable[Any]]\n\n    if isinstance(request_model, dict):\n\n        async def _endpoint(request: Request, request_data: Dict[str, Any]):\n            \"\"\"Endpoint.\"\"\"\n            return _wrap_response(await func(request_data, request=request))\n\n    elif issubclass(request_model, APIRequest):\n\n        async def _endpoint(request: Request, request_data=Depends(request_model)):  # type: ignore\n            \"\"\"Endpoint.\"\"\"\n            return _wrap_response(await func(request=request, **request_data.kwargs()))\n\n    elif issubclass(request_model, BaseModel):\n\n        async def _endpoint(request: Request, request_data: request_model):  # type: ignore\n            \"\"\"Endpoint.\"\"\"\n            return _wrap_response(await func(request_data, request=request))\n\n    else:\n        raise ValueError(f\"Unsupported type for request model {type(request_model)}\")\n\n    return _endpoint\n</code></pre>"},{"location":"api/stac_fastapi/api/routes/#stac_fastapi.api.routes.sync_to_async","title":"sync_to_async","text":"<pre><code>sync_to_async(func)\n</code></pre> <p>Run synchronous function asynchronously in a background thread.</p> Source code in <code>stac_fastapi/api/stac_fastapi/api/routes.py</code> <pre><code>def sync_to_async(func):\n    \"\"\"Run synchronous function asynchronously in a background thread.\"\"\"\n\n    @functools.wraps(func)\n    async def run(*args, **kwargs):\n        return await run_in_threadpool(func, *args, **kwargs)\n\n    return run\n</code></pre>"},{"location":"api/stac_fastapi/extensions/","title":"Module stac_fastapi.extensions","text":"<p>Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core</li> <li>stac_fastapi.extensions.third_party</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/","title":"Module stac_fastapi.extensions","text":"<p>Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.fields</li> <li>stac_fastapi.extensions.core.filter</li> <li>stac_fastapi.extensions.core.free_text</li> <li>stac_fastapi.extensions.core.pagination</li> <li>stac_fastapi.extensions.core.query</li> <li>stac_fastapi.extensions.core.sort</li> <li>stac_fastapi.extensions.core.transaction</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/transaction/","title":"transaction","text":""},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction","title":"stac_fastapi.extensions.core.transaction","text":"<p>transaction extension module.</p>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient","title":"AsyncBaseTransactionsClient","text":"<p>               Bases: <code>ABC</code></p> <p>Defines a pattern for implementing the STAC transaction extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@attr.s  # type:ignore\nclass AsyncBaseTransactionsClient(abc.ABC):\n    \"\"\"Defines a pattern for implementing the STAC transaction extension.\"\"\"\n\n    @abc.abstractmethod\n    async def create_item(\n        self,\n        collection_id: str,\n        item: Union[Item, ItemCollection],\n        **kwargs,\n    ) -&gt; Optional[Union[stac.Item, Response, None]]:\n        \"\"\"Create a new item.\n\n        Called with `POST /collections/{collection_id}/items`.\n\n        Args:\n            item: the item or item collection\n            collection_id: the id of the collection from the resource path\n\n        Returns:\n            The item that was created or None if item collection.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def update_item(\n        self, collection_id: str, item_id: str, item: Item, **kwargs\n    ) -&gt; Optional[Union[stac.Item, Response]]:\n        \"\"\"Perform a complete update on an existing item.\n\n        Called with `PUT /collections/{collection_id}/items`. It is expected\n        that this item already exists.  The update should do a diff against the\n        saved item and perform any necessary updates.  Partial updates are not\n        supported by the transactions extension.\n\n        Args:\n            item: the item (must be complete)\n\n        Returns:\n            The updated item.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def patch_item(\n        self,\n        collection_id: str,\n        item_id: str,\n        patch: Union[PartialItem, List[PatchOperation]],\n        **kwargs,\n    ) -&gt; Optional[Union[stac.Item, Response]]:\n        \"\"\"Update an item from a collection.\n\n        Called with `PATCH /collections/{collection_id}/items/{item_id}`\n\n        example:\n            # convert merge patch item to list of operations\n            if isinstance(patch, PartialItem):\n                patch = patch.operations()\n\n            item = backend.patch_item(collection_id, item_id, patch)\n\n            return item\n\n        Args:\n            item_id: id of the item.\n            collection_id: id of the collection.\n            patch: either the partial item or list of patch operations.\n\n        Returns:\n            The patched item.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def delete_item(\n        self, item_id: str, collection_id: str, **kwargs\n    ) -&gt; Optional[Union[stac.Item, Response]]:\n        \"\"\"Delete an item from a collection.\n\n        Called with `DELETE /collections/{collection_id}/items/{item_id}`\n\n        Args:\n            item_id: id of the item.\n            collection_id: id of the collection.\n\n        Returns:\n            The deleted item.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def create_collection(\n        self, collection: Collection, **kwargs\n    ) -&gt; Optional[Union[stac.Collection, Response]]:\n        \"\"\"Create a new collection.\n\n        Called with `POST /collections`.\n\n        Args:\n            collection: the collection\n\n        Returns:\n            The collection that was created.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def update_collection(\n        self, collection_id: str, collection: Collection, **kwargs\n    ) -&gt; Optional[Union[stac.Collection, Response]]:\n        \"\"\"Perform a complete update on an existing collection.\n\n        Called with `PUT /collections/{collection_id}`. It is expected that this item\n        already exists.  The update should do a diff against the saved collection and\n        perform any necessary updates.  Partial updates are not supported by the\n        transactions extension.\n\n        Args:\n            collection_id: id of the existing collection to be updated\n            collection: the updated collection (must be complete)\n\n        Returns:\n            The updated collection.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def patch_collection(\n        self,\n        collection_id: str,\n        patch: Union[PartialCollection, List[PatchOperation]],\n        **kwargs,\n    ) -&gt; Optional[Union[stac.Collection, Response]]:\n        \"\"\"Update a collection.\n\n        Called with `PATCH /collections/{collection_id}`\n\n        example:\n            # convert merge patch item to list of operations\n            if isinstance(patch, PartialCollection):\n                patch = patch.operations()\n\n            collection = backend.patch_collection(collection_id, patch)\n\n            return collection\n\n        Args:\n            collection_id: id of the collection.\n            patch: either the partial collection or list of patch operations.\n\n        Returns:\n            The patched collection.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def delete_collection(\n        self, collection_id: str, **kwargs\n    ) -&gt; Optional[Union[stac.Collection, Response]]:\n        \"\"\"Delete a collection.\n\n        Called with `DELETE /collections/{collection_id}`\n\n        Args:\n            collection_id: id of the collection.\n\n        Returns:\n            The deleted collection.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.create_collection","title":"create_collection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_collection(collection: Collection, **kwargs) -&gt; Optional[Union[Collection, Response]]\n</code></pre> <p>Create a new collection.</p> <p>Called with <code>POST /collections</code>.</p> <p>Parameters:</p> <ul> <li> <code>collection</code>               (<code>Collection</code>)           \u2013            <p>the collection</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Collection, Response]]</code>           \u2013            <p>The collection that was created.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\nasync def create_collection(\n    self, collection: Collection, **kwargs\n) -&gt; Optional[Union[stac.Collection, Response]]:\n    \"\"\"Create a new collection.\n\n    Called with `POST /collections`.\n\n    Args:\n        collection: the collection\n\n    Returns:\n        The collection that was created.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.create_item","title":"create_item  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_item(\n    collection_id: str, item: Union[Item, ItemCollection], **kwargs\n) -&gt; Optional[Union[Item, Response, None]]\n</code></pre> <p>Create a new item.</p> <p>Called with <code>POST /collections/{collection_id}/items</code>.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Union[Item, ItemCollection]</code>)           \u2013            <p>the item or item collection</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>the id of the collection from the resource path</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Item, Response, None]]</code>           \u2013            <p>The item that was created or None if item collection.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\nasync def create_item(\n    self,\n    collection_id: str,\n    item: Union[Item, ItemCollection],\n    **kwargs,\n) -&gt; Optional[Union[stac.Item, Response, None]]:\n    \"\"\"Create a new item.\n\n    Called with `POST /collections/{collection_id}/items`.\n\n    Args:\n        item: the item or item collection\n        collection_id: the id of the collection from the resource path\n\n    Returns:\n        The item that was created or None if item collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.delete_collection","title":"delete_collection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_collection(collection_id: str, **kwargs) -&gt; Optional[Union[Collection, Response]]\n</code></pre> <p>Delete a collection.</p> <p>Called with <code>DELETE /collections/{collection_id}</code></p> <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Collection, Response]]</code>           \u2013            <p>The deleted collection.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\nasync def delete_collection(\n    self, collection_id: str, **kwargs\n) -&gt; Optional[Union[stac.Collection, Response]]:\n    \"\"\"Delete a collection.\n\n    Called with `DELETE /collections/{collection_id}`\n\n    Args:\n        collection_id: id of the collection.\n\n    Returns:\n        The deleted collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.delete_item","title":"delete_item  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_item(item_id: str, collection_id: str, **kwargs) -&gt; Optional[Union[Item, Response]]\n</code></pre> <p>Delete an item from a collection.</p> <p>Called with <code>DELETE /collections/{collection_id}/items/{item_id}</code></p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>str</code>)           \u2013            <p>id of the item.</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Item, Response]]</code>           \u2013            <p>The deleted item.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\nasync def delete_item(\n    self, item_id: str, collection_id: str, **kwargs\n) -&gt; Optional[Union[stac.Item, Response]]:\n    \"\"\"Delete an item from a collection.\n\n    Called with `DELETE /collections/{collection_id}/items/{item_id}`\n\n    Args:\n        item_id: id of the item.\n        collection_id: id of the collection.\n\n    Returns:\n        The deleted item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.patch_collection","title":"patch_collection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>patch_collection(\n    collection_id: str, patch: Union[PartialCollection, List[PatchOperation]], **kwargs\n) -&gt; Optional[Union[Collection, Response]]\n</code></pre> <p>Update a collection.</p> <p>Called with <code>PATCH /collections/{collection_id}</code></p> example <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> <li> <code>patch</code>               (<code>Union[PartialCollection, List[PatchOperation]]</code>)           \u2013            <p>either the partial collection or list of patch operations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Collection, Response]]</code>           \u2013            <p>The patched collection.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\nasync def patch_collection(\n    self,\n    collection_id: str,\n    patch: Union[PartialCollection, List[PatchOperation]],\n    **kwargs,\n) -&gt; Optional[Union[stac.Collection, Response]]:\n    \"\"\"Update a collection.\n\n    Called with `PATCH /collections/{collection_id}`\n\n    example:\n        # convert merge patch item to list of operations\n        if isinstance(patch, PartialCollection):\n            patch = patch.operations()\n\n        collection = backend.patch_collection(collection_id, patch)\n\n        return collection\n\n    Args:\n        collection_id: id of the collection.\n        patch: either the partial collection or list of patch operations.\n\n    Returns:\n        The patched collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.patch_collection--convert-merge-patch-item-to-list-of-operations","title":"convert merge patch item to list of operations","text":"<p>if isinstance(patch, PartialCollection):     patch = patch.operations()</p> <p>collection = backend.patch_collection(collection_id, patch)</p> <p>return collection</p>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.patch_item","title":"patch_item  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>patch_item(\n    collection_id: str, item_id: str, patch: Union[PartialItem, List[PatchOperation]], **kwargs\n) -&gt; Optional[Union[Item, Response]]\n</code></pre> <p>Update an item from a collection.</p> <p>Called with <code>PATCH /collections/{collection_id}/items/{item_id}</code></p> example <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>str</code>)           \u2013            <p>id of the item.</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> <li> <code>patch</code>               (<code>Union[PartialItem, List[PatchOperation]]</code>)           \u2013            <p>either the partial item or list of patch operations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Item, Response]]</code>           \u2013            <p>The patched item.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\nasync def patch_item(\n    self,\n    collection_id: str,\n    item_id: str,\n    patch: Union[PartialItem, List[PatchOperation]],\n    **kwargs,\n) -&gt; Optional[Union[stac.Item, Response]]:\n    \"\"\"Update an item from a collection.\n\n    Called with `PATCH /collections/{collection_id}/items/{item_id}`\n\n    example:\n        # convert merge patch item to list of operations\n        if isinstance(patch, PartialItem):\n            patch = patch.operations()\n\n        item = backend.patch_item(collection_id, item_id, patch)\n\n        return item\n\n    Args:\n        item_id: id of the item.\n        collection_id: id of the collection.\n        patch: either the partial item or list of patch operations.\n\n    Returns:\n        The patched item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.patch_item--convert-merge-patch-item-to-list-of-operations","title":"convert merge patch item to list of operations","text":"<p>if isinstance(patch, PartialItem):     patch = patch.operations()</p> <p>item = backend.patch_item(collection_id, item_id, patch)</p> <p>return item</p>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.update_collection","title":"update_collection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_collection(\n    collection_id: str, collection: Collection, **kwargs\n) -&gt; Optional[Union[Collection, Response]]\n</code></pre> <p>Perform a complete update on an existing collection.</p> <p>Called with <code>PUT /collections/{collection_id}</code>. It is expected that this item already exists.  The update should do a diff against the saved collection and perform any necessary updates.  Partial updates are not supported by the transactions extension.</p> <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the existing collection to be updated</p> </li> <li> <code>collection</code>               (<code>Collection</code>)           \u2013            <p>the updated collection (must be complete)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Collection, Response]]</code>           \u2013            <p>The updated collection.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\nasync def update_collection(\n    self, collection_id: str, collection: Collection, **kwargs\n) -&gt; Optional[Union[stac.Collection, Response]]:\n    \"\"\"Perform a complete update on an existing collection.\n\n    Called with `PUT /collections/{collection_id}`. It is expected that this item\n    already exists.  The update should do a diff against the saved collection and\n    perform any necessary updates.  Partial updates are not supported by the\n    transactions extension.\n\n    Args:\n        collection_id: id of the existing collection to be updated\n        collection: the updated collection (must be complete)\n\n    Returns:\n        The updated collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.AsyncBaseTransactionsClient.update_item","title":"update_item  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_item(\n    collection_id: str, item_id: str, item: Item, **kwargs\n) -&gt; Optional[Union[Item, Response]]\n</code></pre> <p>Perform a complete update on an existing item.</p> <p>Called with <code>PUT /collections/{collection_id}/items</code>. It is expected that this item already exists.  The update should do a diff against the saved item and perform any necessary updates.  Partial updates are not supported by the transactions extension.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Item</code>)           \u2013            <p>the item (must be complete)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Item, Response]]</code>           \u2013            <p>The updated item.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\nasync def update_item(\n    self, collection_id: str, item_id: str, item: Item, **kwargs\n) -&gt; Optional[Union[stac.Item, Response]]:\n    \"\"\"Perform a complete update on an existing item.\n\n    Called with `PUT /collections/{collection_id}/items`. It is expected\n    that this item already exists.  The update should do a diff against the\n    saved item and perform any necessary updates.  Partial updates are not\n    supported by the transactions extension.\n\n    Args:\n        item: the item (must be complete)\n\n    Returns:\n        The updated item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient","title":"BaseTransactionsClient","text":"<p>               Bases: <code>ABC</code></p> <p>Defines a pattern for implementing the STAC API Transaction Extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@attr.s  # type:ignore\nclass BaseTransactionsClient(abc.ABC):\n    \"\"\"Defines a pattern for implementing the STAC API Transaction Extension.\"\"\"\n\n    @abc.abstractmethod\n    def create_item(\n        self,\n        collection_id: str,\n        item: Union[Item, ItemCollection],\n        **kwargs,\n    ) -&gt; Optional[Union[stac.Item, Response, None]]:\n        \"\"\"Create a new item.\n\n        Called with `POST /collections/{collection_id}/items`.\n\n        Args:\n            item: the item or item collection\n            collection_id: the id of the collection from the resource path\n\n        Returns:\n            The item that was created or None if item collection.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def update_item(\n        self, collection_id: str, item_id: str, item: Item, **kwargs\n    ) -&gt; Optional[Union[stac.Item, Response]]:\n        \"\"\"Perform a complete update on an existing item.\n\n        Called with `PUT /collections/{collection_id}/items`. It is expected\n        that this item already exists.  The update should do a diff against the\n        saved item and perform any necessary updates.  Partial updates are not\n        supported by the transactions extension.\n\n        Args:\n            item: the item (must be complete)\n            collection_id: the id of the collection from the resource path\n\n        Returns:\n            The updated item.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def patch_item(\n        self,\n        collection_id: str,\n        item_id: str,\n        patch: Union[PartialItem, List[PatchOperation]],\n        **kwargs,\n    ) -&gt; Optional[Union[stac.Item, Response]]:\n        \"\"\"Update an item from a collection.\n\n        Called with `PATCH /collections/{collection_id}/items/{item_id}`\n\n        example:\n            # convert merge patch item to list of operations\n            if isinstance(patch, PartialItem):\n                patch = patch.operations()\n\n            item = backend.patch_item(collection_id, item_id, patch)\n\n            return item\n\n        Args:\n            item_id: id of the item.\n            collection_id: id of the collection.\n            patch: either the partial item or list of patch operations.\n\n        Returns:\n            The patched item.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def delete_item(\n        self, item_id: str, collection_id: str, **kwargs\n    ) -&gt; Optional[Union[stac.Item, Response]]:\n        \"\"\"Delete an item from a collection.\n\n        Called with `DELETE /collections/{collection_id}/items/{item_id}`\n\n        Args:\n            item_id: id of the item.\n            collection_id: id of the collection.\n\n        Returns:\n            The deleted item.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def create_collection(\n        self, collection: Collection, **kwargs\n    ) -&gt; Optional[Union[stac.Collection, Response]]:\n        \"\"\"Create a new collection.\n\n        Called with `POST /collections`.\n\n        Args:\n            collection: the collection\n\n        Returns:\n            The collection that was created.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def update_collection(\n        self, collection_id: str, collection: Collection, **kwargs\n    ) -&gt; Optional[Union[stac.Collection, Response]]:\n        \"\"\"Perform a complete update on an existing collection.\n\n        Called with `PUT /collections/{collection_id}`. It is expected that this\n        collection already exists.  The update should do a diff against the saved\n        collection and perform any necessary updates.  Partial updates are not\n        supported by the transactions extension.\n\n        Args:\n            collection_id: id of the existing collection to be updated\n            collection: the updated collection (must be complete)\n\n        Returns:\n            The updated collection.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def patch_collection(\n        self,\n        collection_id: str,\n        patch: Union[PartialCollection, List[PatchOperation]],\n        **kwargs,\n    ) -&gt; Optional[Union[stac.Collection, Response]]:\n        \"\"\"Update a collection.\n\n        Called with `PATCH /collections/{collection_id}`\n\n        example:\n            # convert merge patch item to list of operations\n            if isinstance(patch, PartialCollection):\n                patch = patch.operations()\n\n            collection = backend.patch_collection(collection_id, patch)\n\n            return collection\n\n        Args:\n            collection_id: id of the collection.\n            patch: either the partial collection or list of patch operations.\n\n        Returns:\n            The patched collection.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def delete_collection(\n        self, collection_id: str, **kwargs\n    ) -&gt; Optional[Union[stac.Collection, Response]]:\n        \"\"\"Delete a collection.\n\n        Called with `DELETE /collections/{collection_id}`\n\n        Args:\n            collection_id: id of the collection.\n\n        Returns:\n            The deleted collection.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.create_collection","title":"create_collection  <code>abstractmethod</code>","text":"<pre><code>create_collection(collection: Collection, **kwargs) -&gt; Optional[Union[Collection, Response]]\n</code></pre> <p>Create a new collection.</p> <p>Called with <code>POST /collections</code>.</p> <p>Parameters:</p> <ul> <li> <code>collection</code>               (<code>Collection</code>)           \u2013            <p>the collection</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Collection, Response]]</code>           \u2013            <p>The collection that was created.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\ndef create_collection(\n    self, collection: Collection, **kwargs\n) -&gt; Optional[Union[stac.Collection, Response]]:\n    \"\"\"Create a new collection.\n\n    Called with `POST /collections`.\n\n    Args:\n        collection: the collection\n\n    Returns:\n        The collection that was created.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.create_item","title":"create_item  <code>abstractmethod</code>","text":"<pre><code>create_item(\n    collection_id: str, item: Union[Item, ItemCollection], **kwargs\n) -&gt; Optional[Union[Item, Response, None]]\n</code></pre> <p>Create a new item.</p> <p>Called with <code>POST /collections/{collection_id}/items</code>.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Union[Item, ItemCollection]</code>)           \u2013            <p>the item or item collection</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>the id of the collection from the resource path</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Item, Response, None]]</code>           \u2013            <p>The item that was created or None if item collection.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\ndef create_item(\n    self,\n    collection_id: str,\n    item: Union[Item, ItemCollection],\n    **kwargs,\n) -&gt; Optional[Union[stac.Item, Response, None]]:\n    \"\"\"Create a new item.\n\n    Called with `POST /collections/{collection_id}/items`.\n\n    Args:\n        item: the item or item collection\n        collection_id: the id of the collection from the resource path\n\n    Returns:\n        The item that was created or None if item collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.delete_collection","title":"delete_collection  <code>abstractmethod</code>","text":"<pre><code>delete_collection(collection_id: str, **kwargs) -&gt; Optional[Union[Collection, Response]]\n</code></pre> <p>Delete a collection.</p> <p>Called with <code>DELETE /collections/{collection_id}</code></p> <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Collection, Response]]</code>           \u2013            <p>The deleted collection.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\ndef delete_collection(\n    self, collection_id: str, **kwargs\n) -&gt; Optional[Union[stac.Collection, Response]]:\n    \"\"\"Delete a collection.\n\n    Called with `DELETE /collections/{collection_id}`\n\n    Args:\n        collection_id: id of the collection.\n\n    Returns:\n        The deleted collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.delete_item","title":"delete_item  <code>abstractmethod</code>","text":"<pre><code>delete_item(item_id: str, collection_id: str, **kwargs) -&gt; Optional[Union[Item, Response]]\n</code></pre> <p>Delete an item from a collection.</p> <p>Called with <code>DELETE /collections/{collection_id}/items/{item_id}</code></p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>str</code>)           \u2013            <p>id of the item.</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Item, Response]]</code>           \u2013            <p>The deleted item.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\ndef delete_item(\n    self, item_id: str, collection_id: str, **kwargs\n) -&gt; Optional[Union[stac.Item, Response]]:\n    \"\"\"Delete an item from a collection.\n\n    Called with `DELETE /collections/{collection_id}/items/{item_id}`\n\n    Args:\n        item_id: id of the item.\n        collection_id: id of the collection.\n\n    Returns:\n        The deleted item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.patch_collection","title":"patch_collection  <code>abstractmethod</code>","text":"<pre><code>patch_collection(\n    collection_id: str, patch: Union[PartialCollection, List[PatchOperation]], **kwargs\n) -&gt; Optional[Union[Collection, Response]]\n</code></pre> <p>Update a collection.</p> <p>Called with <code>PATCH /collections/{collection_id}</code></p> example <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> <li> <code>patch</code>               (<code>Union[PartialCollection, List[PatchOperation]]</code>)           \u2013            <p>either the partial collection or list of patch operations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Collection, Response]]</code>           \u2013            <p>The patched collection.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\ndef patch_collection(\n    self,\n    collection_id: str,\n    patch: Union[PartialCollection, List[PatchOperation]],\n    **kwargs,\n) -&gt; Optional[Union[stac.Collection, Response]]:\n    \"\"\"Update a collection.\n\n    Called with `PATCH /collections/{collection_id}`\n\n    example:\n        # convert merge patch item to list of operations\n        if isinstance(patch, PartialCollection):\n            patch = patch.operations()\n\n        collection = backend.patch_collection(collection_id, patch)\n\n        return collection\n\n    Args:\n        collection_id: id of the collection.\n        patch: either the partial collection or list of patch operations.\n\n    Returns:\n        The patched collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.patch_collection--convert-merge-patch-item-to-list-of-operations","title":"convert merge patch item to list of operations","text":"<p>if isinstance(patch, PartialCollection):     patch = patch.operations()</p> <p>collection = backend.patch_collection(collection_id, patch)</p> <p>return collection</p>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.patch_item","title":"patch_item  <code>abstractmethod</code>","text":"<pre><code>patch_item(\n    collection_id: str, item_id: str, patch: Union[PartialItem, List[PatchOperation]], **kwargs\n) -&gt; Optional[Union[Item, Response]]\n</code></pre> <p>Update an item from a collection.</p> <p>Called with <code>PATCH /collections/{collection_id}/items/{item_id}</code></p> example <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>str</code>)           \u2013            <p>id of the item.</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> <li> <code>patch</code>               (<code>Union[PartialItem, List[PatchOperation]]</code>)           \u2013            <p>either the partial item or list of patch operations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Item, Response]]</code>           \u2013            <p>The patched item.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\ndef patch_item(\n    self,\n    collection_id: str,\n    item_id: str,\n    patch: Union[PartialItem, List[PatchOperation]],\n    **kwargs,\n) -&gt; Optional[Union[stac.Item, Response]]:\n    \"\"\"Update an item from a collection.\n\n    Called with `PATCH /collections/{collection_id}/items/{item_id}`\n\n    example:\n        # convert merge patch item to list of operations\n        if isinstance(patch, PartialItem):\n            patch = patch.operations()\n\n        item = backend.patch_item(collection_id, item_id, patch)\n\n        return item\n\n    Args:\n        item_id: id of the item.\n        collection_id: id of the collection.\n        patch: either the partial item or list of patch operations.\n\n    Returns:\n        The patched item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.patch_item--convert-merge-patch-item-to-list-of-operations","title":"convert merge patch item to list of operations","text":"<p>if isinstance(patch, PartialItem):     patch = patch.operations()</p> <p>item = backend.patch_item(collection_id, item_id, patch)</p> <p>return item</p>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.update_collection","title":"update_collection  <code>abstractmethod</code>","text":"<pre><code>update_collection(\n    collection_id: str, collection: Collection, **kwargs\n) -&gt; Optional[Union[Collection, Response]]\n</code></pre> <p>Perform a complete update on an existing collection.</p> <p>Called with <code>PUT /collections/{collection_id}</code>. It is expected that this collection already exists.  The update should do a diff against the saved collection and perform any necessary updates.  Partial updates are not supported by the transactions extension.</p> <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the existing collection to be updated</p> </li> <li> <code>collection</code>               (<code>Collection</code>)           \u2013            <p>the updated collection (must be complete)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Collection, Response]]</code>           \u2013            <p>The updated collection.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\ndef update_collection(\n    self, collection_id: str, collection: Collection, **kwargs\n) -&gt; Optional[Union[stac.Collection, Response]]:\n    \"\"\"Perform a complete update on an existing collection.\n\n    Called with `PUT /collections/{collection_id}`. It is expected that this\n    collection already exists.  The update should do a diff against the saved\n    collection and perform any necessary updates.  Partial updates are not\n    supported by the transactions extension.\n\n    Args:\n        collection_id: id of the existing collection to be updated\n        collection: the updated collection (must be complete)\n\n    Returns:\n        The updated collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.BaseTransactionsClient.update_item","title":"update_item  <code>abstractmethod</code>","text":"<pre><code>update_item(\n    collection_id: str, item_id: str, item: Item, **kwargs\n) -&gt; Optional[Union[Item, Response]]\n</code></pre> <p>Perform a complete update on an existing item.</p> <p>Called with <code>PUT /collections/{collection_id}/items</code>. It is expected that this item already exists.  The update should do a diff against the saved item and perform any necessary updates.  Partial updates are not supported by the transactions extension.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Item</code>)           \u2013            <p>the item (must be complete)</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>the id of the collection from the resource path</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[Item, Response]]</code>           \u2013            <p>The updated item.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/client.py</code> <pre><code>@abc.abstractmethod\ndef update_item(\n    self, collection_id: str, item_id: str, item: Item, **kwargs\n) -&gt; Optional[Union[stac.Item, Response]]:\n    \"\"\"Perform a complete update on an existing item.\n\n    Called with `PUT /collections/{collection_id}/items`. It is expected\n    that this item already exists.  The update should do a diff against the\n    saved item and perform any necessary updates.  Partial updates are not\n    supported by the transactions extension.\n\n    Args:\n        item: the item (must be complete)\n        collection_id: the id of the collection from the resource path\n\n    Returns:\n        The updated item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionConformanceClasses","title":"TransactionConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the Transaction extension.</p> <p>See stac-api-extensions/transaction</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>class TransactionConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the Transaction extension.\n\n    See https://github.com/stac-api-extensions/transaction\n\n    \"\"\"\n\n    ITEMS = \"https://api.stacspec.org/v1.0.0/ogcapi-features/extensions/transaction\"\n    COLLECTIONS = \"https://api.stacspec.org/v1.0.0/collections/extensions/transaction\"\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension","title":"TransactionExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Transaction Extension.</p> <p>The transaction extension adds several endpoints which allow the creation, deletion, and updating of items and collections:     POST /collections     PUT /collections/{collection_id}     DELETE /collections/{collection_id}     POST /collections/{collection_id}/items     PUT /collections/{collection_id}/items     DELETE /collections/{collection_id}/items</p> <p>stac-api-extensions/transaction stac-api-extensions/collection-transaction</p> <p>Attributes:</p> <ul> <li> <code>client</code>               (<code>Union[AsyncBaseTransactionsClient, BaseTransactionsClient]</code>)           \u2013            <p>CRUD application logic</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>@attr.s\nclass TransactionExtension(ApiExtension):\n    \"\"\"Transaction Extension.\n\n    The transaction extension adds several endpoints which allow the creation,\n    deletion, and updating of items and collections:\n        POST /collections\n        PUT /collections/{collection_id}\n        DELETE /collections/{collection_id}\n        POST /collections/{collection_id}/items\n        PUT /collections/{collection_id}/items\n        DELETE /collections/{collection_id}/items\n\n    https://github.com/stac-api-extensions/transaction\n    https://github.com/stac-api-extensions/collection-transaction\n\n    Attributes:\n        client: CRUD application logic\n\n    \"\"\"\n\n    client: Union[AsyncBaseTransactionsClient, BaseTransactionsClient] = attr.ib()\n    settings: ApiSettings = attr.ib()\n    conformance_classes: List[str] = attr.ib(\n        factory=lambda: [\n            TransactionConformanceClasses.ITEMS,\n            TransactionConformanceClasses.COLLECTIONS,\n        ]\n    )\n    schema_href: Optional[str] = attr.ib(default=None)\n    router: APIRouter = attr.ib(factory=APIRouter)\n    response_class: Type[Response] = attr.ib(default=JSONResponse)\n\n    def register_create_item(self):\n        \"\"\"Register create item endpoint (POST /collections/{collection_id}/items).\"\"\"\n        self.router.add_api_route(\n            name=\"Create Item\",\n            path=\"/collections/{collection_id}/items\",\n            status_code=201,\n            response_model=Item if self.settings.enable_response_models else None,\n            responses={\n                201: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": Item,\n                }\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"POST\"],\n            endpoint=create_async_endpoint(self.client.create_item, PostItem),\n        )\n\n    def register_update_item(self):\n        \"\"\"Register update item endpoint (PUT\n        /collections/{collection_id}/items/{item_id}).\"\"\"\n        self.router.add_api_route(\n            name=\"Update Item\",\n            path=\"/collections/{collection_id}/items/{item_id}\",\n            response_model=Item if self.settings.enable_response_models else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": Item,\n                }\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"PUT\"],\n            endpoint=create_async_endpoint(self.client.update_item, PutItem),\n        )\n\n    def register_patch_item(self):\n        \"\"\"Register patch item endpoint (PATCH\n        /collections/{collection_id}/items/{item_id}).\"\"\"\n        self.router.add_api_route(\n            name=\"Patch Item\",\n            path=\"/collections/{collection_id}/items/{item_id}\",\n            response_model=Item if self.settings.enable_response_models else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": Item,\n                }\n            },\n            openapi_extra={\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json-patch+json\": {\n                            \"schema\": _patch_item_schema,\n                        },\n                        \"application/merge-patch+json\": {\n                            \"schema\": PartialItem.model_json_schema(),\n                        },\n                        \"application/json\": {\n                            \"schema\": PartialItem.model_json_schema(),\n                        },\n                    },\n                    \"required\": True,\n                },\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"PATCH\"],\n            endpoint=create_async_endpoint(\n                self.client.patch_item,\n                PatchItem,\n            ),\n        )\n\n    def register_delete_item(self):\n        \"\"\"Register delete item endpoint (DELETE\n        /collections/{collection_id}/items/{item_id}).\"\"\"\n        self.router.add_api_route(\n            name=\"Delete Item\",\n            path=\"/collections/{collection_id}/items/{item_id}\",\n            response_model=Item if self.settings.enable_response_models else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": Item,\n                }\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"DELETE\"],\n            endpoint=create_async_endpoint(self.client.delete_item, ItemUri),\n        )\n\n    def register_create_collection(self):\n        \"\"\"Register create collection endpoint (POST /collections).\"\"\"\n        self.router.add_api_route(\n            name=\"Create Collection\",\n            path=\"/collections\",\n            status_code=201,\n            response_model=Collection if self.settings.enable_response_models else None,\n            responses={\n                201: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": Collection,\n                }\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"POST\"],\n            endpoint=create_async_endpoint(self.client.create_collection, Collection),\n        )\n\n    def register_update_collection(self):\n        \"\"\"Register update collection endpoint (PUT /collections/{collection_id}).\"\"\"\n        self.router.add_api_route(\n            name=\"Update Collection\",\n            path=\"/collections/{collection_id}\",\n            response_model=Collection if self.settings.enable_response_models else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": Collection,\n                }\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"PUT\"],\n            endpoint=create_async_endpoint(self.client.update_collection, PutCollection),\n        )\n\n    def register_patch_collection(self):\n        \"\"\"Register patch collection endpoint (PATCH /collections/{collection_id}).\"\"\"\n        self.router.add_api_route(\n            name=\"Patch Collection\",\n            path=\"/collections/{collection_id}\",\n            response_model=Collection if self.settings.enable_response_models else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.geojson.value: {},\n                    },\n                    \"model\": Collection,\n                }\n            },\n            openapi_extra={\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json-patch+json\": {\n                            \"schema\": _patch_collection_schema,\n                        },\n                        \"application/merge-patch+json\": {\n                            \"schema\": PartialCollection.model_json_schema(),\n                        },\n                        \"application/json\": {\n                            \"schema\": PartialCollection.model_json_schema(),\n                        },\n                    },\n                    \"required\": True,\n                },\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"PATCH\"],\n            endpoint=create_async_endpoint(\n                self.client.patch_collection,\n                PatchCollection,\n            ),\n        )\n\n    def register_delete_collection(self):\n        \"\"\"Register delete collection endpoint (DELETE /collections/{collection_id}).\"\"\"\n        self.router.add_api_route(\n            name=\"Delete Collection\",\n            path=\"/collections/{collection_id}\",\n            response_model=Collection if self.settings.enable_response_models else None,\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": Collection,\n                }\n            },\n            response_class=self.response_class,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"DELETE\"],\n            endpoint=create_async_endpoint(self.client.delete_collection, CollectionUri),\n        )\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        self.router.prefix = app.state.router_prefix\n        self.register_create_item()\n        self.register_update_item()\n        self.register_patch_item()\n        self.register_delete_item()\n        self.register_create_collection()\n        self.register_update_collection()\n        self.register_patch_collection()\n        self.register_delete_collection()\n        app.include_router(self.router, tags=[\"Transaction Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    self.router.prefix = app.state.router_prefix\n    self.register_create_item()\n    self.register_update_item()\n    self.register_patch_item()\n    self.register_delete_item()\n    self.register_create_collection()\n    self.register_update_collection()\n    self.register_patch_collection()\n    self.register_delete_collection()\n    app.include_router(self.router, tags=[\"Transaction Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register_create_collection","title":"register_create_collection","text":"<pre><code>register_create_collection()\n</code></pre> <p>Register create collection endpoint (POST /collections).</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register_create_collection(self):\n    \"\"\"Register create collection endpoint (POST /collections).\"\"\"\n    self.router.add_api_route(\n        name=\"Create Collection\",\n        path=\"/collections\",\n        status_code=201,\n        response_model=Collection if self.settings.enable_response_models else None,\n        responses={\n            201: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": Collection,\n            }\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"POST\"],\n        endpoint=create_async_endpoint(self.client.create_collection, Collection),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register_create_item","title":"register_create_item","text":"<pre><code>register_create_item()\n</code></pre> <p>Register create item endpoint (POST /collections/{collection_id}/items).</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register_create_item(self):\n    \"\"\"Register create item endpoint (POST /collections/{collection_id}/items).\"\"\"\n    self.router.add_api_route(\n        name=\"Create Item\",\n        path=\"/collections/{collection_id}/items\",\n        status_code=201,\n        response_model=Item if self.settings.enable_response_models else None,\n        responses={\n            201: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": Item,\n            }\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"POST\"],\n        endpoint=create_async_endpoint(self.client.create_item, PostItem),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register_delete_collection","title":"register_delete_collection","text":"<pre><code>register_delete_collection()\n</code></pre> <p>Register delete collection endpoint (DELETE /collections/{collection_id}).</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register_delete_collection(self):\n    \"\"\"Register delete collection endpoint (DELETE /collections/{collection_id}).\"\"\"\n    self.router.add_api_route(\n        name=\"Delete Collection\",\n        path=\"/collections/{collection_id}\",\n        response_model=Collection if self.settings.enable_response_models else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": Collection,\n            }\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"DELETE\"],\n        endpoint=create_async_endpoint(self.client.delete_collection, CollectionUri),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register_delete_item","title":"register_delete_item","text":"<pre><code>register_delete_item()\n</code></pre> <p>Register delete item endpoint (DELETE /collections/{collection_id}/items/{item_id}).</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register_delete_item(self):\n    \"\"\"Register delete item endpoint (DELETE\n    /collections/{collection_id}/items/{item_id}).\"\"\"\n    self.router.add_api_route(\n        name=\"Delete Item\",\n        path=\"/collections/{collection_id}/items/{item_id}\",\n        response_model=Item if self.settings.enable_response_models else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": Item,\n            }\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"DELETE\"],\n        endpoint=create_async_endpoint(self.client.delete_item, ItemUri),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register_patch_collection","title":"register_patch_collection","text":"<pre><code>register_patch_collection()\n</code></pre> <p>Register patch collection endpoint (PATCH /collections/{collection_id}).</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register_patch_collection(self):\n    \"\"\"Register patch collection endpoint (PATCH /collections/{collection_id}).\"\"\"\n    self.router.add_api_route(\n        name=\"Patch Collection\",\n        path=\"/collections/{collection_id}\",\n        response_model=Collection if self.settings.enable_response_models else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": Collection,\n            }\n        },\n        openapi_extra={\n            \"requestBody\": {\n                \"content\": {\n                    \"application/json-patch+json\": {\n                        \"schema\": _patch_collection_schema,\n                    },\n                    \"application/merge-patch+json\": {\n                        \"schema\": PartialCollection.model_json_schema(),\n                    },\n                    \"application/json\": {\n                        \"schema\": PartialCollection.model_json_schema(),\n                    },\n                },\n                \"required\": True,\n            },\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"PATCH\"],\n        endpoint=create_async_endpoint(\n            self.client.patch_collection,\n            PatchCollection,\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register_patch_item","title":"register_patch_item","text":"<pre><code>register_patch_item()\n</code></pre> <p>Register patch item endpoint (PATCH /collections/{collection_id}/items/{item_id}).</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register_patch_item(self):\n    \"\"\"Register patch item endpoint (PATCH\n    /collections/{collection_id}/items/{item_id}).\"\"\"\n    self.router.add_api_route(\n        name=\"Patch Item\",\n        path=\"/collections/{collection_id}/items/{item_id}\",\n        response_model=Item if self.settings.enable_response_models else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": Item,\n            }\n        },\n        openapi_extra={\n            \"requestBody\": {\n                \"content\": {\n                    \"application/json-patch+json\": {\n                        \"schema\": _patch_item_schema,\n                    },\n                    \"application/merge-patch+json\": {\n                        \"schema\": PartialItem.model_json_schema(),\n                    },\n                    \"application/json\": {\n                        \"schema\": PartialItem.model_json_schema(),\n                    },\n                },\n                \"required\": True,\n            },\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"PATCH\"],\n        endpoint=create_async_endpoint(\n            self.client.patch_item,\n            PatchItem,\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register_update_collection","title":"register_update_collection","text":"<pre><code>register_update_collection()\n</code></pre> <p>Register update collection endpoint (PUT /collections/{collection_id}).</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register_update_collection(self):\n    \"\"\"Register update collection endpoint (PUT /collections/{collection_id}).\"\"\"\n    self.router.add_api_route(\n        name=\"Update Collection\",\n        path=\"/collections/{collection_id}\",\n        response_model=Collection if self.settings.enable_response_models else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": Collection,\n            }\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"PUT\"],\n        endpoint=create_async_endpoint(self.client.update_collection, PutCollection),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/transaction/#stac_fastapi.extensions.core.transaction.TransactionExtension.register_update_item","title":"register_update_item","text":"<pre><code>register_update_item()\n</code></pre> <p>Register update item endpoint (PUT /collections/{collection_id}/items/{item_id}).</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/transaction/transaction.py</code> <pre><code>def register_update_item(self):\n    \"\"\"Register update item endpoint (PUT\n    /collections/{collection_id}/items/{item_id}).\"\"\"\n    self.router.add_api_route(\n        name=\"Update Item\",\n        path=\"/collections/{collection_id}/items/{item_id}\",\n        response_model=Item if self.settings.enable_response_models else None,\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.geojson.value: {},\n                },\n                \"model\": Item,\n            }\n        },\n        response_class=self.response_class,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"PUT\"],\n        endpoint=create_async_endpoint(self.client.update_item, PutItem),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/","title":"Module stac_fastapi.extensions.core.aggregation","text":"<p>Aggregation Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/aggregation/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.aggregation.aggregation</li> <li>stac_fastapi.extensions.core.aggregation.client</li> <li>stac_fastapi.extensions.core.aggregation.request</li> <li>stac_fastapi.extensions.core.aggregation.types</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/aggregation/aggregation/","title":"aggregation","text":""},{"location":"api/stac_fastapi/extensions/core/aggregation/aggregation/#stac_fastapi.extensions.core.aggregation.aggregation","title":"stac_fastapi.extensions.core.aggregation.aggregation","text":"<p>Aggregation Extension.</p>"},{"location":"api/stac_fastapi/extensions/core/aggregation/aggregation/#stac_fastapi.extensions.core.aggregation.aggregation.AggregationConformanceClasses","title":"AggregationConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the Aggregation extension.</p> <p>See stac-api-extensions/aggregation</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/aggregation.py</code> <pre><code>class AggregationConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the Aggregation extension.\n\n    See\n    https://github.com/stac-api-extensions/aggregation\n    \"\"\"\n\n    AGGREGATION = \"https://api.stacspec.org/v0.3.0/aggregation\"\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/aggregation/#stac_fastapi.extensions.core.aggregation.aggregation.AggregationExtension","title":"AggregationExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Aggregation Extension.</p> <p>The purpose of the Aggregation Extension is to provide an endpoint similar to the Search endpoint (/search), but which will provide aggregated information on matching Items rather than the Items themselves. This is highly influenced by the Elasticsearch and OpenSearch aggregation endpoint, but with a more regular structure for responses.</p> <p>The Aggregation extension adds several endpoints which allow the retrieval of available aggregation fields and aggregation buckets based on a seearch query:     GET /aggregations     POST /aggregations     GET /collections/{collection_id}/aggregations     POST /collections/{collection_id}/aggregations     GET /aggregate     POST /aggregate     GET /collections/{collection_id}/aggregate     POST /collections/{collection_id}/aggregate</p> <p>github.com/stac-api-extensions/aggregation/blob/main/README.md</p> <p>Attributes:</p> <ul> <li> <code>conformance_classes</code>               (<code>List[str]</code>)           \u2013            <p>Conformance classes provided by the extension</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/aggregation.py</code> <pre><code>@attr.s\nclass AggregationExtension(ApiExtension):\n    \"\"\"Aggregation Extension.\n\n    The purpose of the Aggregation Extension is to provide an endpoint similar to\n    the Search endpoint (/search), but which will provide aggregated information\n    on matching Items rather than the Items themselves. This is highly influenced\n    by the Elasticsearch and OpenSearch aggregation endpoint, but with a more\n    regular structure for responses.\n\n    The Aggregation extension adds several endpoints which allow the retrieval of\n    available aggregation fields and aggregation buckets based on a seearch query:\n        GET /aggregations\n        POST /aggregations\n        GET /collections/{collection_id}/aggregations\n        POST /collections/{collection_id}/aggregations\n        GET /aggregate\n        POST /aggregate\n        GET /collections/{collection_id}/aggregate\n        POST /collections/{collection_id}/aggregate\n\n    https://github.com/stac-api-extensions/aggregation/blob/main/README.md\n\n    Attributes:\n        conformance_classes: Conformance classes provided by the extension\n    \"\"\"\n\n    GET: Type[APIRequest] = AggregationExtensionGetRequest\n    POST: Type[BaseModel] = AggregationExtensionPostRequest\n\n    client: Union[AsyncBaseAggregationClient, BaseAggregationClient] = attr.ib(\n        factory=BaseAggregationClient\n    )\n\n    conformance_classes: List[str] = attr.ib(\n        default=[AggregationConformanceClasses.AGGREGATION]\n    )\n    router: APIRouter = attr.ib(factory=APIRouter)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        self.router.prefix = app.state.router_prefix\n        self.router.add_api_route(\n            name=\"Aggregations\",\n            path=\"/aggregations\",\n            methods=[\"GET\", \"POST\"],\n            endpoint=create_async_endpoint(self.client.get_aggregations, EmptyRequest),\n        )\n        self.router.add_api_route(\n            name=\"Collection Aggregations\",\n            path=\"/collections/{collection_id}/aggregations\",\n            methods=[\"GET\", \"POST\"],\n            endpoint=create_async_endpoint(self.client.get_aggregations, CollectionUri),\n        )\n        self.router.add_api_route(\n            name=\"Aggregate\",\n            path=\"/aggregate\",\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(self.client.aggregate, self.GET),\n        )\n        self.router.add_api_route(\n            name=\"Aggregate\",\n            path=\"/aggregate\",\n            methods=[\"POST\"],\n            endpoint=create_async_endpoint(self.client.aggregate, self.POST),\n        )\n        self.router.add_api_route(\n            name=\"Collection Aggregate\",\n            path=\"/collections/{collection_id}/aggregate\",\n            methods=[\"GET\"],\n            endpoint=create_async_endpoint(self.client.aggregate, self.GET),\n        )\n        self.router.add_api_route(\n            name=\"Collection Aggregate\",\n            path=\"/collections/{collection_id}/aggregate\",\n            methods=[\"POST\"],\n            endpoint=create_async_endpoint(self.client.aggregate, self.POST),\n        )\n        app.include_router(self.router, tags=[\"Aggregation Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/aggregation/#stac_fastapi.extensions.core.aggregation.aggregation.AggregationExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/aggregation.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    self.router.prefix = app.state.router_prefix\n    self.router.add_api_route(\n        name=\"Aggregations\",\n        path=\"/aggregations\",\n        methods=[\"GET\", \"POST\"],\n        endpoint=create_async_endpoint(self.client.get_aggregations, EmptyRequest),\n    )\n    self.router.add_api_route(\n        name=\"Collection Aggregations\",\n        path=\"/collections/{collection_id}/aggregations\",\n        methods=[\"GET\", \"POST\"],\n        endpoint=create_async_endpoint(self.client.get_aggregations, CollectionUri),\n    )\n    self.router.add_api_route(\n        name=\"Aggregate\",\n        path=\"/aggregate\",\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(self.client.aggregate, self.GET),\n    )\n    self.router.add_api_route(\n        name=\"Aggregate\",\n        path=\"/aggregate\",\n        methods=[\"POST\"],\n        endpoint=create_async_endpoint(self.client.aggregate, self.POST),\n    )\n    self.router.add_api_route(\n        name=\"Collection Aggregate\",\n        path=\"/collections/{collection_id}/aggregate\",\n        methods=[\"GET\"],\n        endpoint=create_async_endpoint(self.client.aggregate, self.GET),\n    )\n    self.router.add_api_route(\n        name=\"Collection Aggregate\",\n        path=\"/collections/{collection_id}/aggregate\",\n        methods=[\"POST\"],\n        endpoint=create_async_endpoint(self.client.aggregate, self.POST),\n    )\n    app.include_router(self.router, tags=[\"Aggregation Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/client/","title":"client","text":""},{"location":"api/stac_fastapi/extensions/core/aggregation/client/#stac_fastapi.extensions.core.aggregation.client","title":"stac_fastapi.extensions.core.aggregation.client","text":"<p>Aggregation extensions clients.</p>"},{"location":"api/stac_fastapi/extensions/core/aggregation/client/#stac_fastapi.extensions.core.aggregation.client.AsyncBaseAggregationClient","title":"AsyncBaseAggregationClient","text":"<p>               Bases: <code>ABC</code></p> <p>Defines an async pattern for implementing the STAC aggregation extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/client.py</code> <pre><code>@attr.s\nclass AsyncBaseAggregationClient(abc.ABC):\n    \"\"\"Defines an async pattern for implementing the STAC aggregation extension.\"\"\"\n\n    # BUCKET = Bucket\n    # AGGREGAION = Aggregation\n    # AGGREGATION_COLLECTION = AggregationCollection\n\n    async def get_aggregations(\n        self, collection_id: Optional[str] = None, **kwargs\n    ) -&gt; AggregationCollection:\n        \"\"\"Get the aggregations available for the given collection_id.\n\n        If collection_id is None, returns the available aggregations over all\n        collections.\n        \"\"\"\n        return AggregationCollection(\n            type=\"AggregationCollection\",\n            aggregations=[Aggregation(name=\"total_count\", data_type=\"integer\")],\n            links=[\n                {\n                    \"rel\": \"root\",\n                    \"type\": \"application/json\",\n                    \"href\": \"https://example.org/\",\n                },\n                {\n                    \"rel\": \"self\",\n                    \"type\": \"application/json\",\n                    \"href\": \"https://example.org/aggregations\",\n                },\n            ],\n        )\n\n    async def aggregate(\n        self,\n        collection_id: Optional[str] = None,\n        aggregations: Optional[Union[str, List[str]]] = None,\n        collections: Optional[List[str]] = None,\n        ids: Optional[List[str]] = None,\n        bbox: Optional[BBox] = None,\n        intersects: Optional[Geometry] = None,\n        datetime: Optional[DateTimeType] = None,\n        limit: Optional[int] = 10,\n        **kwargs,\n    ) -&gt; AggregationCollection:\n        \"\"\"Return the aggregation buckets for a given search result\"\"\"\n        return AggregationCollection(\n            type=\"AggregationCollection\",\n            aggregations=[],\n            links=[\n                {\n                    \"rel\": \"root\",\n                    \"type\": \"application/json\",\n                    \"href\": \"https://example.org/\",\n                },\n                {\n                    \"rel\": \"self\",\n                    \"type\": \"application/json\",\n                    \"href\": \"https://example.org/aggregations\",\n                },\n            ],\n        )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/client/#stac_fastapi.extensions.core.aggregation.client.AsyncBaseAggregationClient.aggregate","title":"aggregate  <code>async</code>","text":"<pre><code>aggregate(\n    collection_id: Optional[str] = None,\n    aggregations: Optional[Union[str, List[str]]] = None,\n    collections: Optional[List[str]] = None,\n    ids: Optional[List[str]] = None,\n    bbox: Optional[BBox] = None,\n    intersects: Optional[Geometry] = None,\n    datetime: Optional[DateTimeType] = None,\n    limit: Optional[int] = 10,\n    **kwargs\n) -&gt; AggregationCollection\n</code></pre> <p>Return the aggregation buckets for a given search result</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/client.py</code> <pre><code>async def aggregate(\n    self,\n    collection_id: Optional[str] = None,\n    aggregations: Optional[Union[str, List[str]]] = None,\n    collections: Optional[List[str]] = None,\n    ids: Optional[List[str]] = None,\n    bbox: Optional[BBox] = None,\n    intersects: Optional[Geometry] = None,\n    datetime: Optional[DateTimeType] = None,\n    limit: Optional[int] = 10,\n    **kwargs,\n) -&gt; AggregationCollection:\n    \"\"\"Return the aggregation buckets for a given search result\"\"\"\n    return AggregationCollection(\n        type=\"AggregationCollection\",\n        aggregations=[],\n        links=[\n            {\n                \"rel\": \"root\",\n                \"type\": \"application/json\",\n                \"href\": \"https://example.org/\",\n            },\n            {\n                \"rel\": \"self\",\n                \"type\": \"application/json\",\n                \"href\": \"https://example.org/aggregations\",\n            },\n        ],\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/client/#stac_fastapi.extensions.core.aggregation.client.AsyncBaseAggregationClient.get_aggregations","title":"get_aggregations  <code>async</code>","text":"<pre><code>get_aggregations(collection_id: Optional[str] = None, **kwargs) -&gt; AggregationCollection\n</code></pre> <p>Get the aggregations available for the given collection_id.</p> <p>If collection_id is None, returns the available aggregations over all collections.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/client.py</code> <pre><code>async def get_aggregations(\n    self, collection_id: Optional[str] = None, **kwargs\n) -&gt; AggregationCollection:\n    \"\"\"Get the aggregations available for the given collection_id.\n\n    If collection_id is None, returns the available aggregations over all\n    collections.\n    \"\"\"\n    return AggregationCollection(\n        type=\"AggregationCollection\",\n        aggregations=[Aggregation(name=\"total_count\", data_type=\"integer\")],\n        links=[\n            {\n                \"rel\": \"root\",\n                \"type\": \"application/json\",\n                \"href\": \"https://example.org/\",\n            },\n            {\n                \"rel\": \"self\",\n                \"type\": \"application/json\",\n                \"href\": \"https://example.org/aggregations\",\n            },\n        ],\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/client/#stac_fastapi.extensions.core.aggregation.client.BaseAggregationClient","title":"BaseAggregationClient","text":"<p>               Bases: <code>ABC</code></p> <p>Defines a pattern for implementing the STAC aggregation extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/client.py</code> <pre><code>@attr.s\nclass BaseAggregationClient(abc.ABC):\n    \"\"\"Defines a pattern for implementing the STAC aggregation extension.\"\"\"\n\n    # BUCKET = Bucket\n    # AGGREGAION = Aggregation\n    # AGGREGATION_COLLECTION = AggregationCollection\n\n    def get_aggregations(\n        self, collection_id: Optional[str] = None, **kwargs\n    ) -&gt; AggregationCollection:\n        \"\"\"Get the aggregations available for the given collection_id.\n\n        If collection_id is None, returns the available aggregations over all\n        collections.\n        \"\"\"\n        return AggregationCollection(\n            type=\"AggregationCollection\",\n            aggregations=[Aggregation(name=\"total_count\", data_type=\"integer\")],\n            links=[\n                {\n                    \"rel\": \"root\",\n                    \"type\": \"application/json\",\n                    \"href\": \"https://example.org/\",\n                },\n                {\n                    \"rel\": \"self\",\n                    \"type\": \"application/json\",\n                    \"href\": \"https://example.org/aggregations\",\n                },\n            ],\n        )\n\n    def aggregate(\n        self, collection_id: Optional[str] = None, **kwargs\n    ) -&gt; AggregationCollection:\n        \"\"\"Return the aggregation buckets for a given search result\"\"\"\n        return AggregationCollection(\n            type=\"AggregationCollection\",\n            aggregations=[],\n            links=[\n                {\n                    \"rel\": \"root\",\n                    \"type\": \"application/json\",\n                    \"href\": \"https://example.org/\",\n                },\n                {\n                    \"rel\": \"self\",\n                    \"type\": \"application/json\",\n                    \"href\": \"https://example.org/aggregations\",\n                },\n            ],\n        )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/client/#stac_fastapi.extensions.core.aggregation.client.BaseAggregationClient.aggregate","title":"aggregate","text":"<pre><code>aggregate(collection_id: Optional[str] = None, **kwargs) -&gt; AggregationCollection\n</code></pre> <p>Return the aggregation buckets for a given search result</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/client.py</code> <pre><code>def aggregate(\n    self, collection_id: Optional[str] = None, **kwargs\n) -&gt; AggregationCollection:\n    \"\"\"Return the aggregation buckets for a given search result\"\"\"\n    return AggregationCollection(\n        type=\"AggregationCollection\",\n        aggregations=[],\n        links=[\n            {\n                \"rel\": \"root\",\n                \"type\": \"application/json\",\n                \"href\": \"https://example.org/\",\n            },\n            {\n                \"rel\": \"self\",\n                \"type\": \"application/json\",\n                \"href\": \"https://example.org/aggregations\",\n            },\n        ],\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/client/#stac_fastapi.extensions.core.aggregation.client.BaseAggregationClient.get_aggregations","title":"get_aggregations","text":"<pre><code>get_aggregations(collection_id: Optional[str] = None, **kwargs) -&gt; AggregationCollection\n</code></pre> <p>Get the aggregations available for the given collection_id.</p> <p>If collection_id is None, returns the available aggregations over all collections.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/client.py</code> <pre><code>def get_aggregations(\n    self, collection_id: Optional[str] = None, **kwargs\n) -&gt; AggregationCollection:\n    \"\"\"Get the aggregations available for the given collection_id.\n\n    If collection_id is None, returns the available aggregations over all\n    collections.\n    \"\"\"\n    return AggregationCollection(\n        type=\"AggregationCollection\",\n        aggregations=[Aggregation(name=\"total_count\", data_type=\"integer\")],\n        links=[\n            {\n                \"rel\": \"root\",\n                \"type\": \"application/json\",\n                \"href\": \"https://example.org/\",\n            },\n            {\n                \"rel\": \"self\",\n                \"type\": \"application/json\",\n                \"href\": \"https://example.org/aggregations\",\n            },\n        ],\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/request/","title":"request","text":""},{"location":"api/stac_fastapi/extensions/core/aggregation/request/#stac_fastapi.extensions.core.aggregation.request","title":"stac_fastapi.extensions.core.aggregation.request","text":"<p>Request model for the Aggregation extension.</p>"},{"location":"api/stac_fastapi/extensions/core/aggregation/request/#stac_fastapi.extensions.core.aggregation.request.AggregationExtensionGetRequest","title":"AggregationExtensionGetRequest","text":"<p>               Bases: <code>BaseSearchGetRequest</code></p> <p>Aggregation Extension GET request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/request.py</code> <pre><code>@attr.s\nclass AggregationExtensionGetRequest(BaseSearchGetRequest):\n    \"\"\"Aggregation Extension GET request model.\"\"\"\n\n    aggregations: Optional[List[str]] = attr.ib(default=None, converter=_agg_converter)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/request/#stac_fastapi.extensions.core.aggregation.request.AggregationExtensionPostRequest","title":"AggregationExtensionPostRequest","text":"<p>               Bases: <code>BaseSearchPostRequest</code></p> <p>Aggregation Extension POST request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/request.py</code> <pre><code>class AggregationExtensionPostRequest(BaseSearchPostRequest):\n    \"\"\"Aggregation Extension POST request model.\"\"\"\n\n    aggregations: Optional[List[str]] = Field(\n        default=None,\n        description=\"A list of aggregations to compute and return.\",\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/types/","title":"types","text":""},{"location":"api/stac_fastapi/extensions/core/aggregation/types/#stac_fastapi.extensions.core.aggregation.types","title":"stac_fastapi.extensions.core.aggregation.types","text":"<p>Aggregation Extension types.</p>"},{"location":"api/stac_fastapi/extensions/core/aggregation/types/#stac_fastapi.extensions.core.aggregation.types.Aggregation","title":"Aggregation","text":"<p>               Bases: <code>TypedDict</code></p> <p>A STAC aggregation.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/types.py</code> <pre><code>class Aggregation(TypedDict):\n    \"\"\"A STAC aggregation.\"\"\"\n\n    name: str\n    data_type: str\n    buckets: NotRequired[List[Bucket]]\n    overflow: NotRequired[int]\n    value: NotRequired[Union[str, int, DateTimeType]]\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/aggregation/types/#stac_fastapi.extensions.core.aggregation.types.AggregationCollection","title":"AggregationCollection","text":"<p>               Bases: <code>TypedDict</code></p> <p>STAC Item Aggregation Collection.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/aggregation/types.py</code> <pre><code>class AggregationCollection(TypedDict):\n    \"\"\"STAC Item Aggregation Collection.\"\"\"\n\n    type: Literal[\"AggregationCollection\"]\n    aggregations: List[Aggregation]\n    links: List[Dict[str, Any]]\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/","title":"Module stac_fastapi.extensions.core.collection_search","text":"<p>Collection-Search Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/collection_search/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.collection_search.collection_search</li> <li>stac_fastapi.extensions.core.collection_search.client</li> <li>stac_fastapi.extensions.core.collection_search.request</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/collection_search/client/","title":"client","text":""},{"location":"api/stac_fastapi/extensions/core/collection_search/client/#stac_fastapi.extensions.core.collection_search.client","title":"stac_fastapi.extensions.core.collection_search.client","text":"<p>collection-search extensions clients.</p>"},{"location":"api/stac_fastapi/extensions/core/collection_search/client/#stac_fastapi.extensions.core.collection_search.client.AsyncBaseCollectionSearchClient","title":"AsyncBaseCollectionSearchClient","text":"<p>               Bases: <code>ABC</code></p> <p>Defines a pattern for implementing the STAC collection-search POST extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/client.py</code> <pre><code>@attr.s\nclass AsyncBaseCollectionSearchClient(abc.ABC):\n    \"\"\"Defines a pattern for implementing the STAC collection-search POST extension.\"\"\"\n\n    @abc.abstractmethod\n    async def post_all_collections(\n        self,\n        search_request: BaseCollectionSearchPostRequest,\n        **kwargs,\n    ) -&gt; ItemCollection:\n        \"\"\"Get all available collections.\n\n        Called with `POST /collections`.\n\n        Returns:\n            A list of collections.\n\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/client/#stac_fastapi.extensions.core.collection_search.client.AsyncBaseCollectionSearchClient.post_all_collections","title":"post_all_collections  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>post_all_collections(search_request: BaseCollectionSearchPostRequest, **kwargs) -&gt; ItemCollection\n</code></pre> <p>Get all available collections.</p> <p>Called with <code>POST /collections</code>.</p> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>A list of collections.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/client.py</code> <pre><code>@abc.abstractmethod\nasync def post_all_collections(\n    self,\n    search_request: BaseCollectionSearchPostRequest,\n    **kwargs,\n) -&gt; ItemCollection:\n    \"\"\"Get all available collections.\n\n    Called with `POST /collections`.\n\n    Returns:\n        A list of collections.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/client/#stac_fastapi.extensions.core.collection_search.client.BaseCollectionSearchClient","title":"BaseCollectionSearchClient","text":"<p>               Bases: <code>ABC</code></p> <p>Defines a pattern for implementing the STAC collection-search POST extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/client.py</code> <pre><code>@attr.s\nclass BaseCollectionSearchClient(abc.ABC):\n    \"\"\"Defines a pattern for implementing the STAC collection-search POST extension.\"\"\"\n\n    @abc.abstractmethod\n    def post_all_collections(\n        self, search_request: BaseCollectionSearchPostRequest, **kwargs\n    ) -&gt; ItemCollection:\n        \"\"\"Get all available collections.\n\n        Called with `POST /collections`.\n\n        Returns:\n            A list of collections.\n\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/client/#stac_fastapi.extensions.core.collection_search.client.BaseCollectionSearchClient.post_all_collections","title":"post_all_collections  <code>abstractmethod</code>","text":"<pre><code>post_all_collections(search_request: BaseCollectionSearchPostRequest, **kwargs) -&gt; ItemCollection\n</code></pre> <p>Get all available collections.</p> <p>Called with <code>POST /collections</code>.</p> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>A list of collections.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/client.py</code> <pre><code>@abc.abstractmethod\ndef post_all_collections(\n    self, search_request: BaseCollectionSearchPostRequest, **kwargs\n) -&gt; ItemCollection:\n    \"\"\"Get all available collections.\n\n    Called with `POST /collections`.\n\n    Returns:\n        A list of collections.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/","title":"collection_search","text":""},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/#stac_fastapi.extensions.core.collection_search.collection_search","title":"stac_fastapi.extensions.core.collection_search.collection_search","text":"<p>Collection-Search extension.</p>"},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/#stac_fastapi.extensions.core.collection_search.collection_search.CollectionSearchConformanceClasses","title":"CollectionSearchConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the Collection-Search extension.</p> <p>See stac-api-extensions/collection-search</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/collection_search.py</code> <pre><code>class CollectionSearchConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the Collection-Search extension.\n\n    See\n    https://github.com/stac-api-extensions/collection-search\n    \"\"\"\n\n    COLLECTIONSEARCH = \"https://api.stacspec.org/v1.0.0-rc.1/collection-search\"\n    BASIS = \"http://www.opengis.net/spec/ogcapi-common-2/1.0/conf/simple-query\"\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/#stac_fastapi.extensions.core.collection_search.collection_search.CollectionSearchExtension","title":"CollectionSearchExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Collection-Search Extension.</p> <p>The Collection-Search extension adds functionality to the <code>GET - /collections</code> endpoint which allows the caller to include or exclude specific from the API response. Registering this extension with the application has the added effect of removing the <code>ItemCollection</code> response model from the <code>/search</code> endpoint, as the Fields extension allows the API to return potentially invalid responses by excluding fields which are required by the STAC spec, such as geometry.</p> <p>stac-api-extensions/collection-search</p> <p>Attributes:</p> <ul> <li> <code>conformance_classes</code>               (<code>list</code>)           \u2013            <p>Defines the list of conformance classes for the extension</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/collection_search.py</code> <pre><code>@attr.s\nclass CollectionSearchExtension(ApiExtension):\n    \"\"\"Collection-Search Extension.\n\n    The Collection-Search extension adds functionality to the `GET - /collections`\n    endpoint which allows the caller to include or exclude specific from the API\n    response.\n    Registering this extension with the application has the added effect of\n    removing the `ItemCollection` response model from the `/search` endpoint, as\n    the Fields extension allows the API to return potentially invalid responses\n    by excluding fields which are required by the STAC spec, such as geometry.\n\n    https://github.com/stac-api-extensions/collection-search\n\n    Attributes:\n        conformance_classes (list): Defines the list of conformance classes for\n            the extension\n    \"\"\"\n\n    GET: Type[APIRequest] = attr.ib(default=BaseCollectionSearchGetRequest)\n    POST: Optional[Type[BaseModel]] = attr.ib(init=False)\n\n    conformance_classes: List[str] = attr.ib(\n        default=[\n            CollectionSearchConformanceClasses.COLLECTIONSEARCH.value,\n            CollectionSearchConformanceClasses.BASIS.value,\n        ]\n    )\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app (fastapi.FastAPI): target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    @classmethod\n    def from_extensions(\n        cls,\n        extensions: List[ApiExtension],\n        *,\n        schema_href: Optional[str] = None,\n    ) -&gt; \"CollectionSearchExtension\":\n        \"\"\"Create CollectionSearchExtension object from extensions.\"\"\"\n\n        conformance_classes = [\n            CollectionSearchConformanceClasses.COLLECTIONSEARCH.value,\n            CollectionSearchConformanceClasses.BASIS.value,\n        ]\n        for ext in extensions:\n            conformance_classes.extend(ext.conformance_classes)\n\n        get_request_model = cast(\n            Type[APIRequest],\n            create_request_model(\n                model_name=\"CollectionsGetRequest\",\n                base_model=BaseCollectionSearchGetRequest,\n                extensions=extensions,\n                request_type=\"GET\",\n            ),\n        )\n\n        return cls(\n            GET=get_request_model,  # type: ignore\n            conformance_classes=conformance_classes,\n            schema_href=schema_href,\n        )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/#stac_fastapi.extensions.core.collection_search.collection_search.CollectionSearchExtension.from_extensions","title":"from_extensions  <code>classmethod</code>","text":"<pre><code>from_extensions(\n    extensions: List[ApiExtension], *, schema_href: Optional[str] = None\n) -&gt; CollectionSearchExtension\n</code></pre> <p>Create CollectionSearchExtension object from extensions.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/collection_search.py</code> <pre><code>@classmethod\ndef from_extensions(\n    cls,\n    extensions: List[ApiExtension],\n    *,\n    schema_href: Optional[str] = None,\n) -&gt; \"CollectionSearchExtension\":\n    \"\"\"Create CollectionSearchExtension object from extensions.\"\"\"\n\n    conformance_classes = [\n        CollectionSearchConformanceClasses.COLLECTIONSEARCH.value,\n        CollectionSearchConformanceClasses.BASIS.value,\n    ]\n    for ext in extensions:\n        conformance_classes.extend(ext.conformance_classes)\n\n    get_request_model = cast(\n        Type[APIRequest],\n        create_request_model(\n            model_name=\"CollectionsGetRequest\",\n            base_model=BaseCollectionSearchGetRequest,\n            extensions=extensions,\n            request_type=\"GET\",\n        ),\n    )\n\n    return cls(\n        GET=get_request_model,  # type: ignore\n        conformance_classes=conformance_classes,\n        schema_href=schema_href,\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/#stac_fastapi.extensions.core.collection_search.collection_search.CollectionSearchExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/collection_search.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app (fastapi.FastAPI): target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/#stac_fastapi.extensions.core.collection_search.collection_search.CollectionSearchPostExtension","title":"CollectionSearchPostExtension","text":"<p>               Bases: <code>CollectionSearchExtension</code></p> <p>Collection-Search Extension.</p> <p>Extents the collection-search extension with an additional POST - /collections endpoint</p> <p>NOTE: the POST - /collections endpoint can be conflicting with the POST /collections endpoint registered for the Transaction extension.</p> <p>stac-api-extensions/collection-search</p> <p>Attributes:</p> <ul> <li> <code>conformance_classes</code>               (<code>list</code>)           \u2013            <p>Defines the list of conformance classes for the extension</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/collection_search.py</code> <pre><code>@attr.s\nclass CollectionSearchPostExtension(CollectionSearchExtension):\n    \"\"\"Collection-Search Extension.\n\n    Extents the collection-search extension with an additional\n    POST - /collections endpoint\n\n    NOTE: the POST - /collections endpoint can be conflicting with the\n    POST /collections endpoint registered for the Transaction extension.\n\n    https://github.com/stac-api-extensions/collection-search\n\n    Attributes:\n        conformance_classes (list): Defines the list of conformance classes for\n            the extension\n    \"\"\"\n\n    client: Union[AsyncBaseCollectionSearchClient, BaseCollectionSearchClient] = attr.ib()\n    settings: ApiSettings = attr.ib()\n    conformance_classes: List[str] = attr.ib(\n        default=[\n            CollectionSearchConformanceClasses.COLLECTIONSEARCH.value,\n            CollectionSearchConformanceClasses.BASIS.value,\n        ]\n    )\n    schema_href: Optional[str] = attr.ib(default=None)\n    router: APIRouter = attr.ib(factory=APIRouter)\n\n    GET: Type[APIRequest] = attr.ib(default=BaseCollectionSearchGetRequest)\n    POST: Type[BaseModel] = attr.ib(default=BaseCollectionSearchPostRequest)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        self.router.prefix = app.state.router_prefix\n\n        self.router.add_api_route(\n            name=\"Collections\",\n            path=\"/collections\",\n            methods=[\"POST\"],\n            response_model=(\n                Collections if self.settings.enable_response_models else None\n            ),\n            responses={\n                200: {\n                    \"content\": {\n                        MimeTypes.json.value: {},\n                    },\n                    \"model\": Collections,\n                },\n            },\n            response_class=GeoJSONResponse,\n            endpoint=create_async_endpoint(self.client.post_all_collections, self.POST),\n        )\n        app.include_router(self.router)\n\n    @classmethod\n    def from_extensions(  # type: ignore [override]\n        cls,\n        extensions: List[ApiExtension],\n        *,\n        schema_href: Optional[str] = None,\n        client: Union[AsyncBaseCollectionSearchClient, BaseCollectionSearchClient],\n        settings: ApiSettings,\n        router: Optional[APIRouter] = None,\n    ) -&gt; \"CollectionSearchPostExtension\":\n        \"\"\"Create CollectionSearchPostExtension object from extensions.\"\"\"\n        conformance_classes = [\n            CollectionSearchConformanceClasses.COLLECTIONSEARCH.value,\n            CollectionSearchConformanceClasses.BASIS.value,\n        ]\n        for ext in extensions:\n            conformance_classes.extend(ext.conformance_classes)\n\n        get_request_model = cast(\n            Type[APIRequest],\n            create_request_model(\n                model_name=\"CollectionsGetRequest\",\n                base_model=BaseCollectionSearchGetRequest,\n                extensions=extensions,\n                request_type=\"GET\",\n            ),\n        )\n\n        post_request_model = cast(\n            Type[BaseModel],\n            create_request_model(\n                model_name=\"CollectionsPostRequest\",\n                base_model=BaseCollectionSearchPostRequest,\n                extensions=extensions,\n                request_type=\"POST\",\n            ),\n        )\n\n        return cls(\n            client=client,\n            settings=settings,\n            GET=get_request_model,  # type: ignore\n            POST=post_request_model,  # type: ignore\n            conformance_classes=conformance_classes,\n            router=router or APIRouter(),\n            schema_href=schema_href,\n        )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/#stac_fastapi.extensions.core.collection_search.collection_search.CollectionSearchPostExtension.from_extensions","title":"from_extensions  <code>classmethod</code>","text":"<pre><code>from_extensions(\n    extensions: List[ApiExtension],\n    *,\n    schema_href: Optional[str] = None,\n    client: Union[AsyncBaseCollectionSearchClient, BaseCollectionSearchClient],\n    settings: ApiSettings,\n    router: Optional[APIRouter] = None\n) -&gt; CollectionSearchPostExtension\n</code></pre> <p>Create CollectionSearchPostExtension object from extensions.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/collection_search.py</code> <pre><code>@classmethod\ndef from_extensions(  # type: ignore [override]\n    cls,\n    extensions: List[ApiExtension],\n    *,\n    schema_href: Optional[str] = None,\n    client: Union[AsyncBaseCollectionSearchClient, BaseCollectionSearchClient],\n    settings: ApiSettings,\n    router: Optional[APIRouter] = None,\n) -&gt; \"CollectionSearchPostExtension\":\n    \"\"\"Create CollectionSearchPostExtension object from extensions.\"\"\"\n    conformance_classes = [\n        CollectionSearchConformanceClasses.COLLECTIONSEARCH.value,\n        CollectionSearchConformanceClasses.BASIS.value,\n    ]\n    for ext in extensions:\n        conformance_classes.extend(ext.conformance_classes)\n\n    get_request_model = cast(\n        Type[APIRequest],\n        create_request_model(\n            model_name=\"CollectionsGetRequest\",\n            base_model=BaseCollectionSearchGetRequest,\n            extensions=extensions,\n            request_type=\"GET\",\n        ),\n    )\n\n    post_request_model = cast(\n        Type[BaseModel],\n        create_request_model(\n            model_name=\"CollectionsPostRequest\",\n            base_model=BaseCollectionSearchPostRequest,\n            extensions=extensions,\n            request_type=\"POST\",\n        ),\n    )\n\n    return cls(\n        client=client,\n        settings=settings,\n        GET=get_request_model,  # type: ignore\n        POST=post_request_model,  # type: ignore\n        conformance_classes=conformance_classes,\n        router=router or APIRouter(),\n        schema_href=schema_href,\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/collection_search/#stac_fastapi.extensions.core.collection_search.collection_search.CollectionSearchPostExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/collection_search.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    self.router.prefix = app.state.router_prefix\n\n    self.router.add_api_route(\n        name=\"Collections\",\n        path=\"/collections\",\n        methods=[\"POST\"],\n        response_model=(\n            Collections if self.settings.enable_response_models else None\n        ),\n        responses={\n            200: {\n                \"content\": {\n                    MimeTypes.json.value: {},\n                },\n                \"model\": Collections,\n            },\n        },\n        response_class=GeoJSONResponse,\n        endpoint=create_async_endpoint(self.client.post_all_collections, self.POST),\n    )\n    app.include_router(self.router)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/request/","title":"request","text":""},{"location":"api/stac_fastapi/extensions/core/collection_search/request/#stac_fastapi.extensions.core.collection_search.request","title":"stac_fastapi.extensions.core.collection_search.request","text":"<p>Request models for the Collection-Search extension.</p>"},{"location":"api/stac_fastapi/extensions/core/collection_search/request/#stac_fastapi.extensions.core.collection_search.request.BaseCollectionSearchGetRequest","title":"BaseCollectionSearchGetRequest","text":"<p>               Bases: <code>APIRequest</code>, <code>DatetimeMixin</code></p> <p>Basics additional Collection-Search parameters for the GET request.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/request.py</code> <pre><code>@attr.s\nclass BaseCollectionSearchGetRequest(APIRequest, DatetimeMixin):\n    \"\"\"Basics additional Collection-Search parameters for the GET request.\"\"\"\n\n    bbox: Optional[BBox] = attr.ib(default=None, converter=_bbox_converter)  # type: ignore\n    datetime: DateTimeQueryType = attr.ib(default=None, validator=_validate_datetime)\n    limit: Annotated[\n        Optional[Limit],\n        Query(\n            description=\"Limits the number of results that are included in each page of the response.\"  # noqa: E501\n        ),\n    ] = attr.ib(default=10)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/request/#stac_fastapi.extensions.core.collection_search.request.BaseCollectionSearchPostRequest","title":"BaseCollectionSearchPostRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collection-Search POST model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/request.py</code> <pre><code>class BaseCollectionSearchPostRequest(BaseModel):\n    \"\"\"Collection-Search POST model.\"\"\"\n\n    bbox: Optional[BBox] = Field(\n        default=None,\n        description=\"Only return items intersecting this bounding box. Mutually exclusive with **intersects**.\",  # noqa: E501\n        json_schema_extra={\n            \"examples\": [\n                # user-provided\n                None,\n                # Montreal\n                \"-73.896103,45.364690,-73.413734,45.674283\",\n            ],\n        },\n    )\n    datetime: Optional[str] = Field(\n        default=None,\n        description=\"\"\"Only return items that have a temporal property that intersects this value.\\n\nEither a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.\"\"\",  # noqa: E501\n        json_schema_extra={\n            \"examples\": [\n                # user-provided\n                None,\n                # single datetime\n                \"2018-02-12T23:20:50Z\",\n                # closed inverval\n                \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\",\n                # open interval FROM\n                \"2018-02-12T00:00:00Z/..\",\n                # open interval TO\n                \"../2018-03-18T12:31:12Z\",\n            ],\n        },\n    )\n    limit: Optional[Limit] = Field(\n        10,\n        description=\"Limits the number of results that are included in each page of the response (capped to 10_000).\",  # noqa: E501\n    )\n\n    # Private properties to store the parsed datetime values.\n    # Not part of the model schema.\n    _start_date: Optional[dt] = PrivateAttr(default=None)\n    _end_date: Optional[dt] = PrivateAttr(default=None)\n\n    # Properties to return the private values\n    @property\n    def start_date(self) -&gt; Optional[dt]:\n        \"\"\"start date.\"\"\"\n        return self._start_date\n\n    @property\n    def end_date(self) -&gt; Optional[dt]:\n        \"\"\"end date.\"\"\"\n        return self._end_date\n\n    @field_validator(\"bbox\")\n    @classmethod\n    def validate_bbox(cls, v: BBox) -&gt; BBox:\n        \"\"\"validate bbox.\"\"\"\n        if v:\n            # Validate order\n            if len(v) == 4:\n                xmin, ymin, xmax, ymax = cast(Tuple[int, int, int, int], v)\n            else:\n                xmin, ymin, min_elev, xmax, ymax, max_elev = cast(\n                    Tuple[int, int, int, int, int, int], v\n                )\n                if max_elev &lt; min_elev:\n                    raise ValueError(\n                        \"Maximum elevation must greater than minimum elevation\"\n                    )\n            # Validate against WGS84\n            if xmin &lt; -180 or ymin &lt; -90 or xmax &gt; 180 or ymax &gt; 90:\n                raise ValueError(\"Bounding box must be within (-180, -90, 180, 90)\")\n\n            if ymax &lt; ymin:\n                raise ValueError(\n                    \"Maximum longitude must be greater than minimum longitude\"\n                )\n\n        return v\n\n    @field_validator(\"datetime\", mode=\"after\")\n    @classmethod\n    def validate_datetime(\n        cls, value: Optional[str], info: ValidationInfo\n    ) -&gt; Optional[str]:\n        \"\"\"validate datetime.\"\"\"\n        # Split on \"/\" and replace no value or \"..\" with None\n        if value is None:\n            return value\n        values = [v if v and v != \"..\" else None for v in value.split(\"/\")]\n\n        # If there are more than 2 dates, it's invalid\n        if len(values) &gt; 2:\n            raise ValueError(\n                \"\"\"Invalid datetime range. Too many values. \"\"\"\n                \"\"\"Must match format: {begin_date}/{end_date}\"\"\"\n            )\n\n        # If there is only one date, duplicate to use for both start and end dates\n        if len(values) == 1:\n            values = [values[0], values[0]]\n\n        # Cast because pylance gets confused by the type adapter and annotated type\n        dates = cast(\n            List[Optional[dt]],\n            [\n                # Use the type adapter to validate the datetime strings,\n                # strict is necessary due to pydantic issues #8736 and #8762\n                SearchDatetime.validate_strings(v, strict=True) if v else None\n                for v in values\n            ],\n        )\n\n        # If there is a start and end date,\n        # check that the start date is before the end date\n        if dates[0] and dates[1] and dates[0] &gt; dates[1]:\n            raise ValueError(\n                \"Invalid datetime range. Begin date after end date. \"\n                \"Must match format: {begin_date}/{end_date}\"\n            )\n\n        # Store the parsed dates\n        info.data[\"_start_date\"] = dates[0]\n        info.data[\"_end_date\"] = dates[1]\n\n        # Return the original string value\n        return value\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/request/#stac_fastapi.extensions.core.collection_search.request.BaseCollectionSearchPostRequest.end_date","title":"end_date  <code>property</code>","text":"<pre><code>end_date: Optional[datetime]\n</code></pre> <p>end date.</p>"},{"location":"api/stac_fastapi/extensions/core/collection_search/request/#stac_fastapi.extensions.core.collection_search.request.BaseCollectionSearchPostRequest.start_date","title":"start_date  <code>property</code>","text":"<pre><code>start_date: Optional[datetime]\n</code></pre> <p>start date.</p>"},{"location":"api/stac_fastapi/extensions/core/collection_search/request/#stac_fastapi.extensions.core.collection_search.request.BaseCollectionSearchPostRequest.validate_bbox","title":"validate_bbox  <code>classmethod</code>","text":"<pre><code>validate_bbox(v: BBox) -&gt; BBox\n</code></pre> <p>validate bbox.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/request.py</code> <pre><code>@field_validator(\"bbox\")\n@classmethod\ndef validate_bbox(cls, v: BBox) -&gt; BBox:\n    \"\"\"validate bbox.\"\"\"\n    if v:\n        # Validate order\n        if len(v) == 4:\n            xmin, ymin, xmax, ymax = cast(Tuple[int, int, int, int], v)\n        else:\n            xmin, ymin, min_elev, xmax, ymax, max_elev = cast(\n                Tuple[int, int, int, int, int, int], v\n            )\n            if max_elev &lt; min_elev:\n                raise ValueError(\n                    \"Maximum elevation must greater than minimum elevation\"\n                )\n        # Validate against WGS84\n        if xmin &lt; -180 or ymin &lt; -90 or xmax &gt; 180 or ymax &gt; 90:\n            raise ValueError(\"Bounding box must be within (-180, -90, 180, 90)\")\n\n        if ymax &lt; ymin:\n            raise ValueError(\n                \"Maximum longitude must be greater than minimum longitude\"\n            )\n\n    return v\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/collection_search/request/#stac_fastapi.extensions.core.collection_search.request.BaseCollectionSearchPostRequest.validate_datetime","title":"validate_datetime  <code>classmethod</code>","text":"<pre><code>validate_datetime(value: Optional[str], info: ValidationInfo) -&gt; Optional[str]\n</code></pre> <p>validate datetime.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/collection_search/request.py</code> <pre><code>@field_validator(\"datetime\", mode=\"after\")\n@classmethod\ndef validate_datetime(\n    cls, value: Optional[str], info: ValidationInfo\n) -&gt; Optional[str]:\n    \"\"\"validate datetime.\"\"\"\n    # Split on \"/\" and replace no value or \"..\" with None\n    if value is None:\n        return value\n    values = [v if v and v != \"..\" else None for v in value.split(\"/\")]\n\n    # If there are more than 2 dates, it's invalid\n    if len(values) &gt; 2:\n        raise ValueError(\n            \"\"\"Invalid datetime range. Too many values. \"\"\"\n            \"\"\"Must match format: {begin_date}/{end_date}\"\"\"\n        )\n\n    # If there is only one date, duplicate to use for both start and end dates\n    if len(values) == 1:\n        values = [values[0], values[0]]\n\n    # Cast because pylance gets confused by the type adapter and annotated type\n    dates = cast(\n        List[Optional[dt]],\n        [\n            # Use the type adapter to validate the datetime strings,\n            # strict is necessary due to pydantic issues #8736 and #8762\n            SearchDatetime.validate_strings(v, strict=True) if v else None\n            for v in values\n        ],\n    )\n\n    # If there is a start and end date,\n    # check that the start date is before the end date\n    if dates[0] and dates[1] and dates[0] &gt; dates[1]:\n        raise ValueError(\n            \"Invalid datetime range. Begin date after end date. \"\n            \"Must match format: {begin_date}/{end_date}\"\n        )\n\n    # Store the parsed dates\n    info.data[\"_start_date\"] = dates[0]\n    info.data[\"_end_date\"] = dates[1]\n\n    # Return the original string value\n    return value\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/fields/","title":"Module stac_fastapi.extensions.core.fields","text":"<p>Fields Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/fields/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.fields.fields</li> <li>stac_fastapi.extensions.core.fields.request</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/fields/fields/","title":"fields","text":""},{"location":"api/stac_fastapi/extensions/core/fields/fields/#stac_fastapi.extensions.core.fields.fields","title":"stac_fastapi.extensions.core.fields.fields","text":"<p>Fields extension.</p>"},{"location":"api/stac_fastapi/extensions/core/fields/fields/#stac_fastapi.extensions.core.fields.fields.FieldsConformanceClasses","title":"FieldsConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the Fields extension.</p> <p>See stac-api-extensions/fields</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/fields/fields.py</code> <pre><code>class FieldsConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the Fields extension.\n\n    See https://github.com/stac-api-extensions/fields\n\n    \"\"\"\n\n    SEARCH = \"https://api.stacspec.org/v1.0.0/item-search#fields\"\n    ITEMS = \"https://api.stacspec.org/v1.0.0/ogcapi-features#fields\"\n    COLLECTIONS = \"https://api.stacspec.org/v1.0.0-rc.1/collection-search#fields\"\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/fields/fields/#stac_fastapi.extensions.core.fields.fields.FieldsExtension","title":"FieldsExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Fields Extension.</p> <p>The Fields extension adds functionality to the <code>/search</code> endpoint which allows the caller to include or exclude specific from the API response. Registering this extension with the application has the added effect of removing the <code>ItemCollection</code> response model from the <code>/search</code> endpoint, as the Fields extension allows the API to return potentially invalid responses by excluding fields which are required by the STAC spec, such as geometry.</p> <p>stac-api-extensions/fields</p> <p>Attributes:</p> <ul> <li> <code>default_includes</code>               (<code>set</code>)           \u2013            <p>defines the default set of included fields.</p> </li> <li> <code>conformance_classes</code>               (<code>list</code>)           \u2013            <p>Defines the list of conformance classes for the extension</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/fields/fields.py</code> <pre><code>@attr.s\nclass FieldsExtension(ApiExtension):\n    \"\"\"Fields Extension.\n\n    The Fields extension adds functionality to the `/search` endpoint which\n    allows the caller to include or exclude specific from the API response.\n    Registering this extension with the application has the added effect of\n    removing the `ItemCollection` response model from the `/search` endpoint, as\n    the Fields extension allows the API to return potentially invalid responses\n    by excluding fields which are required by the STAC spec, such as geometry.\n\n    https://github.com/stac-api-extensions/fields\n\n    Attributes:\n        default_includes (set): defines the default set of included fields.\n        conformance_classes (list): Defines the list of conformance classes for\n            the extension\n    \"\"\"\n\n    GET: Type[APIRequest] = FieldsExtensionGetRequest\n    POST: Type[BaseModel] = FieldsExtensionPostRequest\n\n    conformance_classes: List[str] = attr.ib(\n        factory=lambda: [\n            FieldsConformanceClasses.SEARCH,\n        ]\n    )\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app (fastapi.FastAPI): target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/fields/fields/#stac_fastapi.extensions.core.fields.fields.FieldsExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/fields/fields.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app (fastapi.FastAPI): target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/fields/request/","title":"request","text":""},{"location":"api/stac_fastapi/extensions/core/fields/request/#stac_fastapi.extensions.core.fields.request","title":"stac_fastapi.extensions.core.fields.request","text":"<p>Request models for the fields extension.</p>"},{"location":"api/stac_fastapi/extensions/core/fields/request/#stac_fastapi.extensions.core.fields.request.FieldsExtensionGetRequest","title":"FieldsExtensionGetRequest","text":"<p>               Bases: <code>APIRequest</code></p> <p>Additional fields for the GET request.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/fields/request.py</code> <pre><code>@attr.s\nclass FieldsExtensionGetRequest(APIRequest):\n    \"\"\"Additional fields for the GET request.\"\"\"\n\n    fields: Optional[List[str]] = attr.ib(default=None, converter=_fields_converter)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/fields/request/#stac_fastapi.extensions.core.fields.request.FieldsExtensionPostRequest","title":"FieldsExtensionPostRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Additional fields and schema for the POST request.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/fields/request.py</code> <pre><code>class FieldsExtensionPostRequest(BaseModel):\n    \"\"\"Additional fields and schema for the POST request.\"\"\"\n\n    fields: Optional[PostFieldsExtension] = Field(\n        PostFieldsExtension(),\n        description=\"Include or exclude fields from items body.\",\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/fields/request/#stac_fastapi.extensions.core.fields.request.PostFieldsExtension","title":"PostFieldsExtension","text":"<p>               Bases: <code>BaseModel</code></p> <p>FieldsExtension.</p> <p>Attributes:</p> <ul> <li> <code>include</code>               (<code>Optional[Set[str]]</code>)           \u2013            <p>set of fields to include.</p> </li> <li> <code>exclude</code>               (<code>Optional[Set[str]]</code>)           \u2013            <p>set of fields to exclude.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/fields/request.py</code> <pre><code>class PostFieldsExtension(BaseModel):\n    \"\"\"FieldsExtension.\n\n    Attributes:\n        include: set of fields to include.\n        exclude: set of fields to exclude.\n    \"\"\"\n\n    include: Optional[Set[str]] = set()\n    exclude: Optional[Set[str]] = set()\n\n    @staticmethod\n    def _get_field_dict(fields: Optional[Set[str]]) -&gt; Dict:\n        \"\"\"Pydantic include/excludes notation.\n\n        Internal method to create a dictionary for advanced include or exclude\n        of pydantic fields on model export\n        Ref: https://pydantic-docs.helpmanual.io/usage/exporting_models/#advanced-include-and-exclude\n        \"\"\"\n        field_dict = {}\n        for field in fields or []:\n            if \".\" in field:\n                parent, key = field.split(\".\")\n                if parent not in field_dict:\n                    field_dict[parent] = {key}\n                else:\n                    if field_dict[parent] is not ...:\n                        field_dict[parent].add(key)\n            else:\n                field_dict[field] = ...  # type:ignore\n\n        return field_dict\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/","title":"Module stac_fastapi.extensions.core.filter","text":"<p>Filter Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/filter/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.filter.filter</li> <li>stac_fastapi.extensions.core.filter.request</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/","title":"filter","text":""},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter","title":"stac_fastapi.extensions.core.filter.filter","text":"<p>Filter Extension.</p>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.CollectionSearchFilterExtension","title":"CollectionSearchFilterExtension","text":"<p>               Bases: <code>FilterExtension</code></p> <p>Collection Search Filter Extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>@attr.s\nclass CollectionSearchFilterExtension(FilterExtension):\n    \"\"\"Collection Search Filter Extension.\"\"\"\n\n    conformance_classes: List[str] = attr.ib(\n        default=[\n            FilterConformanceClasses.FILTER,\n            FilterConformanceClasses.COLLECTIONS,\n            FilterConformanceClasses.BASIC_CQL2,\n            FilterConformanceClasses.CQL2_JSON,\n            FilterConformanceClasses.CQL2_TEXT,\n        ]\n    )\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.CollectionSearchFilterExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.FilterConformanceClasses","title":"FilterConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the Filter extension.</p> <p>See stac-api-extensions/filter</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>class FilterConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the Filter extension.\n\n    See\n    https://github.com/stac-api-extensions/filter\n    \"\"\"\n\n    FILTER = \"http://www.opengis.net/spec/ogcapi-features-3/1.0/conf/filter\"\n\n    SEARCH = \"https://api.stacspec.org/v1.0.0-rc.2/item-search#filter\"\n    ITEMS = \"http://www.opengis.net/spec/ogcapi-features-3/1.0/conf/features-filter\"\n    COLLECTIONS = \"https://api.stacspec.org/v1.0.0-rc.1/collection-search#filter\"\n\n    CQL2_TEXT = \"http://www.opengis.net/spec/cql2/1.0/conf/cql2-text\"\n    CQL2_JSON = \"http://www.opengis.net/spec/cql2/1.0/conf/cql2-json\"\n    BASIC_CQL2 = \"http://www.opengis.net/spec/cql2/1.0/conf/basic-cql2\"\n    BASIC_SPATIAL_FUNCTIONS = (\n        \"http://www.opengis.net/spec/cql2/1.0/conf/basic-spatial-functions\"\n    )\n    TEMPORAL_FUNCTIONS = \"http://www.opengis.net/spec/cql2/1.0/conf/temporal-functions\"\n    ADVANCED_COMPARISON_OPERATORS = (\n        \"http://www.opengis.net/spec/cql2/1.0/conf/advanced-comparison-operators\"\n    )\n    SPATIAL_FUNCTIONS = \"http://www.opengis.net/spec/cql2/1.0/conf/spatial-functions\"\n    FUNCTIONS = \"http://www.opengis.net/spec/cql2/1.0/conf/functions\"\n    ARITHMETIC = \"http://www.opengis.net/spec/cql2/1.0/conf/arithmetic\"\n    ARRAY_FUNCTIONS = \"http://www.opengis.net/spec/cql2/1.0/conf/array-functions\"\n    PROPERTY_PROPERTY = \"http://www.opengis.net/spec/cql2/1.0/conf/property-property\"\n    CASE_INSENSITIVE_COMPARISON = (\n        \"http://www.opengis.net/spec/cql2/1.0/conf/case-insensitive-comparison\"\n    )\n    ACCENT_INSENSITIVE_COMPARISON = (\n        \"http://www.opengis.net/spec/cql2/1.0/conf/accent-insensitive-comparison\"\n    )\n    BASIC_SPATIAL_FUNCTIONS_PLUS = (\n        \"http://www.opengis.net/spec/cql2/1.0/conf/basic-spatial-functions-plus\"\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.FilterExtension","title":"FilterExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Filter Extension.</p> <p>The filter extension adds several endpoints which allow the retrieval of queryables and provides an expressive mechanism for searching based on Item Attributes:     GET /queryables     GET /collections/{collection_id}/queryables</p> <p>github.com/stac-api-extensions/filter/blob/main/README.md</p> <p>Attributes:</p> <ul> <li> <code>client</code>               (<code>Union[AsyncBaseFiltersClient, BaseFiltersClient]</code>)           \u2013            <p>Queryables endpoint logic</p> </li> <li> <code>conformance_classes</code>               (<code>List[str]</code>)           \u2013            <p>Conformance classes provided by the extension</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>@attr.s\nclass FilterExtension(ApiExtension):\n    \"\"\"Filter Extension.\n\n    The filter extension adds several endpoints which allow the retrieval of\n    queryables and provides an expressive mechanism for searching based on Item\n    Attributes:\n        GET /queryables\n        GET /collections/{collection_id}/queryables\n\n    https://github.com/stac-api-extensions/filter/blob/main/README.md\n\n    Attributes:\n        client: Queryables endpoint logic\n        conformance_classes: Conformance classes provided by the extension\n    \"\"\"\n\n    GET: Type[APIRequest] = FilterExtensionGetRequest\n    POST: Type[BaseModel] = FilterExtensionPostRequest\n\n    client: Union[AsyncBaseFiltersClient, BaseFiltersClient] = attr.ib(\n        factory=BaseFiltersClient\n    )\n    conformance_classes: List[str] = attr.ib(\n        default=[\n            FilterConformanceClasses.FILTER,\n            FilterConformanceClasses.SEARCH,\n            FilterConformanceClasses.ITEMS,\n            FilterConformanceClasses.BASIC_CQL2,\n            FilterConformanceClasses.CQL2_JSON,\n            FilterConformanceClasses.CQL2_TEXT,\n        ]\n    )\n    router: APIRouter = attr.ib(factory=APIRouter)\n    response_class: Type[Response] = attr.ib(default=JSONSchemaResponse)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        self.router.prefix = app.state.router_prefix\n        self.router.add_api_route(\n            name=\"Queryables\",\n            path=\"/queryables\",\n            methods=[\"GET\"],\n            responses={\n                200: {\n                    \"content\": {\n                        \"application/schema+json\": {},\n                    },\n                    # TODO: add output model in stac-pydantic\n                },\n            },\n            response_class=self.response_class,\n            endpoint=create_async_endpoint(self.client.get_queryables, EmptyRequest),\n        )\n        self.router.add_api_route(\n            name=\"Collection Queryables\",\n            path=\"/collections/{collection_id}/queryables\",\n            methods=[\"GET\"],\n            responses={\n                200: {\n                    \"content\": {\n                        \"application/schema+json\": {},\n                    },\n                    # TODO: add output model in stac-pydantic\n                },\n            },\n            response_class=self.response_class,\n            endpoint=create_async_endpoint(self.client.get_queryables, CollectionUri),\n        )\n        app.include_router(self.router, tags=[\"Filter Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.FilterExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    self.router.prefix = app.state.router_prefix\n    self.router.add_api_route(\n        name=\"Queryables\",\n        path=\"/queryables\",\n        methods=[\"GET\"],\n        responses={\n            200: {\n                \"content\": {\n                    \"application/schema+json\": {},\n                },\n                # TODO: add output model in stac-pydantic\n            },\n        },\n        response_class=self.response_class,\n        endpoint=create_async_endpoint(self.client.get_queryables, EmptyRequest),\n    )\n    self.router.add_api_route(\n        name=\"Collection Queryables\",\n        path=\"/collections/{collection_id}/queryables\",\n        methods=[\"GET\"],\n        responses={\n            200: {\n                \"content\": {\n                    \"application/schema+json\": {},\n                },\n                # TODO: add output model in stac-pydantic\n            },\n        },\n        response_class=self.response_class,\n        endpoint=create_async_endpoint(self.client.get_queryables, CollectionUri),\n    )\n    app.include_router(self.router, tags=[\"Filter Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.ItemCollectionFilterExtension","title":"ItemCollectionFilterExtension","text":"<p>               Bases: <code>FilterExtension</code></p> <p>Item Collection Filter Extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>@attr.s\nclass ItemCollectionFilterExtension(FilterExtension):\n    \"\"\"Item Collection Filter Extension.\"\"\"\n\n    conformance_classes: List[str] = attr.ib(\n        default=[\n            FilterConformanceClasses.FILTER,\n            FilterConformanceClasses.ITEMS,\n            FilterConformanceClasses.BASIC_CQL2,\n            FilterConformanceClasses.CQL2_JSON,\n            FilterConformanceClasses.CQL2_TEXT,\n        ]\n    )\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        self.router.prefix = app.state.router_prefix\n        self.router.add_api_route(\n            name=\"Collection Queryables\",\n            path=\"/collections/{collection_id}/queryables\",\n            methods=[\"GET\"],\n            responses={\n                200: {\n                    \"content\": {\n                        \"application/schema+json\": {},\n                    },\n                    # TODO: add output model in stac-pydantic\n                },\n            },\n            response_class=self.response_class,\n            endpoint=create_async_endpoint(self.client.get_queryables, CollectionUri),\n        )\n        app.include_router(self.router, tags=[\"Filter Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.ItemCollectionFilterExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    self.router.prefix = app.state.router_prefix\n    self.router.add_api_route(\n        name=\"Collection Queryables\",\n        path=\"/collections/{collection_id}/queryables\",\n        methods=[\"GET\"],\n        responses={\n            200: {\n                \"content\": {\n                    \"application/schema+json\": {},\n                },\n                # TODO: add output model in stac-pydantic\n            },\n        },\n        response_class=self.response_class,\n        endpoint=create_async_endpoint(self.client.get_queryables, CollectionUri),\n    )\n    app.include_router(self.router, tags=[\"Filter Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.SearchFilterExtension","title":"SearchFilterExtension","text":"<p>               Bases: <code>FilterExtension</code></p> <p>Item Search Filter Extension.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>@attr.s\nclass SearchFilterExtension(FilterExtension):\n    \"\"\"Item Search Filter Extension.\"\"\"\n\n    conformance_classes: List[str] = attr.ib(\n        default=[\n            FilterConformanceClasses.FILTER,\n            FilterConformanceClasses.SEARCH,\n            FilterConformanceClasses.BASIC_CQL2,\n            FilterConformanceClasses.CQL2_JSON,\n            FilterConformanceClasses.CQL2_TEXT,\n        ]\n    )\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        self.router.prefix = app.state.router_prefix\n        self.router.add_api_route(\n            name=\"Queryables\",\n            path=\"/queryables\",\n            methods=[\"GET\"],\n            responses={\n                200: {\n                    \"content\": {\n                        \"application/schema+json\": {},\n                    },\n                    # TODO: add output model in stac-pydantic\n                },\n            },\n            response_class=self.response_class,\n            endpoint=create_async_endpoint(self.client.get_queryables, EmptyRequest),\n        )\n        app.include_router(self.router, tags=[\"Filter Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/filter/#stac_fastapi.extensions.core.filter.filter.SearchFilterExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/filter.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    self.router.prefix = app.state.router_prefix\n    self.router.add_api_route(\n        name=\"Queryables\",\n        path=\"/queryables\",\n        methods=[\"GET\"],\n        responses={\n            200: {\n                \"content\": {\n                    \"application/schema+json\": {},\n                },\n                # TODO: add output model in stac-pydantic\n            },\n        },\n        response_class=self.response_class,\n        endpoint=create_async_endpoint(self.client.get_queryables, EmptyRequest),\n    )\n    app.include_router(self.router, tags=[\"Filter Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/request/","title":"request","text":""},{"location":"api/stac_fastapi/extensions/core/filter/request/#stac_fastapi.extensions.core.filter.request","title":"stac_fastapi.extensions.core.filter.request","text":"<p>Filter extension request models.</p>"},{"location":"api/stac_fastapi/extensions/core/filter/request/#stac_fastapi.extensions.core.filter.request.FilterExtensionGetRequest","title":"FilterExtensionGetRequest","text":"<p>               Bases: <code>APIRequest</code></p> <p>Filter extension GET request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/request.py</code> <pre><code>@attr.s\nclass FilterExtensionGetRequest(APIRequest):\n    \"\"\"Filter extension GET request model.\"\"\"\n\n    filter_expr: Annotated[\n        Optional[str],\n        Query(\n            alias=\"filter\",\n            description=\"\"\"A CQL2 filter expression for filtering items.\\n\nSupports `CQL2-JSON` as defined in https://docs.ogc.org/is/21-065r2/21-065r2.htmln\nRemember to URL encode the CQL2-JSON if using GET\"\"\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"landsat8-item\": {\n                    \"value\": \"id='LC08_L1TP_060247_20180905_20180912_01_T1_L1TP' AND collection='landsat8_l1tp'\"  # noqa: E501\n                },\n            },\n        ),\n    ] = attr.ib(default=None)\n    filter_crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"filter-crs\",\n            description=\"The coordinate reference system (CRS) used by spatial literals in the 'filter' value. Default is `http://www.opengis.net/def/crs/OGC/1.3/CRS84`\",  # noqa: E501\n        ),\n    ] = attr.ib(default=None)\n    filter_lang: Annotated[\n        Optional[FilterLang],\n        Query(\n            alias=\"filter-lang\",\n            description=\"The CQL filter encoding that the 'filter' value uses.\",\n        ),\n    ] = attr.ib(default=\"cql2-text\")\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/filter/request/#stac_fastapi.extensions.core.filter.request.FilterExtensionPostRequest","title":"FilterExtensionPostRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Filter extension POST request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/filter/request.py</code> <pre><code>class FilterExtensionPostRequest(BaseModel):\n    \"\"\"Filter extension POST request model.\"\"\"\n\n    filter_expr: Optional[Dict[str, Any]] = Field(\n        None,\n        alias=\"filter\",\n        description=\"A CQL filter expression for filtering items.\",\n        json_schema_extra={\n            \"examples\": [\n                # user-provided\n                None,\n                # landsat8-item\n                {\n                    \"op\": \"and\",\n                    \"args\": [\n                        {\n                            \"op\": \"=\",\n                            \"args\": [\n                                {\"property\": \"id\"},\n                                \"LC08_L1TP_060247_20180905_20180912_01_T1_L1TP\",\n                            ],\n                        },\n                        {\n                            \"op\": \"=\",\n                            \"args\": [{\"property\": \"collection\"}, \"landsat8_l1tp\"],\n                        },\n                    ],\n                },\n            ],\n        },\n    )\n    filter_crs: Optional[str] = Field(\n        None,\n        alias=\"filter-crs\",\n        description=\"The coordinate reference system (CRS) used by spatial literals in the 'filter' value. Default is `http://www.opengis.net/def/crs/OGC/1.3/CRS84`\",  # noqa: E501\n    )\n    filter_lang: Optional[Literal[\"cql2-json\"]] = Field(\n        \"cql2-json\",\n        alias=\"filter-lang\",\n        description=\"The CQL filter encoding that the 'filter' value uses.\",\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/","title":"Module stac_fastapi.extensions.core.free_text","text":"<p>Free-Text Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/free_text/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.free_text.free_text</li> <li>stac_fastapi.extensions.core.free_text.request</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/free_text/free_text/","title":"free_text","text":""},{"location":"api/stac_fastapi/extensions/core/free_text/free_text/#stac_fastapi.extensions.core.free_text.free_text","title":"stac_fastapi.extensions.core.free_text.free_text","text":"<p>Free-text extension.</p>"},{"location":"api/stac_fastapi/extensions/core/free_text/free_text/#stac_fastapi.extensions.core.free_text.free_text.FreeTextAdvancedExtension","title":"FreeTextAdvancedExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Free-text Extension.</p> <p>The Free-text extension adds an additional <code>q</code> parameter to <code>/search</code> requests which allows the caller to perform free-text queries against STAC metadata.</p> <p>stac-api-extensions/freetext-search?tab=readme-ov-file#advanced</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/free_text.py</code> <pre><code>@attr.s\nclass FreeTextAdvancedExtension(ApiExtension):\n    \"\"\"Free-text Extension.\n\n    The Free-text extension adds an additional `q` parameter to `/search` requests which\n    allows the caller to perform free-text queries against STAC metadata.\n\n    https://github.com/stac-api-extensions/freetext-search?tab=readme-ov-file#advanced\n\n    \"\"\"\n\n    GET: Type[APIRequest] = FreeTextAdvancedExtensionGetRequest\n    POST: Type[BaseModel] = FreeTextAdvancedExtensionPostRequest\n\n    conformance_classes: List[str] = attr.ib(\n        default=[\n            FreeTextConformanceClasses.SEARCH_ADVANCED,\n        ]\n    )\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/free_text/#stac_fastapi.extensions.core.free_text.free_text.FreeTextAdvancedExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/free_text.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/free_text/#stac_fastapi.extensions.core.free_text.free_text.FreeTextConformanceClasses","title":"FreeTextConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the Free-Text extension.</p> <p>See stac-api-extensions/freetext-search</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/free_text.py</code> <pre><code>class FreeTextConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the Free-Text extension.\n\n    See https://github.com/stac-api-extensions/freetext-search\n\n    \"\"\"\n\n    # https://github.com/stac-api-extensions/freetext-search?tab=readme-ov-file#basic\n    SEARCH = \"https://api.stacspec.org/v1.0.0-rc.1/item-search#free-text\"\n    ITEMS = \"https://api.stacspec.org/v1.0.0-rc.1/ogcapi-features#free-text\"\n    COLLECTIONS = \"https://api.stacspec.org/v1.0.0-rc.1/collection-search#free-text\"\n\n    # https://github.com/stac-api-extensions/freetext-search?tab=readme-ov-file#advanced\n    SEARCH_ADVANCED = (\n        \"https://api.stacspec.org/v1.0.0-rc.1/item-search#advanced-free-text\"\n    )\n    ITEMS_ADVANCED = (\n        \"https://api.stacspec.org/v1.0.0-rc.1/ogcapi-features#advanced-free-text\"\n    )\n    COLLECTIONS_ADVANCED = (\n        \"https://api.stacspec.org/v1.0.0-rc.1/collection-search#advanced-free-text\"\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/free_text/#stac_fastapi.extensions.core.free_text.free_text.FreeTextExtension","title":"FreeTextExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Free-text Extension.</p> <p>The Free-text extension adds an additional <code>q</code> parameter to <code>/search</code> requests which allows the caller to perform free-text queries against STAC metadata.</p> <p>stac-api-extensions/freetext-search?tab=readme-ov-file#basic</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/free_text.py</code> <pre><code>@attr.s\nclass FreeTextExtension(ApiExtension):\n    \"\"\"Free-text Extension.\n\n    The Free-text extension adds an additional `q` parameter to `/search` requests which\n    allows the caller to perform free-text queries against STAC metadata.\n\n    https://github.com/stac-api-extensions/freetext-search?tab=readme-ov-file#basic\n\n    \"\"\"\n\n    GET: Type[APIRequest] = FreeTextExtensionGetRequest\n    POST: Type[BaseModel] = FreeTextExtensionPostRequest\n\n    conformance_classes: List[str] = attr.ib(\n        default=[\n            FreeTextConformanceClasses.SEARCH,\n        ]\n    )\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/free_text/#stac_fastapi.extensions.core.free_text.free_text.FreeTextExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/free_text.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/request/","title":"request","text":""},{"location":"api/stac_fastapi/extensions/core/free_text/request/#stac_fastapi.extensions.core.free_text.request","title":"stac_fastapi.extensions.core.free_text.request","text":"<p>Request model for the Free-text extension.</p>"},{"location":"api/stac_fastapi/extensions/core/free_text/request/#stac_fastapi.extensions.core.free_text.request.FreeTextAdvancedExtensionGetRequest","title":"FreeTextAdvancedExtensionGetRequest","text":"<p>               Bases: <code>APIRequest</code></p> <p>Free-text Extension GET request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/request.py</code> <pre><code>@attr.s\nclass FreeTextAdvancedExtensionGetRequest(APIRequest):\n    \"\"\"Free-text Extension GET request model.\"\"\"\n\n    q: Annotated[\n        Optional[str],\n        Query(\n            description=\"Parameter to perform free-text queries against STAC metadata\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"Coastal\": {\"value\": \"ocean,coast\"},\n            },\n        ),\n    ] = attr.ib(default=None)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/request/#stac_fastapi.extensions.core.free_text.request.FreeTextAdvancedExtensionPostRequest","title":"FreeTextAdvancedExtensionPostRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Free-text Extension POST request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/request.py</code> <pre><code>class FreeTextAdvancedExtensionPostRequest(BaseModel):\n    \"\"\"Free-text Extension POST request model.\"\"\"\n\n    q: Optional[str] = Field(\n        None,\n        description=\"Parameter to perform free-text queries against STAC metadata\",\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/request/#stac_fastapi.extensions.core.free_text.request.FreeTextExtensionGetRequest","title":"FreeTextExtensionGetRequest","text":"<p>               Bases: <code>APIRequest</code></p> <p>Free-text Extension GET request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/request.py</code> <pre><code>@attr.s\nclass FreeTextExtensionGetRequest(APIRequest):\n    \"\"\"Free-text Extension GET request model.\"\"\"\n\n    q: Optional[List[str]] = attr.ib(default=None, converter=_ft_converter)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/free_text/request/#stac_fastapi.extensions.core.free_text.request.FreeTextExtensionPostRequest","title":"FreeTextExtensionPostRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Free-text Extension POST request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/free_text/request.py</code> <pre><code>class FreeTextExtensionPostRequest(BaseModel):\n    \"\"\"Free-text Extension POST request model.\"\"\"\n\n    q: Optional[List[str]] = Field(\n        None,\n        description=\"Parameter to perform free-text queries against STAC metadata\",\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/","title":"Module stac_fastapi.extensions.core.pagination","text":"<p>Pagination Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/pagination/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.pagination.pagination</li> <li>stac_fastapi.extensions.core.pagination.offset_pagination</li> <li>stac_fastapi.extensions.core.pagination.token_pagination</li> <li>stac_fastapi.extensions.core.pagination.request</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/pagination/offset_pagination/","title":"offset_pagination","text":""},{"location":"api/stac_fastapi/extensions/core/pagination/offset_pagination/#stac_fastapi.extensions.core.pagination.offset_pagination","title":"stac_fastapi.extensions.core.pagination.offset_pagination","text":"<p>Offset Pagination API extension.</p>"},{"location":"api/stac_fastapi/extensions/core/pagination/offset_pagination/#stac_fastapi.extensions.core.pagination.offset_pagination.OffsetPaginationExtension","title":"OffsetPaginationExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Offset Pagination.</p> <p>Though not strictly an extension, the chosen pagination will modify the form of the request object. By making pagination an extension class, we can use create_request_model to dynamically add the correct pagination parameter to the request model for OpenAPI generation.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/offset_pagination.py</code> <pre><code>@attr.s\nclass OffsetPaginationExtension(ApiExtension):\n    \"\"\"Offset Pagination.\n\n    Though not strictly an extension, the chosen pagination will modify the form of the\n    request object. By making pagination an extension class, we can use\n    create_request_model to dynamically add the correct pagination parameter to the\n    request model for OpenAPI generation.\n    \"\"\"\n\n    GET: Type[APIRequest] = GETOffsetPagination\n    POST: Type[BaseModel] = POSTOffsetPagination\n\n    conformance_classes: List[str] = attr.ib(factory=list)\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/offset_pagination/#stac_fastapi.extensions.core.pagination.offset_pagination.OffsetPaginationExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/offset_pagination.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/pagination/","title":"pagination","text":""},{"location":"api/stac_fastapi/extensions/core/pagination/pagination/#stac_fastapi.extensions.core.pagination.pagination","title":"stac_fastapi.extensions.core.pagination.pagination","text":"<p>Pagination API extension.</p>"},{"location":"api/stac_fastapi/extensions/core/pagination/pagination/#stac_fastapi.extensions.core.pagination.pagination.PaginationExtension","title":"PaginationExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Token Pagination.</p> <p>Though not strictly an extension, the chosen pagination will modify the form of the request object. By making pagination an extension class, we can use create_request_model to dynamically add the correct pagination parameter to the request model for OpenAPI generation.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/pagination.py</code> <pre><code>@attr.s\nclass PaginationExtension(ApiExtension):\n    \"\"\"Token Pagination.\n\n    Though not strictly an extension, the chosen pagination will modify the form of the\n    request object. By making pagination an extension class, we can use\n    create_request_model to dynamically add the correct pagination parameter to the\n    request model for OpenAPI generation.\n    \"\"\"\n\n    GET: Type[APIRequest] = GETPagination\n    POST: Type[BaseModel] = POSTPagination\n\n    conformance_classes: List[str] = attr.ib(factory=list)\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/pagination/#stac_fastapi.extensions.core.pagination.pagination.PaginationExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/pagination.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/request/","title":"request","text":""},{"location":"api/stac_fastapi/extensions/core/pagination/request/#stac_fastapi.extensions.core.pagination.request","title":"stac_fastapi.extensions.core.pagination.request","text":"<p>Pagination extension request models.</p>"},{"location":"api/stac_fastapi/extensions/core/pagination/request/#stac_fastapi.extensions.core.pagination.request.GETOffsetPagination","title":"GETOffsetPagination","text":"<p>               Bases: <code>APIRequest</code></p> <p>Offset pagination for GET requests.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/request.py</code> <pre><code>@attr.s\nclass GETOffsetPagination(APIRequest):\n    \"\"\"Offset pagination for GET requests.\"\"\"\n\n    offset: Annotated[Optional[int], Query()] = attr.ib(default=None)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/request/#stac_fastapi.extensions.core.pagination.request.GETPagination","title":"GETPagination","text":"<p>               Bases: <code>APIRequest</code></p> <p>Page based pagination for GET requests.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/request.py</code> <pre><code>@attr.s\nclass GETPagination(APIRequest):\n    \"\"\"Page based pagination for GET requests.\"\"\"\n\n    page: Annotated[Optional[str], Query()] = attr.ib(default=None)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/request/#stac_fastapi.extensions.core.pagination.request.GETTokenPagination","title":"GETTokenPagination","text":"<p>               Bases: <code>APIRequest</code></p> <p>Token pagination for GET requests.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/request.py</code> <pre><code>@attr.s\nclass GETTokenPagination(APIRequest):\n    \"\"\"Token pagination for GET requests.\"\"\"\n\n    token: Annotated[Optional[str], Query()] = attr.ib(default=None)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/request/#stac_fastapi.extensions.core.pagination.request.POSTOffsetPagination","title":"POSTOffsetPagination","text":"<p>               Bases: <code>BaseModel</code></p> <p>Offset pagination model for POST requests.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/request.py</code> <pre><code>class POSTOffsetPagination(BaseModel):\n    \"\"\"Offset pagination model for POST requests.\"\"\"\n\n    offset: Optional[int] = None\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/request/#stac_fastapi.extensions.core.pagination.request.POSTPagination","title":"POSTPagination","text":"<p>               Bases: <code>BaseModel</code></p> <p>Page based pagination for POST requests.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/request.py</code> <pre><code>class POSTPagination(BaseModel):\n    \"\"\"Page based pagination for POST requests.\"\"\"\n\n    page: Optional[str] = None\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/request/#stac_fastapi.extensions.core.pagination.request.POSTTokenPagination","title":"POSTTokenPagination","text":"<p>               Bases: <code>BaseModel</code></p> <p>Token pagination model for POST requests.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/request.py</code> <pre><code>class POSTTokenPagination(BaseModel):\n    \"\"\"Token pagination model for POST requests.\"\"\"\n\n    token: Optional[str] = None\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/token_pagination/","title":"token_pagination","text":""},{"location":"api/stac_fastapi/extensions/core/pagination/token_pagination/#stac_fastapi.extensions.core.pagination.token_pagination","title":"stac_fastapi.extensions.core.pagination.token_pagination","text":"<p>Token pagination API extension.</p>"},{"location":"api/stac_fastapi/extensions/core/pagination/token_pagination/#stac_fastapi.extensions.core.pagination.token_pagination.TokenPaginationExtension","title":"TokenPaginationExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Token Pagination.</p> <p>Though not strictly an extension, the chosen pagination will modify the form of the request object. By making pagination an extension class, we can use create_request_model to dynamically add the correct pagination parameter to the request model for OpenAPI generation.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/token_pagination.py</code> <pre><code>@attr.s\nclass TokenPaginationExtension(ApiExtension):\n    \"\"\"Token Pagination.\n\n    Though not strictly an extension, the chosen pagination will modify the form of the\n    request object. By making pagination an extension class, we can use\n    create_request_model to dynamically add the correct pagination parameter to the\n    request model for OpenAPI generation.\n    \"\"\"\n\n    GET: Type[APIRequest] = GETTokenPagination\n    POST: Type[BaseModel] = POSTTokenPagination\n\n    conformance_classes: List[str] = attr.ib(factory=list)\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/pagination/token_pagination/#stac_fastapi.extensions.core.pagination.token_pagination.TokenPaginationExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/pagination/token_pagination.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/query/","title":"Module stac_fastapi.extensions.core.query","text":"<p>Query Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/query/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.query.query</li> <li>stac_fastapi.extensions.core.query.request</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/query/query/","title":"query","text":""},{"location":"api/stac_fastapi/extensions/core/query/query/#stac_fastapi.extensions.core.query.query","title":"stac_fastapi.extensions.core.query.query","text":"<p>Query extension.</p>"},{"location":"api/stac_fastapi/extensions/core/query/query/#stac_fastapi.extensions.core.query.query.QueryConformanceClasses","title":"QueryConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the Query extension.</p> <p>See stac-api-extensions/query</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/query/query.py</code> <pre><code>class QueryConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the Query extension.\n\n    See https://github.com/stac-api-extensions/query\n    \"\"\"\n\n    SEARCH = \"https://api.stacspec.org/v1.0.0/item-search#query\"\n    ITEMS = \"https://api.stacspec.org/v1.0.0/ogcapi-features#query\"\n    COLLECTIONS = \"https://api.stacspec.org/v1.0.0-rc.1/collection-search#query\"\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/query/query/#stac_fastapi.extensions.core.query.query.QueryExtension","title":"QueryExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Query Extension.</p> <p>The Query extension adds an additional <code>query</code> parameter to <code>/search</code> requests which allows the caller to perform queries against item metadata (ex. find all images with cloud cover less than 15%). stac-api-extensions/query</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/query/query.py</code> <pre><code>@attr.s\nclass QueryExtension(ApiExtension):\n    \"\"\"Query Extension.\n\n    The Query extension adds an additional `query` parameter to `/search` requests which\n    allows the caller to perform queries against item metadata (ex. find all images with\n    cloud cover less than 15%).\n    https://github.com/stac-api-extensions/query\n    \"\"\"\n\n    GET: Type[APIRequest] = QueryExtensionGetRequest\n    POST: Type[BaseModel] = QueryExtensionPostRequest\n\n    conformance_classes: List[str] = attr.ib(\n        factory=lambda: [\n            QueryConformanceClasses.SEARCH,\n        ]\n    )\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/query/query/#stac_fastapi.extensions.core.query.query.QueryExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/query/query.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/query/request/","title":"request","text":""},{"location":"api/stac_fastapi/extensions/core/query/request/#stac_fastapi.extensions.core.query.request","title":"stac_fastapi.extensions.core.query.request","text":"<p>Request model for the Query extension.</p>"},{"location":"api/stac_fastapi/extensions/core/query/request/#stac_fastapi.extensions.core.query.request.QueryExtensionGetRequest","title":"QueryExtensionGetRequest","text":"<p>               Bases: <code>APIRequest</code></p> <p>Query Extension GET request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/query/request.py</code> <pre><code>@attr.s\nclass QueryExtensionGetRequest(APIRequest):\n    \"\"\"Query Extension GET request model.\"\"\"\n\n    query: Annotated[\n        Optional[str],\n        Query(\n            description=\"Allows additional filtering based on the properties of Item objects\",  # noqa: E501\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"cloudy\": {\"value\": '{\"eo:cloud_cover\": {\"gte\": 95}}'},\n            },\n        ),\n    ] = attr.ib(default=None)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/query/request/#stac_fastapi.extensions.core.query.request.QueryExtensionPostRequest","title":"QueryExtensionPostRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Query Extension POST request model.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/query/request.py</code> <pre><code>class QueryExtensionPostRequest(BaseModel):\n    \"\"\"Query Extension POST request model.\"\"\"\n\n    query: Optional[Dict[str, Dict[str, Any]]] = Field(\n        None,\n        description=\"Allows additional filtering based on the properties of Item objects\",  # noqa: E501\n        json_schema_extra={\n            \"examples\": [\n                # user-provided\n                None,\n                # cloudy\n                '{\"eo:cloud_cover\": {\"gte\": 95}}',\n            ],\n        },\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/sort/","title":"Module stac_fastapi.extensions.core.sort","text":"<p>Sort Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/core/sort/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.core.sort.sort</li> <li>stac_fastapi.extensions.core.sort.request</li> </ul>"},{"location":"api/stac_fastapi/extensions/core/sort/request/","title":"request","text":""},{"location":"api/stac_fastapi/extensions/core/sort/request/#stac_fastapi.extensions.core.sort.request","title":"stac_fastapi.extensions.core.sort.request","text":"<p>Request model for the Sort Extension.</p>"},{"location":"api/stac_fastapi/extensions/core/sort/request/#stac_fastapi.extensions.core.sort.request.SortExtensionGetRequest","title":"SortExtensionGetRequest","text":"<p>               Bases: <code>APIRequest</code></p> <p>Sortby Parameter for GET requests.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/sort/request.py</code> <pre><code>@attr.s\nclass SortExtensionGetRequest(APIRequest):\n    \"\"\"Sortby Parameter for GET requests.\"\"\"\n\n    sortby: Optional[List[str]] = attr.ib(default=None, converter=_sort_converter)\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/sort/request/#stac_fastapi.extensions.core.sort.request.SortExtensionPostRequest","title":"SortExtensionPostRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Sortby parameter for POST requests.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/sort/request.py</code> <pre><code>class SortExtensionPostRequest(BaseModel):\n    \"\"\"Sortby parameter for POST requests.\"\"\"\n\n    sortby: Optional[List[PostSortModel]] = Field(\n        None,\n        description=\"An array of property (field) names, and direction in form of '{'field': '&lt;property_name&gt;', 'direction':'&lt;direction&gt;'}'\",  # noqa: E501\n        json_schema_extra={\n            \"examples\": [\n                # user-provided\n                None,\n                # creation-time\n                [\n                    {\n                        \"field\": \"properties.created\",\n                        \"direction\": \"asc\",\n                    }\n                ],\n            ],\n        },\n    )\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/sort/sort/","title":"sort","text":""},{"location":"api/stac_fastapi/extensions/core/sort/sort/#stac_fastapi.extensions.core.sort.sort","title":"stac_fastapi.extensions.core.sort.sort","text":"<p>Sort extension.</p>"},{"location":"api/stac_fastapi/extensions/core/sort/sort/#stac_fastapi.extensions.core.sort.sort.SortConformanceClasses","title":"SortConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the Sort extension.</p> <p>See stac-api-extensions/sort</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/sort/sort.py</code> <pre><code>class SortConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the Sort extension.\n\n    See https://github.com/stac-api-extensions/sort\n\n    \"\"\"\n\n    SEARCH = \"https://api.stacspec.org/v1.0.0/item-search#sort\"\n    ITEMS = \"https://api.stacspec.org/v1.0.0/ogcapi-features#sort\"\n    COLLECTIONS = \"https://api.stacspec.org/v1.0.0-rc.1/collection-search#sort\"\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/sort/sort/#stac_fastapi.extensions.core.sort.sort.SortExtension","title":"SortExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Sort Extension.</p> <p>The Sort extension adds the <code>sortby</code> parameter to the <code>/search</code> endpoint, allowing the caller to specify the sort order of the returned items. stac-api-extensions/sort</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/sort/sort.py</code> <pre><code>@attr.s\nclass SortExtension(ApiExtension):\n    \"\"\"Sort Extension.\n\n    The Sort extension adds the `sortby` parameter to the `/search` endpoint, allowing the\n    caller to specify the sort order of the returned items.\n    https://github.com/stac-api-extensions/sort\n    \"\"\"\n\n    GET: Type[APIRequest] = SortExtensionGetRequest\n    POST: Type[BaseModel] = SortExtensionPostRequest\n\n    conformance_classes: List[str] = attr.ib(\n        factory=lambda: [\n            SortConformanceClasses.SEARCH,\n        ]\n    )\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/core/sort/sort/#stac_fastapi.extensions.core.sort.sort.SortExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/core/sort/sort.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/","title":"Module stac_fastapi.extensions.third_party","text":"<p>Third Party Extensions submodule.</p>"},{"location":"api/stac_fastapi/extensions/third_party/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.extensions.third_party.bulk_transactions</li> </ul>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/","title":"bulk_transactions","text":""},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions","title":"stac_fastapi.extensions.third_party.bulk_transactions","text":"<p>Bulk transactions extension.</p>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.AsyncBaseBulkTransactionsClient","title":"AsyncBaseBulkTransactionsClient","text":"<p>               Bases: <code>ABC</code></p> <p>BulkTransactionsClient.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>@attr.s\nclass AsyncBaseBulkTransactionsClient(abc.ABC):\n    \"\"\"BulkTransactionsClient.\"\"\"\n\n    @abc.abstractmethod\n    async def bulk_item_insert(\n        self,\n        items: Items,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Bulk creation of items.\n\n        Args:\n            items: list of items.\n\n        Returns:\n            Message indicating the status of the insert.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.AsyncBaseBulkTransactionsClient.bulk_item_insert","title":"bulk_item_insert  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>bulk_item_insert(items: Items, **kwargs) -&gt; str\n</code></pre> <p>Bulk creation of items.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>Items</code>)           \u2013            <p>list of items.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Message indicating the status of the insert.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>@abc.abstractmethod\nasync def bulk_item_insert(\n    self,\n    items: Items,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Bulk creation of items.\n\n    Args:\n        items: list of items.\n\n    Returns:\n        Message indicating the status of the insert.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.BaseBulkTransactionsClient","title":"BaseBulkTransactionsClient","text":"<p>               Bases: <code>ABC</code></p> <p>BulkTransactionsClient.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>@attr.s\nclass BaseBulkTransactionsClient(abc.ABC):\n    \"\"\"BulkTransactionsClient.\"\"\"\n\n    @staticmethod\n    def _chunks(lst, n):\n        \"\"\"Yield successive n-sized chunks from list.\n\n        https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks\n        \"\"\"\n        for i in range(0, len(lst), n):\n            yield lst[i : i + n]\n\n    @abc.abstractmethod\n    def bulk_item_insert(\n        self,\n        items: Items,\n        chunk_size: Optional[int] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Bulk creation of items.\n\n        Args:\n            items: list of items.\n            chunk_size: number of items processed at a time.\n\n        Returns:\n            Message indicating the status of the insert.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.BaseBulkTransactionsClient.bulk_item_insert","title":"bulk_item_insert  <code>abstractmethod</code>","text":"<pre><code>bulk_item_insert(items: Items, chunk_size: Optional[int] = None, **kwargs) -&gt; str\n</code></pre> <p>Bulk creation of items.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>Items</code>)           \u2013            <p>list of items.</p> </li> <li> <code>chunk_size</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>number of items processed at a time.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Message indicating the status of the insert.</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>@abc.abstractmethod\ndef bulk_item_insert(\n    self,\n    items: Items,\n    chunk_size: Optional[int] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Bulk creation of items.\n\n    Args:\n        items: list of items.\n        chunk_size: number of items processed at a time.\n\n    Returns:\n        Message indicating the status of the insert.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.BulkTransactionExtension","title":"BulkTransactionExtension","text":"<p>               Bases: <code>ApiExtension</code></p> <p>Bulk Transaction Extension.</p> <p>Bulk Transaction extension adds the <code>POST /collections/{collection_id}/bulk_items</code> endpoint to the application for efficient bulk insertion of items. The input to this is an object with an attribute  \"items\", that has a value that is an object with a group of attributes that are the ids of each Item, and the value is the Item entity.</p> <p>Optionally, clients can specify a \"method\" attribute that is either \"insert\" or \"upsert\". If \"insert\", then the items will be inserted if they do not exist, and an error will be returned if they do. If \"upsert\", then the items will be inserted if they do not exist, and updated if they do. This defaults to \"insert\".</p> <pre><code>{\n    \"items\": {\n        \"id1\": { \"type\": \"Feature\", ... },\n        \"id2\": { \"type\": \"Feature\", ... },\n        \"id3\": { \"type\": \"Feature\", ... }\n    },\n    \"method\": \"insert\"\n}\n</code></pre> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>@attr.s\nclass BulkTransactionExtension(ApiExtension):\n    \"\"\"Bulk Transaction Extension.\n\n    Bulk Transaction extension adds the `POST\n    /collections/{collection_id}/bulk_items` endpoint to the application for\n    efficient bulk insertion of items. The input to this is an object with an\n    attribute  \"items\", that has a value that is an object with a group of\n    attributes that are the ids of each Item, and the value is the Item entity.\n\n    Optionally, clients can specify a \"method\" attribute that is either \"insert\"\n    or \"upsert\". If \"insert\", then the items will be inserted if they do not\n    exist, and an error will be returned if they do. If \"upsert\", then the items\n    will be inserted if they do not exist, and updated if they do. This defaults\n    to \"insert\".\n\n        {\n            \"items\": {\n                \"id1\": { \"type\": \"Feature\", ... },\n                \"id2\": { \"type\": \"Feature\", ... },\n                \"id3\": { \"type\": \"Feature\", ... }\n            },\n            \"method\": \"insert\"\n        }\n    \"\"\"\n\n    client: Union[AsyncBaseBulkTransactionsClient, BaseBulkTransactionsClient] = attr.ib()\n    conformance_classes: List[str] = attr.ib(default=list())\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        items_request_model = create_request_model(\"Items\", base_model=Items)\n\n        router = APIRouter(prefix=app.state.router_prefix)\n        router.add_api_route(\n            name=\"Bulk Create Item\",\n            path=\"/collections/{collection_id}/bulk_items\",\n            response_model=str,\n            response_model_exclude_unset=True,\n            response_model_exclude_none=True,\n            methods=[\"POST\"],\n            endpoint=create_async_endpoint(\n                self.client.bulk_item_insert, items_request_model\n            ),\n        )\n        app.include_router(router, tags=[\"Bulk Transaction Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.BulkTransactionExtension.register","title":"register","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>def register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    items_request_model = create_request_model(\"Items\", base_model=Items)\n\n    router = APIRouter(prefix=app.state.router_prefix)\n    router.add_api_route(\n        name=\"Bulk Create Item\",\n        path=\"/collections/{collection_id}/bulk_items\",\n        response_model=str,\n        response_model_exclude_unset=True,\n        response_model_exclude_none=True,\n        methods=[\"POST\"],\n        endpoint=create_async_endpoint(\n            self.client.bulk_item_insert, items_request_model\n        ),\n    )\n    app.include_router(router, tags=[\"Bulk Transaction Extension\"])\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.BulkTransactionMethod","title":"BulkTransactionMethod","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Bulk Transaction Methods.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>class BulkTransactionMethod(str, Enum):\n    \"\"\"Bulk Transaction Methods.\"\"\"\n\n    INSERT = \"insert\"\n    UPSERT = \"upsert\"\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.Items","title":"Items","text":"<p>               Bases: <code>BaseModel</code></p> <p>A group of STAC Item objects, in the form of a dictionary from Item.id -&gt; Item.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>class Items(BaseModel):\n    \"\"\"A group of STAC Item objects, in the form of a dictionary from Item.id -&gt; Item.\"\"\"\n\n    items: Dict[str, Any]\n    method: BulkTransactionMethod = BulkTransactionMethod.INSERT\n\n    def __iter__(self):\n        \"\"\"Return an iterable of STAC Item objects.\"\"\"\n        return iter(self.items.values())\n</code></pre>"},{"location":"api/stac_fastapi/extensions/third_party/bulk_transactions/#stac_fastapi.extensions.third_party.bulk_transactions.Items.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Return an iterable of STAC Item objects.</p> Source code in <code>stac_fastapi/extensions/stac_fastapi/extensions/third_party/bulk_transactions.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return an iterable of STAC Item objects.\"\"\"\n    return iter(self.items.values())\n</code></pre>"},{"location":"api/stac_fastapi/types/","title":"Module stac_fastapi.types","text":"<p>Types submodule.</p>"},{"location":"api/stac_fastapi/types/#sub-modules","title":"Sub-modules","text":"<ul> <li>stac_fastapi.types.config</li> <li>stac_fastapi.types.conformance</li> <li>stac_fastapi.types.core</li> <li>stac_fastapi.types.errors</li> <li>stac_fastapi.types.extension</li> <li>stac_fastapi.types.links</li> <li>stac_fastapi.types.requests</li> <li>stac_fastapi.types.rfc3339</li> <li>stac_fastapi.types.search</li> <li>stac_fastapi.types.stac</li> </ul>"},{"location":"api/stac_fastapi/types/config/","title":"config","text":""},{"location":"api/stac_fastapi/types/config/#stac_fastapi.types.config","title":"stac_fastapi.types.config","text":"<p>stac_fastapi.types.config module.</p>"},{"location":"api/stac_fastapi/types/config/#stac_fastapi.types.config.ApiSettings","title":"ApiSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>ApiSettings.</p> <p>Defines api configuration, potentially through environment variables. See pydantic-docs.helpmanual.io/usage/settings/. Attributes:     environment: name of the environment (ex. dev/prod).     debug: toggles debug mode.     forbidden_fields: set of fields defined by STAC but not included in the database.     indexed_fields:         set of fields which are usually in <code>item.properties</code> but are indexed         as distinct columns in the database.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/config.py</code> <pre><code>class ApiSettings(BaseSettings):\n    \"\"\"ApiSettings.\n\n    Defines api configuration, potentially through environment variables.\n    See https://pydantic-docs.helpmanual.io/usage/settings/.\n    Attributes:\n        environment: name of the environment (ex. dev/prod).\n        debug: toggles debug mode.\n        forbidden_fields: set of fields defined by STAC but not included in the database.\n        indexed_fields:\n            set of fields which are usually in `item.properties` but are indexed\n            as distinct columns in the database.\n    \"\"\"\n\n    stac_fastapi_title: str = \"stac-fastapi\"\n    stac_fastapi_description: str = \"stac-fastapi\"\n    stac_fastapi_version: str = \"0.1\"\n    stac_fastapi_landing_id: str = \"stac-fastapi\"\n\n    app_host: str = \"0.0.0.0\"\n    app_port: int = 8000\n    reload: bool = True\n\n    # Enable Pydantic validation for output Response\n    enable_response_models: bool = False\n\n    # Enable direct `Response` from endpoint, skipping validation and serialization\n    enable_direct_response: bool = False\n\n    openapi_url: str = \"/api\"\n    docs_url: str = \"/api.html\"\n    root_path: str = \"\"\n\n    model_config = SettingsConfigDict(env_file=\".env\", extra=\"allow\")\n\n    @model_validator(mode=\"after\")\n    def check_incompatible_options(self) -&gt; Self:\n        \"\"\"Check for incompatible options.\"\"\"\n        if self.enable_response_models and self.enable_direct_response:\n            raise ValueError(\n                \"`enable_reponse_models` and `enable_direct_response` options are incompatible\"  # noqa: E501\n            )\n\n        return self\n</code></pre>"},{"location":"api/stac_fastapi/types/config/#stac_fastapi.types.config.ApiSettings.check_incompatible_options","title":"check_incompatible_options","text":"<pre><code>check_incompatible_options() -&gt; Self\n</code></pre> <p>Check for incompatible options.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_incompatible_options(self) -&gt; Self:\n    \"\"\"Check for incompatible options.\"\"\"\n    if self.enable_response_models and self.enable_direct_response:\n        raise ValueError(\n            \"`enable_reponse_models` and `enable_direct_response` options are incompatible\"  # noqa: E501\n        )\n\n    return self\n</code></pre>"},{"location":"api/stac_fastapi/types/config/#stac_fastapi.types.config.Settings","title":"Settings","text":"<p>Holds the global instance of settings.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/config.py</code> <pre><code>class Settings:\n    \"\"\"Holds the global instance of settings.\"\"\"\n\n    _instance: Optional[ApiSettings] = None\n\n    @classmethod\n    def set(cls, base_settings: ApiSettings):\n        \"\"\"Set the global settings.\"\"\"\n        cls._instance = base_settings\n\n    @classmethod\n    def get(cls) -&gt; ApiSettings:\n        \"\"\"Get the settings.\n\n        If they have not yet been set, throws an exception.\n        \"\"\"\n        if cls._instance is None:\n            raise ValueError(\"Settings have not yet been set.\")\n        return cls._instance\n</code></pre>"},{"location":"api/stac_fastapi/types/config/#stac_fastapi.types.config.Settings.get","title":"get  <code>classmethod</code>","text":"<pre><code>get() -&gt; ApiSettings\n</code></pre> <p>Get the settings.</p> <p>If they have not yet been set, throws an exception.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/config.py</code> <pre><code>@classmethod\ndef get(cls) -&gt; ApiSettings:\n    \"\"\"Get the settings.\n\n    If they have not yet been set, throws an exception.\n    \"\"\"\n    if cls._instance is None:\n        raise ValueError(\"Settings have not yet been set.\")\n    return cls._instance\n</code></pre>"},{"location":"api/stac_fastapi/types/config/#stac_fastapi.types.config.Settings.set","title":"set  <code>classmethod</code>","text":"<pre><code>set(base_settings: ApiSettings)\n</code></pre> <p>Set the global settings.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/config.py</code> <pre><code>@classmethod\ndef set(cls, base_settings: ApiSettings):\n    \"\"\"Set the global settings.\"\"\"\n    cls._instance = base_settings\n</code></pre>"},{"location":"api/stac_fastapi/types/conformance/","title":"conformance","text":""},{"location":"api/stac_fastapi/types/conformance/#stac_fastapi.types.conformance","title":"stac_fastapi.types.conformance","text":"<p>Conformance Classes.</p>"},{"location":"api/stac_fastapi/types/conformance/#stac_fastapi.types.conformance.OAFConformanceClasses","title":"OAFConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for OGC API - Features.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/conformance.py</code> <pre><code>class OAFConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for OGC API - Features.\"\"\"\n\n    CORE = \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\"\n    OPEN_API = \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/oas30\"\n    GEOJSON = \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/geojson\"\n</code></pre>"},{"location":"api/stac_fastapi/types/conformance/#stac_fastapi.types.conformance.STACConformanceClasses","title":"STACConformanceClasses","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Conformance classes for the STAC API spec.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/conformance.py</code> <pre><code>class STACConformanceClasses(str, Enum):\n    \"\"\"Conformance classes for the STAC API spec.\"\"\"\n\n    CORE = \"https://api.stacspec.org/v1.0.0/core\"\n    OGC_API_FEAT = \"https://api.stacspec.org/v1.0.0/ogcapi-features\"\n    COLLECTIONS = \"https://api.stacspec.org/v1.0.0/collections\"\n    ITEM_SEARCH = \"https://api.stacspec.org/v1.0.0/item-search\"\n</code></pre>"},{"location":"api/stac_fastapi/types/core/","title":"core","text":""},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core","title":"stac_fastapi.types.core","text":"<p>Base clients.</p>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient","title":"AsyncBaseCoreClient","text":"<p>               Bases: <code>LandingPageMixin</code>, <code>ABC</code></p> <p>Defines a pattern for implementing STAC api core endpoints.</p> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>List[ApiExtension]</code>)           \u2013            <p>list of registered api extensions.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@attr.s  # type:ignore\nclass AsyncBaseCoreClient(LandingPageMixin, abc.ABC):\n    \"\"\"Defines a pattern for implementing STAC api core endpoints.\n\n    Attributes:\n        extensions: list of registered api extensions.\n    \"\"\"\n\n    base_conformance_classes: List[str] = attr.ib(\n        factory=lambda: BASE_CONFORMANCE_CLASSES\n    )\n    extensions: List[ApiExtension] = attr.ib(default=attr.Factory(list))\n\n    def conformance_classes(self) -&gt; List[str]:\n        \"\"\"Generate conformance classes by adding extension conformance to base\n        conformance classes.\"\"\"\n        conformance_classes = self.base_conformance_classes.copy()\n\n        for extension in self.extensions:\n            extension_classes = getattr(extension, \"conformance_classes\", [])\n            conformance_classes.extend(extension_classes)\n\n        return sorted(list(set(conformance_classes)))\n\n    def extension_is_enabled(self, extension: str) -&gt; bool:\n        \"\"\"Check if an api extension is enabled.\"\"\"\n        return any([type(ext).__name__ == extension for ext in self.extensions])\n\n    async def landing_page(self, **kwargs) -&gt; stac.LandingPage:\n        \"\"\"Landing page.\n\n        Called with `GET /`.\n\n        Returns:\n            API landing page, serving as an entry point to the API.\n        \"\"\"\n        request: Request = kwargs[\"request\"]\n        base_url = get_base_url(request)\n\n        landing_page = self._landing_page(\n            base_url=base_url,\n            conformance_classes=self.conformance_classes(),\n            extension_schemas=[],\n        )\n\n        # Add Queryables link\n        if self.extension_is_enabled(\"FilterExtension\") or self.extension_is_enabled(\n            \"SearchFilterExtension\"\n        ):\n            landing_page[\"links\"].append(\n                {\n                    \"rel\": Relations.queryables.value,\n                    \"type\": MimeTypes.jsonschema.value,\n                    \"title\": \"Queryables available for this Catalog\",\n                    \"href\": urljoin(base_url, \"queryables\"),\n                    \"method\": \"GET\",\n                }\n            )\n\n        # Add Aggregation links\n        if self.extension_is_enabled(\"AggregationExtension\"):\n            landing_page[\"links\"].extend(\n                [\n                    {\n                        \"rel\": \"aggregate\",\n                        \"type\": \"application/json\",\n                        \"title\": \"Aggregate\",\n                        \"href\": urljoin(base_url, \"aggregate\"),\n                    },\n                    {\n                        \"rel\": \"aggregations\",\n                        \"type\": \"application/json\",\n                        \"title\": \"Aggregations\",\n                        \"href\": urljoin(base_url, \"aggregations\"),\n                    },\n                ]\n            )\n\n        # Add OpenAPI URL\n        landing_page[\"links\"].append(\n            {\n                \"rel\": Relations.service_desc.value,\n                \"type\": MimeTypes.openapi.value,\n                \"title\": \"OpenAPI service description\",\n                \"href\": str(request.url_for(\"openapi\")),\n            }\n        )\n\n        # Add human readable service-doc\n        landing_page[\"links\"].append(\n            {\n                \"rel\": Relations.service_doc.value,\n                \"type\": MimeTypes.html.value,\n                \"title\": \"OpenAPI service documentation\",\n                \"href\": str(request.url_for(\"swagger_ui_html\")),\n            }\n        )\n\n        return stac.LandingPage(**landing_page)\n\n    async def conformance(self, **kwargs) -&gt; stac.Conformance:\n        \"\"\"Conformance classes.\n\n        Called with `GET /conformance`.\n\n        Returns:\n            Conformance classes which the server conforms to.\n        \"\"\"\n        return stac.Conformance(conformsTo=self.conformance_classes())\n\n    @abc.abstractmethod\n    async def post_search(\n        self, search_request: BaseSearchPostRequest, **kwargs\n    ) -&gt; stac.ItemCollection:\n        \"\"\"Cross catalog search (POST).\n\n        Called with `POST /search`.\n\n        Args:\n            search_request: search request parameters.\n\n        Returns:\n            ItemCollection containing items which match the search criteria.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def get_search(\n        self,\n        collections: Optional[List[str]] = None,\n        ids: Optional[List[str]] = None,\n        bbox: Optional[BBox] = None,\n        intersects: Optional[Geometry] = None,\n        datetime: Optional[str] = None,\n        limit: Optional[int] = 10,\n        **kwargs,\n    ) -&gt; stac.ItemCollection:\n        \"\"\"Cross catalog search (GET).\n\n        Called with `GET /search`.\n\n        Returns:\n            ItemCollection containing items which match the search criteria.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def get_item(self, item_id: str, collection_id: str, **kwargs) -&gt; stac.Item:\n        \"\"\"Get item by id.\n\n        Called with `GET /collections/{collection_id}/items/{item_id}`.\n\n        Args:\n            item_id: Id of the item.\n            collection_id: Id of the collection.\n\n        Returns:\n            Item.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def all_collections(self, **kwargs) -&gt; stac.Collections:\n        \"\"\"Get all available collections.\n\n        Called with `GET /collections`.\n\n        Returns:\n            A list of collections.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def get_collection(self, collection_id: str, **kwargs) -&gt; stac.Collection:\n        \"\"\"Get collection by id.\n\n        Called with `GET /collections/{collection_id}`.\n\n        Args:\n            collection_id: Id of the collection.\n\n        Returns:\n            Collection.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def item_collection(\n        self,\n        collection_id: str,\n        bbox: Optional[BBox] = None,\n        datetime: Optional[str] = None,\n        limit: int = 10,\n        token: Optional[str] = None,\n        **kwargs,\n    ) -&gt; stac.ItemCollection:\n        \"\"\"Get all items from a specific collection.\n\n        Called with `GET /collections/{collection_id}/items`\n\n        Args:\n            collection_id: id of the collection.\n            limit: number of items to return.\n            token: pagination token.\n\n        Returns:\n            An ItemCollection.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.all_collections","title":"all_collections  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>all_collections(**kwargs) -&gt; Collections\n</code></pre> <p>Get all available collections.</p> <p>Called with <code>GET /collections</code>.</p> <p>Returns:</p> <ul> <li> <code>Collections</code>           \u2013            <p>A list of collections.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\nasync def all_collections(self, **kwargs) -&gt; stac.Collections:\n    \"\"\"Get all available collections.\n\n    Called with `GET /collections`.\n\n    Returns:\n        A list of collections.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.conformance","title":"conformance  <code>async</code>","text":"<pre><code>conformance(**kwargs) -&gt; Conformance\n</code></pre> <p>Conformance classes.</p> <p>Called with <code>GET /conformance</code>.</p> <p>Returns:</p> <ul> <li> <code>Conformance</code>           \u2013            <p>Conformance classes which the server conforms to.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>async def conformance(self, **kwargs) -&gt; stac.Conformance:\n    \"\"\"Conformance classes.\n\n    Called with `GET /conformance`.\n\n    Returns:\n        Conformance classes which the server conforms to.\n    \"\"\"\n    return stac.Conformance(conformsTo=self.conformance_classes())\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.conformance_classes","title":"conformance_classes","text":"<pre><code>conformance_classes() -&gt; List[str]\n</code></pre> <p>Generate conformance classes by adding extension conformance to base conformance classes.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>def conformance_classes(self) -&gt; List[str]:\n    \"\"\"Generate conformance classes by adding extension conformance to base\n    conformance classes.\"\"\"\n    conformance_classes = self.base_conformance_classes.copy()\n\n    for extension in self.extensions:\n        extension_classes = getattr(extension, \"conformance_classes\", [])\n        conformance_classes.extend(extension_classes)\n\n    return sorted(list(set(conformance_classes)))\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.extension_is_enabled","title":"extension_is_enabled","text":"<pre><code>extension_is_enabled(extension: str) -&gt; bool\n</code></pre> <p>Check if an api extension is enabled.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>def extension_is_enabled(self, extension: str) -&gt; bool:\n    \"\"\"Check if an api extension is enabled.\"\"\"\n    return any([type(ext).__name__ == extension for ext in self.extensions])\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.get_collection","title":"get_collection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_collection(collection_id: str, **kwargs) -&gt; Collection\n</code></pre> <p>Get collection by id.</p> <p>Called with <code>GET /collections/{collection_id}</code>.</p> <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>Id of the collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Collection</code>           \u2013            <p>Collection.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\nasync def get_collection(self, collection_id: str, **kwargs) -&gt; stac.Collection:\n    \"\"\"Get collection by id.\n\n    Called with `GET /collections/{collection_id}`.\n\n    Args:\n        collection_id: Id of the collection.\n\n    Returns:\n        Collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.get_item","title":"get_item  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_item(item_id: str, collection_id: str, **kwargs) -&gt; Item\n</code></pre> <p>Get item by id.</p> <p>Called with <code>GET /collections/{collection_id}/items/{item_id}</code>.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>str</code>)           \u2013            <p>Id of the item.</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>Id of the collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\nasync def get_item(self, item_id: str, collection_id: str, **kwargs) -&gt; stac.Item:\n    \"\"\"Get item by id.\n\n    Called with `GET /collections/{collection_id}/items/{item_id}`.\n\n    Args:\n        item_id: Id of the item.\n        collection_id: Id of the collection.\n\n    Returns:\n        Item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.get_search","title":"get_search  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_search(\n    collections: Optional[List[str]] = None,\n    ids: Optional[List[str]] = None,\n    bbox: Optional[BBox] = None,\n    intersects: Optional[Geometry] = None,\n    datetime: Optional[str] = None,\n    limit: Optional[int] = 10,\n    **kwargs\n) -&gt; ItemCollection\n</code></pre> <p>Cross catalog search (GET).</p> <p>Called with <code>GET /search</code>.</p> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>ItemCollection containing items which match the search criteria.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\nasync def get_search(\n    self,\n    collections: Optional[List[str]] = None,\n    ids: Optional[List[str]] = None,\n    bbox: Optional[BBox] = None,\n    intersects: Optional[Geometry] = None,\n    datetime: Optional[str] = None,\n    limit: Optional[int] = 10,\n    **kwargs,\n) -&gt; stac.ItemCollection:\n    \"\"\"Cross catalog search (GET).\n\n    Called with `GET /search`.\n\n    Returns:\n        ItemCollection containing items which match the search criteria.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.item_collection","title":"item_collection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>item_collection(\n    collection_id: str,\n    bbox: Optional[BBox] = None,\n    datetime: Optional[str] = None,\n    limit: int = 10,\n    token: Optional[str] = None,\n    **kwargs\n) -&gt; ItemCollection\n</code></pre> <p>Get all items from a specific collection.</p> <p>Called with <code>GET /collections/{collection_id}/items</code></p> <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>number of items to return.</p> </li> <li> <code>token</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>pagination token.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>An ItemCollection.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\nasync def item_collection(\n    self,\n    collection_id: str,\n    bbox: Optional[BBox] = None,\n    datetime: Optional[str] = None,\n    limit: int = 10,\n    token: Optional[str] = None,\n    **kwargs,\n) -&gt; stac.ItemCollection:\n    \"\"\"Get all items from a specific collection.\n\n    Called with `GET /collections/{collection_id}/items`\n\n    Args:\n        collection_id: id of the collection.\n        limit: number of items to return.\n        token: pagination token.\n\n    Returns:\n        An ItemCollection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.landing_page","title":"landing_page  <code>async</code>","text":"<pre><code>landing_page(**kwargs) -&gt; LandingPage\n</code></pre> <p>Landing page.</p> <p>Called with <code>GET /</code>.</p> <p>Returns:</p> <ul> <li> <code>LandingPage</code>           \u2013            <p>API landing page, serving as an entry point to the API.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>async def landing_page(self, **kwargs) -&gt; stac.LandingPage:\n    \"\"\"Landing page.\n\n    Called with `GET /`.\n\n    Returns:\n        API landing page, serving as an entry point to the API.\n    \"\"\"\n    request: Request = kwargs[\"request\"]\n    base_url = get_base_url(request)\n\n    landing_page = self._landing_page(\n        base_url=base_url,\n        conformance_classes=self.conformance_classes(),\n        extension_schemas=[],\n    )\n\n    # Add Queryables link\n    if self.extension_is_enabled(\"FilterExtension\") or self.extension_is_enabled(\n        \"SearchFilterExtension\"\n    ):\n        landing_page[\"links\"].append(\n            {\n                \"rel\": Relations.queryables.value,\n                \"type\": MimeTypes.jsonschema.value,\n                \"title\": \"Queryables available for this Catalog\",\n                \"href\": urljoin(base_url, \"queryables\"),\n                \"method\": \"GET\",\n            }\n        )\n\n    # Add Aggregation links\n    if self.extension_is_enabled(\"AggregationExtension\"):\n        landing_page[\"links\"].extend(\n            [\n                {\n                    \"rel\": \"aggregate\",\n                    \"type\": \"application/json\",\n                    \"title\": \"Aggregate\",\n                    \"href\": urljoin(base_url, \"aggregate\"),\n                },\n                {\n                    \"rel\": \"aggregations\",\n                    \"type\": \"application/json\",\n                    \"title\": \"Aggregations\",\n                    \"href\": urljoin(base_url, \"aggregations\"),\n                },\n            ]\n        )\n\n    # Add OpenAPI URL\n    landing_page[\"links\"].append(\n        {\n            \"rel\": Relations.service_desc.value,\n            \"type\": MimeTypes.openapi.value,\n            \"title\": \"OpenAPI service description\",\n            \"href\": str(request.url_for(\"openapi\")),\n        }\n    )\n\n    # Add human readable service-doc\n    landing_page[\"links\"].append(\n        {\n            \"rel\": Relations.service_doc.value,\n            \"type\": MimeTypes.html.value,\n            \"title\": \"OpenAPI service documentation\",\n            \"href\": str(request.url_for(\"swagger_ui_html\")),\n        }\n    )\n\n    return stac.LandingPage(**landing_page)\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.AsyncBaseCoreClient.post_search","title":"post_search  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>post_search(search_request: BaseSearchPostRequest, **kwargs) -&gt; ItemCollection\n</code></pre> <p>Cross catalog search (POST).</p> <p>Called with <code>POST /search</code>.</p> <p>Parameters:</p> <ul> <li> <code>search_request</code>               (<code>BaseSearchPostRequest</code>)           \u2013            <p>search request parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>ItemCollection containing items which match the search criteria.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\nasync def post_search(\n    self, search_request: BaseSearchPostRequest, **kwargs\n) -&gt; stac.ItemCollection:\n    \"\"\"Cross catalog search (POST).\n\n    Called with `POST /search`.\n\n    Args:\n        search_request: search request parameters.\n\n    Returns:\n        ItemCollection containing items which match the search criteria.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient","title":"BaseCoreClient","text":"<p>               Bases: <code>LandingPageMixin</code>, <code>ABC</code></p> <p>Defines a pattern for implementing STAC api core endpoints.</p> <p>Attributes:</p> <ul> <li> <code>extensions</code>               (<code>List[ApiExtension]</code>)           \u2013            <p>list of registered api extensions.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@attr.s  # type:ignore\nclass BaseCoreClient(LandingPageMixin, abc.ABC):\n    \"\"\"Defines a pattern for implementing STAC api core endpoints.\n\n    Attributes:\n        extensions: list of registered api extensions.\n    \"\"\"\n\n    base_conformance_classes: List[str] = attr.ib(\n        factory=lambda: BASE_CONFORMANCE_CLASSES\n    )\n    extensions: List[ApiExtension] = attr.ib(default=attr.Factory(list))\n\n    def conformance_classes(self) -&gt; List[str]:\n        \"\"\"Generate conformance classes by adding extension conformance to base\n        conformance classes.\"\"\"\n        base_conformance_classes = self.base_conformance_classes.copy()\n\n        for extension in self.extensions:\n            extension_classes = getattr(extension, \"conformance_classes\", [])\n            base_conformance_classes.extend(extension_classes)\n\n        return sorted(list(set(base_conformance_classes)))\n\n    def extension_is_enabled(self, extension: str) -&gt; bool:\n        \"\"\"Check if an api extension is enabled.\"\"\"\n        return any([type(ext).__name__ == extension for ext in self.extensions])\n\n    def list_conformance_classes(self):\n        \"\"\"Return a list of conformance classes, including implemented extensions.\"\"\"\n        base_conformance = BASE_CONFORMANCE_CLASSES\n\n        for extension in self.extensions:\n            extension_classes = getattr(extension, \"conformance_classes\", [])\n            base_conformance.extend(extension_classes)\n\n        return base_conformance\n\n    def landing_page(self, **kwargs) -&gt; stac.LandingPage:\n        \"\"\"Landing page.\n\n        Called with `GET /`.\n\n        Returns:\n            API landing page, serving as an entry point to the API.\n        \"\"\"\n        request: Request = kwargs[\"request\"]\n        base_url = get_base_url(request)\n\n        landing_page = self._landing_page(\n            base_url=base_url,\n            conformance_classes=self.conformance_classes(),\n            extension_schemas=[],\n        )\n\n        # Add Queryables link\n        if self.extension_is_enabled(\"FilterExtension\") or self.extension_is_enabled(\n            \"SearchFilterExtension\"\n        ):\n            landing_page[\"links\"].append(\n                {\n                    \"rel\": Relations.queryables.value,\n                    \"type\": MimeTypes.jsonschema.value,\n                    \"title\": \"Queryables available for this Catalog\",\n                    \"href\": urljoin(base_url, \"queryables\"),\n                }\n            )\n\n        # Add Aggregation links\n        if self.extension_is_enabled(\"AggregationExtension\"):\n            landing_page[\"links\"].extend(\n                [\n                    {\n                        \"rel\": \"aggregate\",\n                        \"type\": \"application/json\",\n                        \"title\": \"Aggregate\",\n                        \"href\": urljoin(base_url, \"aggregate\"),\n                    },\n                    {\n                        \"rel\": \"aggregations\",\n                        \"type\": \"application/json\",\n                        \"title\": \"Aggregations\",\n                        \"href\": urljoin(base_url, \"aggregations\"),\n                    },\n                ]\n            )\n\n        # Add OpenAPI URL\n        landing_page[\"links\"].append(\n            {\n                \"rel\": Relations.service_desc.value,\n                \"type\": MimeTypes.openapi.value,\n                \"title\": \"OpenAPI service description\",\n                \"href\": str(request.url_for(\"openapi\")),\n            }\n        )\n\n        # Add human readable service-doc\n        landing_page[\"links\"].append(\n            {\n                \"rel\": Relations.service_doc.value,\n                \"type\": MimeTypes.html.value,\n                \"title\": \"OpenAPI service documentation\",\n                \"href\": str(request.url_for(\"swagger_ui_html\")),\n            }\n        )\n\n        return stac.LandingPage(**landing_page)\n\n    def conformance(self, **kwargs) -&gt; stac.Conformance:\n        \"\"\"Conformance classes.\n\n        Called with `GET /conformance`.\n\n        Returns:\n            Conformance classes which the server conforms to.\n        \"\"\"\n        return stac.Conformance(conformsTo=self.conformance_classes())\n\n    @abc.abstractmethod\n    def post_search(\n        self, search_request: BaseSearchPostRequest, **kwargs\n    ) -&gt; stac.ItemCollection:\n        \"\"\"Cross catalog search (POST).\n\n        Called with `POST /search`.\n\n        Args:\n            search_request: search request parameters.\n\n        Returns:\n            ItemCollection containing items which match the search criteria.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def get_search(\n        self,\n        collections: Optional[List[str]] = None,\n        ids: Optional[List[str]] = None,\n        bbox: Optional[BBox] = None,\n        intersects: Optional[Geometry] = None,\n        datetime: Optional[str] = None,\n        limit: Optional[int] = 10,\n        **kwargs,\n    ) -&gt; stac.ItemCollection:\n        \"\"\"Cross catalog search (GET).\n\n        Called with `GET /search`.\n\n        Returns:\n            ItemCollection containing items which match the search criteria.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def get_item(self, item_id: str, collection_id: str, **kwargs) -&gt; stac.Item:\n        \"\"\"Get item by id.\n\n        Called with `GET /collections/{collection_id}/items/{item_id}`.\n\n        Args:\n            item_id: Id of the item.\n            collection_id: Id of the collection.\n\n        Returns:\n            Item.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def all_collections(self, **kwargs) -&gt; stac.Collections:\n        \"\"\"Get all available collections.\n\n        Called with `GET /collections`.\n\n        Returns:\n            A list of collections.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def get_collection(self, collection_id: str, **kwargs) -&gt; stac.Collection:\n        \"\"\"Get collection by id.\n\n        Called with `GET /collections/{collection_id}`.\n\n        Args:\n            collection_id: Id of the collection.\n\n        Returns:\n            Collection.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def item_collection(\n        self,\n        collection_id: str,\n        bbox: Optional[BBox] = None,\n        datetime: Optional[str] = None,\n        limit: int = 10,\n        token: Optional[str] = None,\n        **kwargs,\n    ) -&gt; stac.ItemCollection:\n        \"\"\"Get all items from a specific collection.\n\n        Called with `GET /collections/{collection_id}/items`\n\n        Args:\n            collection_id: id of the collection.\n            limit: number of items to return.\n            token: pagination token.\n\n        Returns:\n            An ItemCollection.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.all_collections","title":"all_collections  <code>abstractmethod</code>","text":"<pre><code>all_collections(**kwargs) -&gt; Collections\n</code></pre> <p>Get all available collections.</p> <p>Called with <code>GET /collections</code>.</p> <p>Returns:</p> <ul> <li> <code>Collections</code>           \u2013            <p>A list of collections.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\ndef all_collections(self, **kwargs) -&gt; stac.Collections:\n    \"\"\"Get all available collections.\n\n    Called with `GET /collections`.\n\n    Returns:\n        A list of collections.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.conformance","title":"conformance","text":"<pre><code>conformance(**kwargs) -&gt; Conformance\n</code></pre> <p>Conformance classes.</p> <p>Called with <code>GET /conformance</code>.</p> <p>Returns:</p> <ul> <li> <code>Conformance</code>           \u2013            <p>Conformance classes which the server conforms to.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>def conformance(self, **kwargs) -&gt; stac.Conformance:\n    \"\"\"Conformance classes.\n\n    Called with `GET /conformance`.\n\n    Returns:\n        Conformance classes which the server conforms to.\n    \"\"\"\n    return stac.Conformance(conformsTo=self.conformance_classes())\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.conformance_classes","title":"conformance_classes","text":"<pre><code>conformance_classes() -&gt; List[str]\n</code></pre> <p>Generate conformance classes by adding extension conformance to base conformance classes.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>def conformance_classes(self) -&gt; List[str]:\n    \"\"\"Generate conformance classes by adding extension conformance to base\n    conformance classes.\"\"\"\n    base_conformance_classes = self.base_conformance_classes.copy()\n\n    for extension in self.extensions:\n        extension_classes = getattr(extension, \"conformance_classes\", [])\n        base_conformance_classes.extend(extension_classes)\n\n    return sorted(list(set(base_conformance_classes)))\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.extension_is_enabled","title":"extension_is_enabled","text":"<pre><code>extension_is_enabled(extension: str) -&gt; bool\n</code></pre> <p>Check if an api extension is enabled.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>def extension_is_enabled(self, extension: str) -&gt; bool:\n    \"\"\"Check if an api extension is enabled.\"\"\"\n    return any([type(ext).__name__ == extension for ext in self.extensions])\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.get_collection","title":"get_collection  <code>abstractmethod</code>","text":"<pre><code>get_collection(collection_id: str, **kwargs) -&gt; Collection\n</code></pre> <p>Get collection by id.</p> <p>Called with <code>GET /collections/{collection_id}</code>.</p> <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>Id of the collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Collection</code>           \u2013            <p>Collection.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\ndef get_collection(self, collection_id: str, **kwargs) -&gt; stac.Collection:\n    \"\"\"Get collection by id.\n\n    Called with `GET /collections/{collection_id}`.\n\n    Args:\n        collection_id: Id of the collection.\n\n    Returns:\n        Collection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.get_item","title":"get_item  <code>abstractmethod</code>","text":"<pre><code>get_item(item_id: str, collection_id: str, **kwargs) -&gt; Item\n</code></pre> <p>Get item by id.</p> <p>Called with <code>GET /collections/{collection_id}/items/{item_id}</code>.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>str</code>)           \u2013            <p>Id of the item.</p> </li> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>Id of the collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>Item.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\ndef get_item(self, item_id: str, collection_id: str, **kwargs) -&gt; stac.Item:\n    \"\"\"Get item by id.\n\n    Called with `GET /collections/{collection_id}/items/{item_id}`.\n\n    Args:\n        item_id: Id of the item.\n        collection_id: Id of the collection.\n\n    Returns:\n        Item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.get_search","title":"get_search  <code>abstractmethod</code>","text":"<pre><code>get_search(\n    collections: Optional[List[str]] = None,\n    ids: Optional[List[str]] = None,\n    bbox: Optional[BBox] = None,\n    intersects: Optional[Geometry] = None,\n    datetime: Optional[str] = None,\n    limit: Optional[int] = 10,\n    **kwargs\n) -&gt; ItemCollection\n</code></pre> <p>Cross catalog search (GET).</p> <p>Called with <code>GET /search</code>.</p> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>ItemCollection containing items which match the search criteria.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\ndef get_search(\n    self,\n    collections: Optional[List[str]] = None,\n    ids: Optional[List[str]] = None,\n    bbox: Optional[BBox] = None,\n    intersects: Optional[Geometry] = None,\n    datetime: Optional[str] = None,\n    limit: Optional[int] = 10,\n    **kwargs,\n) -&gt; stac.ItemCollection:\n    \"\"\"Cross catalog search (GET).\n\n    Called with `GET /search`.\n\n    Returns:\n        ItemCollection containing items which match the search criteria.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.item_collection","title":"item_collection  <code>abstractmethod</code>","text":"<pre><code>item_collection(\n    collection_id: str,\n    bbox: Optional[BBox] = None,\n    datetime: Optional[str] = None,\n    limit: int = 10,\n    token: Optional[str] = None,\n    **kwargs\n) -&gt; ItemCollection\n</code></pre> <p>Get all items from a specific collection.</p> <p>Called with <code>GET /collections/{collection_id}/items</code></p> <p>Parameters:</p> <ul> <li> <code>collection_id</code>               (<code>str</code>)           \u2013            <p>id of the collection.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>number of items to return.</p> </li> <li> <code>token</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>pagination token.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>An ItemCollection.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\ndef item_collection(\n    self,\n    collection_id: str,\n    bbox: Optional[BBox] = None,\n    datetime: Optional[str] = None,\n    limit: int = 10,\n    token: Optional[str] = None,\n    **kwargs,\n) -&gt; stac.ItemCollection:\n    \"\"\"Get all items from a specific collection.\n\n    Called with `GET /collections/{collection_id}/items`\n\n    Args:\n        collection_id: id of the collection.\n        limit: number of items to return.\n        token: pagination token.\n\n    Returns:\n        An ItemCollection.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.landing_page","title":"landing_page","text":"<pre><code>landing_page(**kwargs) -&gt; LandingPage\n</code></pre> <p>Landing page.</p> <p>Called with <code>GET /</code>.</p> <p>Returns:</p> <ul> <li> <code>LandingPage</code>           \u2013            <p>API landing page, serving as an entry point to the API.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>def landing_page(self, **kwargs) -&gt; stac.LandingPage:\n    \"\"\"Landing page.\n\n    Called with `GET /`.\n\n    Returns:\n        API landing page, serving as an entry point to the API.\n    \"\"\"\n    request: Request = kwargs[\"request\"]\n    base_url = get_base_url(request)\n\n    landing_page = self._landing_page(\n        base_url=base_url,\n        conformance_classes=self.conformance_classes(),\n        extension_schemas=[],\n    )\n\n    # Add Queryables link\n    if self.extension_is_enabled(\"FilterExtension\") or self.extension_is_enabled(\n        \"SearchFilterExtension\"\n    ):\n        landing_page[\"links\"].append(\n            {\n                \"rel\": Relations.queryables.value,\n                \"type\": MimeTypes.jsonschema.value,\n                \"title\": \"Queryables available for this Catalog\",\n                \"href\": urljoin(base_url, \"queryables\"),\n            }\n        )\n\n    # Add Aggregation links\n    if self.extension_is_enabled(\"AggregationExtension\"):\n        landing_page[\"links\"].extend(\n            [\n                {\n                    \"rel\": \"aggregate\",\n                    \"type\": \"application/json\",\n                    \"title\": \"Aggregate\",\n                    \"href\": urljoin(base_url, \"aggregate\"),\n                },\n                {\n                    \"rel\": \"aggregations\",\n                    \"type\": \"application/json\",\n                    \"title\": \"Aggregations\",\n                    \"href\": urljoin(base_url, \"aggregations\"),\n                },\n            ]\n        )\n\n    # Add OpenAPI URL\n    landing_page[\"links\"].append(\n        {\n            \"rel\": Relations.service_desc.value,\n            \"type\": MimeTypes.openapi.value,\n            \"title\": \"OpenAPI service description\",\n            \"href\": str(request.url_for(\"openapi\")),\n        }\n    )\n\n    # Add human readable service-doc\n    landing_page[\"links\"].append(\n        {\n            \"rel\": Relations.service_doc.value,\n            \"type\": MimeTypes.html.value,\n            \"title\": \"OpenAPI service documentation\",\n            \"href\": str(request.url_for(\"swagger_ui_html\")),\n        }\n    )\n\n    return stac.LandingPage(**landing_page)\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.list_conformance_classes","title":"list_conformance_classes","text":"<pre><code>list_conformance_classes()\n</code></pre> <p>Return a list of conformance classes, including implemented extensions.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>def list_conformance_classes(self):\n    \"\"\"Return a list of conformance classes, including implemented extensions.\"\"\"\n    base_conformance = BASE_CONFORMANCE_CLASSES\n\n    for extension in self.extensions:\n        extension_classes = getattr(extension, \"conformance_classes\", [])\n        base_conformance.extend(extension_classes)\n\n    return base_conformance\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.BaseCoreClient.post_search","title":"post_search  <code>abstractmethod</code>","text":"<pre><code>post_search(search_request: BaseSearchPostRequest, **kwargs) -&gt; ItemCollection\n</code></pre> <p>Cross catalog search (POST).</p> <p>Called with <code>POST /search</code>.</p> <p>Parameters:</p> <ul> <li> <code>search_request</code>               (<code>BaseSearchPostRequest</code>)           \u2013            <p>search request parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>ItemCollection containing items which match the search criteria.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@abc.abstractmethod\ndef post_search(\n    self, search_request: BaseSearchPostRequest, **kwargs\n) -&gt; stac.ItemCollection:\n    \"\"\"Cross catalog search (POST).\n\n    Called with `POST /search`.\n\n    Args:\n        search_request: search request parameters.\n\n    Returns:\n        ItemCollection containing items which match the search criteria.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/stac_fastapi/types/core/#stac_fastapi.types.core.LandingPageMixin","title":"LandingPageMixin","text":"<p>               Bases: <code>ABC</code></p> <p>Create a STAC landing page (GET /).</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/core.py</code> <pre><code>@attr.s\nclass LandingPageMixin(abc.ABC):\n    \"\"\"Create a STAC landing page (GET /).\"\"\"\n\n    stac_version: str = attr.ib(default=STAC_VERSION)\n    landing_page_id: str = attr.ib(default=api_settings.stac_fastapi_landing_id)\n    title: str = attr.ib(default=api_settings.stac_fastapi_title)\n    description: str = attr.ib(default=api_settings.stac_fastapi_description)\n\n    def _landing_page(\n        self,\n        base_url: str,\n        conformance_classes: List[str],\n        extension_schemas: List[str],\n    ) -&gt; stac.LandingPage:\n        landing_page = stac.LandingPage(\n            type=\"Catalog\",\n            id=self.landing_page_id,\n            title=self.title,\n            description=self.description,\n            stac_version=self.stac_version,\n            conformsTo=conformance_classes,\n            links=[\n                {\n                    \"rel\": Relations.self.value,\n                    \"type\": MimeTypes.json.value,\n                    \"title\": \"This document\",\n                    \"href\": base_url,\n                },\n                {\n                    \"rel\": Relations.root.value,\n                    \"type\": MimeTypes.json.value,\n                    \"title\": \"Root\",\n                    \"href\": base_url,\n                },\n                {\n                    \"rel\": Relations.data.value,\n                    \"type\": MimeTypes.json.value,\n                    \"title\": \"Collections available for this Catalog\",\n                    \"href\": urljoin(base_url, \"collections\"),\n                },\n                {\n                    \"rel\": Relations.conformance.value,\n                    \"type\": MimeTypes.json.value,\n                    \"title\": \"STAC/OGC conformance classes implemented by this server\",\n                    \"href\": urljoin(base_url, \"conformance\"),\n                },\n                {\n                    \"rel\": Relations.search.value,\n                    \"type\": MimeTypes.geojson.value,\n                    \"title\": \"STAC search [GET]\",\n                    \"href\": urljoin(base_url, \"search\"),\n                    \"method\": \"GET\",\n                },\n                {\n                    \"rel\": Relations.search.value,\n                    \"type\": MimeTypes.geojson.value,\n                    \"title\": \"STAC search [POST]\",\n                    \"href\": urljoin(base_url, \"search\"),\n                    \"method\": \"POST\",\n                },\n            ],\n            stac_extensions=extension_schemas,\n        )\n\n        return landing_page\n</code></pre>"},{"location":"api/stac_fastapi/types/errors/","title":"errors","text":""},{"location":"api/stac_fastapi/types/errors/#stac_fastapi.types.errors","title":"stac_fastapi.types.errors","text":"<p>stac_fastapi.types.errors module.</p>"},{"location":"api/stac_fastapi/types/errors/#stac_fastapi.types.errors.ConflictError","title":"ConflictError","text":"<p>               Bases: <code>StacApiError</code></p> <p>Database conflict.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/errors.py</code> <pre><code>class ConflictError(StacApiError):\n    \"\"\"Database conflict.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/types/errors/#stac_fastapi.types.errors.DatabaseError","title":"DatabaseError","text":"<p>               Bases: <code>StacApiError</code></p> <p>Generic database errors.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/errors.py</code> <pre><code>class DatabaseError(StacApiError):\n    \"\"\"Generic database errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/types/errors/#stac_fastapi.types.errors.ForeignKeyError","title":"ForeignKeyError","text":"<p>               Bases: <code>StacApiError</code></p> <p>Foreign key error (collection does not exist).</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/errors.py</code> <pre><code>class ForeignKeyError(StacApiError):\n    \"\"\"Foreign key error (collection does not exist).\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/types/errors/#stac_fastapi.types.errors.InvalidQueryParameter","title":"InvalidQueryParameter","text":"<p>               Bases: <code>StacApiError</code></p> <p>Error for unknown or invalid query parameters.</p> <p>Used to capture errors that should respond according to docs.opengeospatial.org/is/17-069r3/17-069r3.html#query_parameters</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/errors.py</code> <pre><code>class InvalidQueryParameter(StacApiError):\n    \"\"\"Error for unknown or invalid query parameters.\n\n    Used to capture errors that should respond according to\n    http://docs.opengeospatial.org/is/17-069r3/17-069r3.html#query_parameters\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/types/errors/#stac_fastapi.types.errors.NotFoundError","title":"NotFoundError","text":"<p>               Bases: <code>StacApiError</code></p> <p>Resource not found.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/errors.py</code> <pre><code>class NotFoundError(StacApiError):\n    \"\"\"Resource not found.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/types/errors/#stac_fastapi.types.errors.StacApiError","title":"StacApiError","text":"<p>               Bases: <code>Exception</code></p> <p>Generic API error.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/errors.py</code> <pre><code>class StacApiError(Exception):\n    \"\"\"Generic API error.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/types/extension/","title":"extension","text":""},{"location":"api/stac_fastapi/types/extension/#stac_fastapi.types.extension","title":"stac_fastapi.types.extension","text":"<p>Base api extension.</p>"},{"location":"api/stac_fastapi/types/extension/#stac_fastapi.types.extension.ApiExtension","title":"ApiExtension","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for defining API extensions.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/extension.py</code> <pre><code>@attr.s\nclass ApiExtension(abc.ABC):\n    \"\"\"Abstract base class for defining API extensions.\"\"\"\n\n    GET: Optional[Type[APIRequest]] = None\n    POST: Optional[Type[BaseModel]] = None\n\n    def get_request_model(\n        self, verb: str = \"GET\"\n    ) -&gt; Optional[Union[Type[BaseModel], Type[APIRequest]]]:\n        \"\"\"Return the request model for the extension.method.\n\n        The model can differ based on HTTP verb\n        \"\"\"\n        return getattr(self, verb)\n\n    conformance_classes: List[str] = attr.ib(factory=list)\n    schema_href: Optional[str] = attr.ib(default=None)\n\n    @abc.abstractmethod\n    def register(self, app: FastAPI) -&gt; None:\n        \"\"\"Register the extension with a FastAPI application.\n\n        Args:\n            app: target FastAPI application.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/stac_fastapi/types/extension/#stac_fastapi.types.extension.ApiExtension.get_request_model","title":"get_request_model","text":"<pre><code>get_request_model(verb: str = 'GET') -&gt; Optional[Union[Type[BaseModel], Type[APIRequest]]]\n</code></pre> <p>Return the request model for the extension.method.</p> <p>The model can differ based on HTTP verb</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/extension.py</code> <pre><code>def get_request_model(\n    self, verb: str = \"GET\"\n) -&gt; Optional[Union[Type[BaseModel], Type[APIRequest]]]:\n    \"\"\"Return the request model for the extension.method.\n\n    The model can differ based on HTTP verb\n    \"\"\"\n    return getattr(self, verb)\n</code></pre>"},{"location":"api/stac_fastapi/types/extension/#stac_fastapi.types.extension.ApiExtension.register","title":"register  <code>abstractmethod</code>","text":"<pre><code>register(app: FastAPI) -&gt; None\n</code></pre> <p>Register the extension with a FastAPI application.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>target FastAPI application.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/extension.py</code> <pre><code>@abc.abstractmethod\ndef register(self, app: FastAPI) -&gt; None:\n    \"\"\"Register the extension with a FastAPI application.\n\n    Args:\n        app: target FastAPI application.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/stac_fastapi/types/links/","title":"links","text":""},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links","title":"stac_fastapi.types.links","text":"<p>Link helpers.</p>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.BaseLinks","title":"BaseLinks","text":"<p>Create inferred links common to collections and items.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>@attr.s\nclass BaseLinks:\n    \"\"\"Create inferred links common to collections and items.\"\"\"\n\n    collection_id: str = attr.ib()\n    base_url: str = attr.ib()\n\n    def root(self) -&gt; Dict[str, Any]:\n        \"\"\"Return the catalog root.\"\"\"\n        return dict(rel=Relations.root, type=MimeTypes.json, href=self.base_url)\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.BaseLinks.root","title":"root","text":"<pre><code>root() -&gt; Dict[str, Any]\n</code></pre> <p>Return the catalog root.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def root(self) -&gt; Dict[str, Any]:\n    \"\"\"Return the catalog root.\"\"\"\n    return dict(rel=Relations.root, type=MimeTypes.json, href=self.base_url)\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.CollectionLinks","title":"CollectionLinks","text":"<p>               Bases: <code>BaseLinks</code></p> <p>Create inferred links specific to collections.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>@attr.s\nclass CollectionLinks(BaseLinks):\n    \"\"\"Create inferred links specific to collections.\"\"\"\n\n    def self(self) -&gt; Dict[str, Any]:\n        \"\"\"Create the `self` link.\"\"\"\n        return dict(\n            rel=Relations.self,\n            type=MimeTypes.json,\n            href=urljoin(self.base_url, f\"collections/{self.collection_id}\"),\n        )\n\n    def parent(self) -&gt; Dict[str, Any]:\n        \"\"\"Create the `parent` link.\"\"\"\n        return dict(rel=Relations.parent, type=MimeTypes.json, href=self.base_url)\n\n    def items(self) -&gt; Dict[str, Any]:\n        \"\"\"Create the `items` link.\"\"\"\n        return dict(\n            rel=\"items\",\n            type=MimeTypes.geojson,\n            href=urljoin(self.base_url, f\"collections/{self.collection_id}/items\"),\n        )\n\n    def create_links(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Return all inferred links.\"\"\"\n        return [self.self(), self.parent(), self.items(), self.root()]\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.CollectionLinks.create_links","title":"create_links","text":"<pre><code>create_links() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Return all inferred links.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def create_links(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return all inferred links.\"\"\"\n    return [self.self(), self.parent(), self.items(), self.root()]\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.CollectionLinks.items","title":"items","text":"<pre><code>items() -&gt; Dict[str, Any]\n</code></pre> <p>Create the <code>items</code> link.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def items(self) -&gt; Dict[str, Any]:\n    \"\"\"Create the `items` link.\"\"\"\n    return dict(\n        rel=\"items\",\n        type=MimeTypes.geojson,\n        href=urljoin(self.base_url, f\"collections/{self.collection_id}/items\"),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.CollectionLinks.parent","title":"parent","text":"<pre><code>parent() -&gt; Dict[str, Any]\n</code></pre> <p>Create the <code>parent</code> link.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def parent(self) -&gt; Dict[str, Any]:\n    \"\"\"Create the `parent` link.\"\"\"\n    return dict(rel=Relations.parent, type=MimeTypes.json, href=self.base_url)\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.CollectionLinks.self","title":"self","text":"<pre><code>self() -&gt; Dict[str, Any]\n</code></pre> <p>Create the <code>self</code> link.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def self(self) -&gt; Dict[str, Any]:\n    \"\"\"Create the `self` link.\"\"\"\n    return dict(\n        rel=Relations.self,\n        type=MimeTypes.json,\n        href=urljoin(self.base_url, f\"collections/{self.collection_id}\"),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.ItemLinks","title":"ItemLinks","text":"<p>               Bases: <code>BaseLinks</code></p> <p>Create inferred links specific to items.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>@attr.s\nclass ItemLinks(BaseLinks):\n    \"\"\"Create inferred links specific to items.\"\"\"\n\n    item_id: str = attr.ib()\n\n    def self(self) -&gt; Dict[str, Any]:\n        \"\"\"Create the `self` link.\"\"\"\n        return dict(\n            rel=Relations.self,\n            type=MimeTypes.geojson,\n            href=urljoin(\n                self.base_url,\n                f\"collections/{self.collection_id}/items/{self.item_id}\",\n            ),\n        )\n\n    def parent(self) -&gt; Dict[str, Any]:\n        \"\"\"Create the `parent` link.\"\"\"\n        return dict(\n            rel=Relations.parent,\n            type=MimeTypes.json,\n            href=urljoin(self.base_url, f\"collections/{self.collection_id}\"),\n        )\n\n    def collection(self) -&gt; Dict[str, Any]:\n        \"\"\"Create the `collection` link.\"\"\"\n        return dict(\n            rel=Relations.collection,\n            type=MimeTypes.json,\n            href=urljoin(self.base_url, f\"collections/{self.collection_id}\"),\n        )\n\n    def create_links(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Return all inferred links.\"\"\"\n        links = [\n            self.self(),\n            self.parent(),\n            self.collection(),\n            self.root(),\n        ]\n        return links\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.ItemLinks.collection","title":"collection","text":"<pre><code>collection() -&gt; Dict[str, Any]\n</code></pre> <p>Create the <code>collection</code> link.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def collection(self) -&gt; Dict[str, Any]:\n    \"\"\"Create the `collection` link.\"\"\"\n    return dict(\n        rel=Relations.collection,\n        type=MimeTypes.json,\n        href=urljoin(self.base_url, f\"collections/{self.collection_id}\"),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.ItemLinks.create_links","title":"create_links","text":"<pre><code>create_links() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Return all inferred links.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def create_links(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return all inferred links.\"\"\"\n    links = [\n        self.self(),\n        self.parent(),\n        self.collection(),\n        self.root(),\n    ]\n    return links\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.ItemLinks.parent","title":"parent","text":"<pre><code>parent() -&gt; Dict[str, Any]\n</code></pre> <p>Create the <code>parent</code> link.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def parent(self) -&gt; Dict[str, Any]:\n    \"\"\"Create the `parent` link.\"\"\"\n    return dict(\n        rel=Relations.parent,\n        type=MimeTypes.json,\n        href=urljoin(self.base_url, f\"collections/{self.collection_id}\"),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.ItemLinks.self","title":"self","text":"<pre><code>self() -&gt; Dict[str, Any]\n</code></pre> <p>Create the <code>self</code> link.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def self(self) -&gt; Dict[str, Any]:\n    \"\"\"Create the `self` link.\"\"\"\n    return dict(\n        rel=Relations.self,\n        type=MimeTypes.geojson,\n        href=urljoin(\n            self.base_url,\n            f\"collections/{self.collection_id}/items/{self.item_id}\",\n        ),\n    )\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.filter_links","title":"filter_links","text":"<pre><code>filter_links(links: List[Dict]) -&gt; List[Dict]\n</code></pre> <p>Remove inferred links.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def filter_links(links: List[Dict]) -&gt; List[Dict]:\n    \"\"\"Remove inferred links.\"\"\"\n    return [link for link in links if link[\"rel\"] not in INFERRED_LINK_RELS]\n</code></pre>"},{"location":"api/stac_fastapi/types/links/#stac_fastapi.types.links.resolve_links","title":"resolve_links","text":"<pre><code>resolve_links(links: list, base_url: str) -&gt; List[Dict]\n</code></pre> <p>Convert relative links to absolute links.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/links.py</code> <pre><code>def resolve_links(links: list, base_url: str) -&gt; List[Dict]:\n    \"\"\"Convert relative links to absolute links.\"\"\"\n    filtered_links = filter_links(links)\n    for link in filtered_links:\n        link.update({\"href\": urljoin(base_url, link[\"href\"])})\n    return filtered_links\n</code></pre>"},{"location":"api/stac_fastapi/types/requests/","title":"requests","text":""},{"location":"api/stac_fastapi/types/requests/#stac_fastapi.types.requests","title":"stac_fastapi.types.requests","text":"<p>Requests helpers.</p>"},{"location":"api/stac_fastapi/types/requests/#stac_fastapi.types.requests.get_base_url","title":"get_base_url","text":"<pre><code>get_base_url(request: Request) -&gt; str\n</code></pre> <p>Get base URL with respect of APIRouter prefix.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/requests.py</code> <pre><code>def get_base_url(request: Request) -&gt; str:\n    \"\"\"Get base URL with respect of APIRouter prefix.\"\"\"\n    app = request.app\n    if not app.state.router_prefix:\n        return str(request.base_url)\n    else:\n        return \"{}{}/\".format(str(request.base_url), app.state.router_prefix.lstrip(\"/\"))\n</code></pre>"},{"location":"api/stac_fastapi/types/rfc3339/","title":"rfc3339","text":""},{"location":"api/stac_fastapi/types/rfc3339/#stac_fastapi.types.rfc3339","title":"stac_fastapi.types.rfc3339","text":"<p>rfc3339.</p>"},{"location":"api/stac_fastapi/types/rfc3339/#stac_fastapi.types.rfc3339.datetime_to_str","title":"datetime_to_str","text":"<pre><code>datetime_to_str(dt: datetime, timespec: str = 'auto') -&gt; str\n</code></pre> <p>Converts a :class:<code>datetime.datetime</code> instance to an ISO8601 string in the <code>RFC 3339, section 5.6 &lt;https://datatracker.ietf.org/doc/html/rfc3339#section-5.6&gt;</code>__ format required by the :stac-spec:<code>STAC Spec &lt;master/item-spec/common-metadata.md#date-and-time&gt;</code>.</p> <p>Parameters:</p> <ul> <li> <code>dt </code>           \u2013            <p>The datetime to convert.</p> </li> <li> <code>timespec</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>An optional argument that specifies the number of additional terms of the time to include. Valid options are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds' and 'microseconds'. The default value is 'auto'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The ISO8601 (RFC 3339) formatted string representing the datetime.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/rfc3339.py</code> <pre><code>def datetime_to_str(dt: datetime, timespec: str = \"auto\") -&gt; str:\n    \"\"\"Converts a :class:`datetime.datetime` instance to an ISO8601 string in the\n    `RFC 3339, section 5.6\n    &lt;https://datatracker.ietf.org/doc/html/rfc3339#section-5.6&gt;`__ format required by\n    the :stac-spec:`STAC Spec &lt;master/item-spec/common-metadata.md#date-and-time&gt;`.\n\n    Args:\n        dt : The datetime to convert.\n        timespec: An optional argument that specifies the number of additional\n            terms of the time to include. Valid options are 'auto', 'hours',\n            'minutes', 'seconds', 'milliseconds' and 'microseconds'. The default value\n            is 'auto'.\n\n    Returns:\n        str: The ISO8601 (RFC 3339) formatted string representing the datetime.\n    \"\"\"\n    if dt.tzinfo is None:\n        dt = dt.replace(tzinfo=timezone.utc)\n\n    timestamp = dt.isoformat(timespec=timespec)\n    zulu = \"+00:00\"\n    if timestamp.endswith(zulu):\n        timestamp = f\"{timestamp[: -len(zulu)]}Z\"\n\n    return timestamp\n</code></pre>"},{"location":"api/stac_fastapi/types/rfc3339/#stac_fastapi.types.rfc3339.now_in_utc","title":"now_in_utc","text":"<pre><code>now_in_utc() -&gt; datetime\n</code></pre> <p>Return a datetime value of now with the UTC timezone applied.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/rfc3339.py</code> <pre><code>def now_in_utc() -&gt; datetime:\n    \"\"\"Return a datetime value of now with the UTC timezone applied.\"\"\"\n    return datetime.now(timezone.utc)\n</code></pre>"},{"location":"api/stac_fastapi/types/rfc3339/#stac_fastapi.types.rfc3339.now_to_rfc3339_str","title":"now_to_rfc3339_str","text":"<pre><code>now_to_rfc3339_str() -&gt; str\n</code></pre> <p>Return an RFC 3339 string representing now.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/rfc3339.py</code> <pre><code>def now_to_rfc3339_str() -&gt; str:\n    \"\"\"Return an RFC 3339 string representing now.\"\"\"\n    return datetime_to_str(now_in_utc())\n</code></pre>"},{"location":"api/stac_fastapi/types/rfc3339/#stac_fastapi.types.rfc3339.parse_single_date","title":"parse_single_date","text":"<pre><code>parse_single_date(date_str: str) -&gt; datetime\n</code></pre> <p>Parse a single RFC3339 date string into a datetime object.</p> <p>Parameters:</p> <ul> <li> <code>date_str</code>               (<code>str</code>)           \u2013            <p>A string representing the date in RFC3339 format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>datetime</code> (              <code>datetime</code> )          \u2013            <p>A datetime object parsed from the date_str.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the date_str is empty or contains the placeholder '..'.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/rfc3339.py</code> <pre><code>def parse_single_date(date_str: str) -&gt; datetime:\n    \"\"\"\n    Parse a single RFC3339 date string into a datetime object.\n\n    Args:\n        date_str (str): A string representing the date in RFC3339 format.\n\n    Returns:\n        datetime: A datetime object parsed from the date_str.\n\n    Raises:\n        ValueError: If the date_str is empty or contains the placeholder '..'.\n    \"\"\"\n    if \"..\" in date_str or not date_str:\n        raise ValueError(\"Invalid date format.\")\n    return rfc3339_str_to_datetime(date_str)\n</code></pre>"},{"location":"api/stac_fastapi/types/rfc3339/#stac_fastapi.types.rfc3339.rfc3339_str_to_datetime","title":"rfc3339_str_to_datetime","text":"<pre><code>rfc3339_str_to_datetime(s: str) -&gt; datetime\n</code></pre> <p>Convert a string conforming to RFC 3339 to a :class:<code>datetime.datetime</code>.</p> <p>Uses :meth:<code>iso8601.parse_date</code> under the hood.</p> <p>Parameters:</p> <ul> <li> <code>s (str) </code>           \u2013            <p>The string to convert to :class:<code>datetime.datetime</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>datetime</code> )          \u2013            <p>The datetime represented by the ISO8601 (RFC 3339) formatted string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string is not a valid RFC 3339 string.</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/rfc3339.py</code> <pre><code>def rfc3339_str_to_datetime(s: str) -&gt; datetime:\n    \"\"\"Convert a string conforming to RFC 3339 to a :class:`datetime.datetime`.\n\n    Uses :meth:`iso8601.parse_date` under the hood.\n\n    Args:\n        s (str) : The string to convert to :class:`datetime.datetime`.\n\n    Returns:\n        str: The datetime represented by the ISO8601 (RFC 3339) formatted string.\n\n    Raises:\n        ValueError: If the string is not a valid RFC 3339 string.\n    \"\"\"\n    # Uppercase the string\n    s = s.upper()\n\n    # Match against RFC3339 regex.\n    result = re.match(RFC33339_PATTERN, s)\n    if not result:\n        raise ValueError(\"Invalid RFC3339 datetime.\")\n\n    # Parse with pyiso8601\n    return iso8601.parse_date(s)\n</code></pre>"},{"location":"api/stac_fastapi/types/rfc3339/#stac_fastapi.types.rfc3339.str_to_interval","title":"str_to_interval","text":"<pre><code>str_to_interval(interval: Optional[str]) -&gt; Optional[DateTimeType]\n</code></pre> <p>Extract a single datetime object or a tuple of datetime objects from an interval string defined by the OGC API. The interval can either be a single datetime or a range with start and end datetime.</p> <p>Parameters:</p> <ul> <li> <code>interval</code>               (<code>Optional[str]</code>)           \u2013            <p>The interval string to convert to datetime objects,</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[DateTimeType]</code>           \u2013            <p>Optional[DateTimeType]: A single datetime.datetime object, a tuple of</p> </li> <li> <code>Optional[DateTimeType]</code>           \u2013            <p>datetime.datetime objects, or None if input is None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the string is not valid for various reasons such as being empty,</p> </li> </ul> Source code in <code>stac_fastapi/types/stac_fastapi/types/rfc3339.py</code> <pre><code>def str_to_interval(interval: Optional[str]) -&gt; Optional[DateTimeType]:\n    \"\"\"\n    Extract a single datetime object or a tuple of datetime objects from an\n    interval string defined by the OGC API. The interval can either be a\n    single datetime or a range with start and end datetime.\n\n    Args:\n        interval (Optional[str]): The interval string to convert to datetime objects,\n        or None if no datetime is specified.\n\n    Returns:\n        Optional[DateTimeType]: A single datetime.datetime object, a tuple of\n        datetime.datetime objects, or None if input is None.\n\n    Raises:\n        HTTPException: If the string is not valid for various reasons such as being empty,\n        having more than one slash, or if date formats are invalid.\n    \"\"\"\n    if interval is None:\n        return None\n\n    if not interval:\n        raise HTTPException(status_code=400, detail=\"Empty interval string is invalid.\")\n\n    values = interval.split(\"/\")\n    if len(values) &gt; 2:\n        raise HTTPException(\n            status_code=400,\n            detail=\"Interval string contains more than one forward slash.\",\n        )\n\n    try:\n        start = parse_single_date(values[0]) if values[0] not in [\"..\", \"\"] else None\n        if len(values) == 1:\n            return start\n\n        end = (\n            parse_single_date(values[1])\n            if len(values) &gt; 1 and values[1] not in [\"..\", \"\"]\n            else None\n        )\n    except (ValueError, iso8601.ParseError) as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n    if start is None and end is None:\n        raise HTTPException(\n            status_code=400, detail=\"Double open-ended intervals are not allowed.\"\n        )\n\n    if start is not None and end is not None and start &gt; end:\n        raise HTTPException(\n            status_code=400, detail=\"Start datetime cannot be before end datetime.\"\n        )\n\n    return start, end  # type: ignore\n</code></pre>"},{"location":"api/stac_fastapi/types/search/","title":"search","text":""},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search","title":"stac_fastapi.types.search","text":"<p>stac_fastapi.types.search module.</p>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.APIRequest","title":"APIRequest","text":"<p>Generic API Request base class.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>@attr.s\nclass APIRequest:\n    \"\"\"Generic API Request base class.\"\"\"\n\n    def kwargs(self) -&gt; Dict:\n        \"\"\"Transform api request params into format which matches the signature of the\n        endpoint.\"\"\"\n        return self.__dict__\n</code></pre>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.APIRequest.kwargs","title":"kwargs","text":"<pre><code>kwargs() -&gt; Dict\n</code></pre> <p>Transform api request params into format which matches the signature of the endpoint.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>def kwargs(self) -&gt; Dict:\n    \"\"\"Transform api request params into format which matches the signature of the\n    endpoint.\"\"\"\n    return self.__dict__\n</code></pre>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.BaseSearchGetRequest","title":"BaseSearchGetRequest","text":"<p>               Bases: <code>APIRequest</code>, <code>DatetimeMixin</code></p> <p>Base arguments for GET Request.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>@attr.s\nclass BaseSearchGetRequest(APIRequest, DatetimeMixin):\n    \"\"\"Base arguments for GET Request.\"\"\"\n\n    collections: Optional[List[str]] = attr.ib(\n        default=None, converter=_collection_converter\n    )\n    ids: Optional[List[str]] = attr.ib(default=None, converter=_ids_converter)\n    bbox: Optional[BBox] = attr.ib(default=None, converter=_bbox_converter)\n    intersects: Annotated[\n        Optional[str],\n        Query(\n            description=\"\"\"Only return items intersecting this GeoJSON Geometry. Mutually exclusive with **bbox**. \\n\n*Remember to URL encode the GeoJSON geometry when using GET request*.\"\"\",  # noqa: E501\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"madrid\": {\n                    \"value\": {\n                        \"type\": \"Feature\",\n                        \"properties\": {},\n                        \"geometry\": {\n                            \"coordinates\": [\n                                [\n                                    [-3.8549260500072933, 40.54923557897152],\n                                    [-3.8549260500072933, 40.29428000041938],\n                                    [-3.516597069715033, 40.29428000041938],\n                                    [-3.516597069715033, 40.54923557897152],\n                                    [-3.8549260500072933, 40.54923557897152],\n                                ]\n                            ],\n                            \"type\": \"Polygon\",\n                        },\n                    },\n                },\n                \"new-york\": {\n                    \"value\": {\n                        \"type\": \"Feature\",\n                        \"properties\": {},\n                        \"geometry\": {\n                            \"coordinates\": [\n                                [\n                                    [-74.50117532354284, 41.128266394414055],\n                                    [-74.50117532354284, 40.35633909727355],\n                                    [-73.46713183168603, 40.35633909727355],\n                                    [-73.46713183168603, 41.128266394414055],\n                                    [-74.50117532354284, 41.128266394414055],\n                                ]\n                            ],\n                            \"type\": \"Polygon\",\n                        },\n                    },\n                },\n            },\n        ),\n    ] = attr.ib(default=None)\n    datetime: DateTimeQueryType = attr.ib(default=None, validator=_validate_datetime)\n    limit: Annotated[\n        Optional[Limit],\n        Query(\n            description=\"Limits the number of results that are included in each page of the response (capped to 10_000).\"  # noqa: E501\n        ),\n    ] = attr.ib(default=10)\n</code></pre>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.BaseSearchPostRequest","title":"BaseSearchPostRequest","text":"<p>               Bases: <code>Search</code></p> <p>Base arguments for POST Request.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>class BaseSearchPostRequest(Search):\n    \"\"\"Base arguments for POST Request.\"\"\"\n\n    limit: Optional[Limit] = Field(\n        10,\n        description=\"Limits the number of results that are included in each page of the response (capped to 10_000).\",  # noqa: E501\n    )\n</code></pre>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.DatetimeMixin","title":"DatetimeMixin","text":"<p>Datetime Mixin.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>@attr.s\nclass DatetimeMixin:\n    \"\"\"Datetime Mixin.\"\"\"\n\n    datetime: DateTimeQueryType = attr.ib(default=None, validator=_validate_datetime)\n\n    def parse_datetime(self) -&gt; Optional[DateTimeType]:\n        \"\"\"Return Datetime objects.\"\"\"\n        return str_to_interval(self.datetime)\n\n    @property\n    def start_date(self) -&gt; Optional[dt]:\n        \"\"\"Start Date.\"\"\"\n        parsed = self.parse_datetime()\n        if parsed is None:\n            return None\n\n        return parsed[0] if isinstance(parsed, tuple) else parsed\n\n    @property\n    def end_date(self) -&gt; Optional[dt]:\n        \"\"\"End Date.\"\"\"\n        parsed = self.parse_datetime()\n        if parsed is None:\n            return None\n\n        return parsed[1] if isinstance(parsed, tuple) else None\n</code></pre>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.DatetimeMixin.end_date","title":"end_date  <code>property</code>","text":"<pre><code>end_date: Optional[datetime]\n</code></pre> <p>End Date.</p>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.DatetimeMixin.start_date","title":"start_date  <code>property</code>","text":"<pre><code>start_date: Optional[datetime]\n</code></pre> <p>Start Date.</p>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.DatetimeMixin.parse_datetime","title":"parse_datetime","text":"<pre><code>parse_datetime() -&gt; Optional[DateTimeType]\n</code></pre> <p>Return Datetime objects.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>def parse_datetime(self) -&gt; Optional[DateTimeType]:\n    \"\"\"Return Datetime objects.\"\"\"\n    return str_to_interval(self.datetime)\n</code></pre>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.crop","title":"crop","text":"<pre><code>crop(v: PositiveInt) -&gt; PositiveInt\n</code></pre> <p>Crop value to 10,000.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>def crop(v: PositiveInt) -&gt; PositiveInt:\n    \"\"\"Crop value to 10,000.\"\"\"\n    limit = 10_000\n    if v &gt; limit:\n        v = limit\n    return v\n</code></pre>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.str2bbox","title":"str2bbox","text":"<pre><code>str2bbox(x: str) -&gt; Optional[BBox]\n</code></pre> <p>Convert string to BBox based on , delimiter.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>def str2bbox(x: str) -&gt; Optional[BBox]:\n    \"\"\"Convert string to BBox based on , delimiter.\"\"\"\n    if x:\n        try:\n            t = tuple(float(v) for v in x.split(\",\"))\n        except ValueError:\n            raise HTTPException(status_code=400, detail=f\"invalid bbox: {x}\")\n\n        if len(t) not in (4, 6):\n            raise HTTPException(\n                status_code=400, detail=f\"BBox '{x}' must have 4 or 6 values.\"\n            )\n\n        return cast(BBox, t)\n\n    return None\n</code></pre>"},{"location":"api/stac_fastapi/types/search/#stac_fastapi.types.search.str2list","title":"str2list","text":"<pre><code>str2list(x: Optional[str]) -&gt; Optional[List[str]]\n</code></pre> <p>Convert string to list base on , delimiter.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/search.py</code> <pre><code>def str2list(x: Optional[str]) -&gt; Optional[List[str]]:\n    \"\"\"Convert string to list base on , delimiter.\"\"\"\n    if x:\n        return x.split(\",\")\n\n    return None\n</code></pre>"},{"location":"api/stac_fastapi/types/stac/","title":"stac","text":""},{"location":"api/stac_fastapi/types/stac/#stac_fastapi.types.stac","title":"stac_fastapi.types.stac","text":"<p>STAC types.</p>"},{"location":"api/stac_fastapi/types/stac/#stac_fastapi.types.stac.Catalog","title":"Catalog","text":"<p>               Bases: <code>TypedDict</code></p> <p>STAC Catalog.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/stac.py</code> <pre><code>class Catalog(TypedDict):\n    \"\"\"STAC Catalog.\"\"\"\n\n    type: str\n    stac_version: str\n    stac_extensions: NotRequired[List[str]]\n    id: str\n    title: NotRequired[str]\n    description: str\n    links: List[Dict[str, Any]]\n</code></pre>"},{"location":"api/stac_fastapi/types/stac/#stac_fastapi.types.stac.Collection","title":"Collection","text":"<p>               Bases: <code>Catalog</code></p> <p>STAC Collection.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/stac.py</code> <pre><code>class Collection(Catalog):\n    \"\"\"STAC Collection.\"\"\"\n\n    keywords: List[str]\n    license: str\n    providers: List[Dict[str, Any]]\n    extent: Dict[str, Any]\n    summaries: Dict[str, Any]\n    assets: Dict[str, Any]\n</code></pre>"},{"location":"api/stac_fastapi/types/stac/#stac_fastapi.types.stac.Collections","title":"Collections","text":"<p>               Bases: <code>TypedDict</code></p> <p>All collections endpoint. github.com/radiantearth/stac-api-spec/tree/master/collections</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/stac.py</code> <pre><code>class Collections(TypedDict):\n    \"\"\"All collections endpoint.\n    https://github.com/radiantearth/stac-api-spec/tree/master/collections\n    \"\"\"\n\n    collections: List[Collection]\n    links: List[Dict[str, Any]]\n    numberMatched: NotRequired[int]\n    numberReturned: NotRequired[int]\n</code></pre>"},{"location":"api/stac_fastapi/types/stac/#stac_fastapi.types.stac.Conformance","title":"Conformance","text":"<p>               Bases: <code>TypedDict</code></p> <p>STAC Conformance Classes.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/stac.py</code> <pre><code>class Conformance(TypedDict):\n    \"\"\"STAC Conformance Classes.\"\"\"\n\n    conformsTo: List[str]\n</code></pre>"},{"location":"api/stac_fastapi/types/stac/#stac_fastapi.types.stac.Item","title":"Item","text":"<p>               Bases: <code>TypedDict</code></p> <p>STAC Item.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/stac.py</code> <pre><code>class Item(TypedDict):\n    \"\"\"STAC Item.\"\"\"\n\n    type: Literal[\"Feature\"]\n    stac_version: str\n    stac_extensions: NotRequired[List[str]]\n    id: str\n    geometry: Dict[str, Any]\n    bbox: BBox\n    properties: Dict[str, Any]\n    links: List[Dict[str, Any]]\n    assets: Dict[str, Any]\n    collection: str\n</code></pre>"},{"location":"api/stac_fastapi/types/stac/#stac_fastapi.types.stac.ItemCollection","title":"ItemCollection","text":"<p>               Bases: <code>TypedDict</code></p> <p>STAC Item Collection.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/stac.py</code> <pre><code>class ItemCollection(TypedDict):\n    \"\"\"STAC Item Collection.\"\"\"\n\n    type: Literal[\"FeatureCollection\"]\n    features: List[Item]\n    links: List[Dict[str, Any]]\n    numberMatched: NotRequired[int]\n    numberReturned: NotRequired[int]\n</code></pre>"},{"location":"api/stac_fastapi/types/stac/#stac_fastapi.types.stac.LandingPage","title":"LandingPage","text":"<p>               Bases: <code>Catalog</code></p> <p>STAC Landing Page.</p> Source code in <code>stac_fastapi/types/stac_fastapi/types/stac.py</code> <pre><code>class LandingPage(Catalog):\n    \"\"\"STAC Landing Page.\"\"\"\n\n    conformsTo: List[str]\n</code></pre>"},{"location":"migrations/v3.0.0/","title":"stac-fastapi v3.0 Migration Guide","text":"<p>This document aims to help you update your application from stac-fastapi 2.5 to 3.0.0.</p>"},{"location":"migrations/v3.0.0/#changelog","title":"CHANGELOG","text":""},{"location":"migrations/v3.0.0/#removed","title":"Removed","text":"<ul> <li>Removed the <code>Context</code> extension</li> <li>Removed <code>stac_fastapi.api.openapi.config_openapi</code> method and <code>stac_fastapi.api.openapi.VndOaiResponse</code> class</li> <li>Removed <code>response_class</code> argument in <code>stac_fastapi.api.routes.create_async_endpoint</code> method</li> <li>Removed <code>filter_fields</code> property in <code>stac_fastapi.extensions.core.fields.request.PostFieldsExtension</code> class</li> <li>Removed <code>pagination_extension</code> attribute in <code>stac_fastapi.api.app.StacApi</code></li> <li>Removed <code>default_includes</code> from <code>stac_fastapi.types.config.ApiSettings</code> (#706)</li> <li>Removed use of <code>pagination_extension</code> in <code>register_get_item_collection</code> function (User now need to construct the request model and pass it using <code>items_get_request_model</code> attribute)</li> <li>Removed use of <code>FieldsExtension</code> in <code>stac_fastapi.api.app.StacApi</code>. NOTE: If users use <code>FieldsExtension</code>, they HAVE TO handle skipping the model validation step by returning a <code>JSONResponse</code> from the <code>post_search</code> and <code>get_search</code> client methods</li> <li>Removed <code>add_middleware</code> method in <code>StacApi</code> object and let starlette handle the middleware stack creation (#721)</li> <li>Removed <code>pystac</code> dependecy, as it was just used for a datetime-to-string function (#690)</li> <li>Removed internal Search and Operator Types in favor of stac_pydantic Types (#625)</li> </ul>"},{"location":"migrations/v3.0.0/#changed","title":"Changed","text":"<ul> <li>Update to pydantic 2.0 (#625)</li> <li>Update stac-pydantic requirement to <code>~3.1</code> (#697)</li> <li>Switch from <code>fastapi</code> to <code>fastapi-slim</code> to avoid installing unwanted dependencies (#687)</li> <li>Update FastAPI requirement to <code>&gt;=0.111.0</code></li> <li>Moved <code>AsyncBaseFiltersClient</code> and <code>BaseFiltersClient</code> classes in <code>stac_fastapi.extensions.core.filter.client</code> submodule</li> <li>Add more openapi metadata in input models (#734)</li> <li>Use same <code>Limit</code> (capped to <code>10_000</code>) for <code>/items</code> and <code>GET - /search</code> input models (#738)</li> <li>Moved <code>GETPagination</code>, <code>POSTPagination</code>, <code>GETTokenPagination</code> and <code>POSTTokenPagination</code> to <code>stac_fastapi.extensions.core.pagination.request</code> submodule (#717)</li> <li>Added option for default route dependencies <code>*</code> can be used for <code>path</code> or <code>method</code> to match all allowed route. (#705)</li> <li>Moved <code>AsyncBaseFiltersClient</code> and <code>BaseFiltersClient</code> classes in <code>stac_fastapi.extensions.core.filter.client</code> submodule (#704)</li> <li>Replace Enum with <code>Literal</code> for <code>FilterLang</code>. (#686)</li> <li>Fix response model validation (#625)</li> <li>Use status code 201 for Item/Collection creation (#625)</li> <li>Add <code>response_class</code> attribute in <code>FilterExtension</code> class</li> <li>Add version pinning (<code>~=3.0</code>) for stac-fastapi submodules</li> </ul>"},{"location":"migrations/v3.0.0/#fixed","title":"Fixed","text":"<ul> <li>Updated default <code>filter</code> language in filter extension's POST search request model to match the extension's documentation (#711)</li> <li>Fix missing default (<code>None</code>) for optional <code>query</code> attribute in <code>QueryExtensionPostRequest</code> model (#701)</li> <li>Make <code>str_to_interval</code> not return a tuple for single-value input (fixing <code>datetime</code> argument as passed to <code>get_search</code>). (#692)</li> </ul>"},{"location":"migrations/v3.0.0/#added","title":"Added","text":"<ul> <li>Add enhanced middleware configuration to the StacApi class, enabling specific middleware options and dynamic addition post-application initialization. (#442)</li> <li>Add response pydantic models to OpenAPI, even if model validation is turned off (#625)</li> <li>Add attributes to <code>stac_fastapi.api.app.StacApi</code> to enable customization of request model for:</li> <li><code>/collections</code>: collections_get_request_model, default to <code>EmptyRequest</code></li> <li><code>/collections/{collection_id}</code>: collection_get_request_model, default to <code>CollectionUri</code></li> <li><code>/collections/{collection_id}/items</code>: items_get_request_model, default to <code>ItemCollectionUri</code></li> <li><code>/collections/{collection_id}/items/{item_id}</code>: item_get_request_model, default to <code>ItemUri</code></li> <li>Add Aggregation extension (#684)</li> <li>Add Free-text extension (#655)</li> <li>Add Collection-Search extension (#736, #739)</li> </ul>"},{"location":"migrations/v3.0.0/#dependencies","title":"Dependencies","text":"<ul> <li>pydantic~=2.0</li> <li>fastapi&gt;=0.111</li> <li>stac-pydantic~=3.1</li> </ul> <p>Most of the stac-fastapi's dependencies have been upgraded. Moving from pydantic v1 to v2 is mostly the one update bringing most breaking changes (see docs.pydantic.dev/latest/migration/).</p> <p>In addition to pydantic v2 update, <code>stac-pydantic</code> has been updated to better match the STAC and STAC-API specifications (see github.com/stac-utils/stac-pydantic/blob/main/CHANGELOG.md#310-2024-05-21)</p>"},{"location":"migrations/v3.0.0/#deprecation","title":"Deprecation","text":"<ul> <li> <p>the <code>ContextExtension</code> have been removed (see stac-utils/stac-pydantic!138) and was replaced by optional <code>NumberMatched</code> and <code>NumberReturned</code> attributes, defined by the OGC features specification.</p> </li> <li> <p><code>stac_fastapi.api.config_openapi</code> method was removed (see stac-utils/stac-fastapi!523)</p> </li> <li> <p>passing <code>response_class</code> in <code>stac_fastapi.api.routes.create_async_endpoint</code> is now deprecated. The response class now has to be set when registering the endpoint to the application (see stac-utils/stac-fastapi#461)</p> </li> <li> <p><code>PostFieldsExtension.filter_fields</code> property has been removed.</p> </li> </ul>"},{"location":"migrations/v3.0.0/#middlewares-configuration","title":"Middlewares configuration","text":"<p>The <code>StacApi.middlewares</code> attribute has been updated to accept a list of <code>starlette.middleware.Middleware</code>. This enables dynamic configuration of middlewares (see stac-utils/stac-fastapi!442).</p> <pre><code># before\nclass myMiddleware(mainMiddleware):\n    option1 = option1\n    option2 = option2\n\nstac = StacApi(\n    middlewares=[\n        myMiddleware,\n    ]\n)\n\n# now\nstac = StacApi(\n    middlewares=[\n        Middleware(myMiddleware, option1, option2),\n    ]\n)\n</code></pre>"},{"location":"migrations/v3.0.0/#request-models","title":"Request Models","text":"<p>In stac-fastapi v2.0, users could already customize both GET/POST search request models. For v3.0, we've added more attributes to enable other endpoints customization:</p> <ul> <li><code>collections_get_request_model</code>: GET request model for the <code>/collections</code> endpoint (default to <code>EmptyRequest</code>)</li> <li><code>collection_get_request_model</code>: GET request model for the <code>/collections/{collection_id}</code> endpoint (default to <code>stac_fastapi.api.models.CollectionUri</code>)</li> <li><code>items_get_request_model</code>: GET request model for the <code>/collections/{collection_id}/items</code> endpoint (default to <code>stac_fastapi.api.models.ItemCollectionUri</code>)</li> <li><code>item_get_request_model</code>: GET request model for the <code>/collections/{collection_id}/items/{item_id}</code> endpoint (default to <code>stac_fastapi.api.models.ItemUri</code>)</li> </ul> <pre><code># before\ngetSearchModel = create_request_model(\n    model_name=\"SearchGetRequest\",\n    base_model=BaseSearchGetRequest\n    extensions=[...],\n    request_type=\"GET\"\n)\nstac = StacApi(\n    search_get_request_model=getSearchModel,\n    search_post_request_model=...,\n)\n\n# now\n@attr.s\nclass CollectionsRequest(APIRequest):\n    user: Annotated[str, Query(...)] = attr.ib()\n\nstac = StacApi(\n    search_get_request_model=getSearchModel,\n    search_post_request_model=postSearchModel,\n        collections_get_request_model=CollectionsRequest,\n        collection_get_request_model=...,\n        items_get_request_model=...,\n        item_get_request_model=...,\n)\n</code></pre>"},{"location":"migrations/v3.0.0/#apirequest-get-request-model","title":"APIRequest - GET Request Model","text":"<p>Most of the GET endpoints are configured with <code>stac_fastapi.types.search.APIRequest</code> base class.</p> <p>e.g the BaseSearchGetRequest, default for the <code>GET - /search</code> endpoint:</p> <pre><code>@attr.s\nclass BaseSearchGetRequest(APIRequest):\n    \"\"\"Base arguments for GET Request.\"\"\"\n\n    collections: Optional[List[str]] = attr.ib(default=None, converter=_collection_converter)\n    ids: Optional[List[str]] = attr.ib(default=None, converter=_ids_converter)\n    bbox: Optional[BBox] = attr.ib(default=None, converter=_bbox_converter)\n    intersects: Annotated[Optional[str], Query()] = attr.ib(default=None)\n    datetime: Optional[DateTimeType] = attr.ib(\n        default=None, converter=_datetime_converter\n    )\n    limit: Annotated[Optional[int], Query()] = attr.ib(default=10)\n</code></pre> <p>We use python attrs to construct those classes. Type Hint for each attribute is important and should be defined using <code>Annotated[{type}, fastapi.Query()]</code> form.</p> <pre><code>@attr.s\nclass SomeRequest(APIRequest):\n    user_number: Annotated[Optional[int], Query(alias=\"user-number\")] = attr.ib(default=None)\n</code></pre> <p>Note: when an attribute has a <code>converter</code> (e.g <code>_ids_converter</code>), the Type Hint should be defined directly in the converter:</p> <pre><code>def _ids_converter(\n    val: Annotated[\n        Optional[str],\n        Query(\n            description=\"Array of Item ids to return.\",\n        ),\n    ] = None,\n) -&gt; Optional[List[str]]:\n    return str2list(val)\n\n@attr.s\nclass BaseSearchGetRequest(APIRequest):\n    \"\"\"Base arguments for GET Request.\"\"\"\n\n    ids: Optional[List[str]] = attr.ib(default=None, converter=_ids_converter)\n</code></pre>"},{"location":"migrations/v3.0.0/#filter-extension","title":"Filter extension","text":"<p><code>default_includes</code> attribute has been removed from the <code>ApiSettings</code> object. If you need <code>defaults</code> includes you can overwrite the <code>FieldExtension</code> models (see stac-utils/stac-fastapi!706).</p> <pre><code># before\nstac = StacApi(\n    extensions=[\n        FieldsExtension()\n    ]\n)\n\n# now\nclass PostFieldsExtension(requests.PostFieldsExtension):\n    include: Optional[Set[str]] = Field(\n        default_factory=lambda: {\n            \"id\",\n            \"type\",\n            \"stac_version\",\n            \"geometry\",\n            \"bbox\",\n            \"links\",\n            \"assets\",\n            \"properties.datetime\",\n            \"collection\",\n        }\n    )\n    exclude: Optional[Set[str]] = set()\n\n\nclass FieldsExtensionPostRequest(BaseModel):\n    \"\"\"Additional fields and schema for the POST request.\"\"\"\n\n    fields: Optional[PostFieldsExtension] = Field(PostFieldsExtension())\n\n\nclass FieldsExtension(FieldsExtensionBase):\n    \"\"\"Override the POST model\"\"\"\n\n    POST = FieldsExtensionPostRequest\n\n\nfrom stac_fastapi.api.app import StacApi\n\nstac = StacApi(\n    extensions=[\n        FieldsExtension()\n    ]\n)\n</code></pre>"},{"location":"migrations/v3.0.0/#pagination-extension","title":"Pagination extension","text":"<p>In stac-fastapi v3.0, we removed the <code>pagination_extension</code> attribute in <code>stac_fastapi.api.app.StacApi</code>. This attribute was used within the <code>register_get_item_collection</code> to update the request model for the <code>/collections/{collection_id}/items</code> endpoint.</p> <p>It's now up to the user to create the request model and use the <code>items_get_request_model=</code> attribute in the StacApi object.</p> <pre><code># before\nstac=StacApi(\n    pagination_extension=TokenPaginationExtension,\n    extension=[TokenPaginationExtension]\n)\n\n# now\nitems_get_request_model = create_request_model(\n    \"ItemCollectionURI\",\n    base_model=ItemCollectionUri,\n    mixins=[TokenPaginationExtension().GET],\n)\n\nstac=StacApi(\n    extension=[TokenPaginationExtension],\n    items_get_request_model=items_get_request_model,\n)\n</code></pre>"},{"location":"migrations/v3.0.0/#fields-extension-and-model-validation","title":"Fields extension and model validation","text":"<p>When using the <code>Fields</code> extension, the <code>/search</code> endpoint should be able to return `invalid STAC Items. This creates an issue when model validation is enabled at the application level.</p> <p>Previously when adding the <code>FieldsExtension</code> to the extensions list and if setting output model validation, we were turning off the validation for both GET/POST <code>/search</code> endpoints. This was by-passing validation even when users were not using the <code>fields</code> options in requests.</p> <p>In <code>stac-fastapi</code> v3.0, implementers will have to by-pass the validation step at <code>Client</code> level by returning <code>JSONResponse</code> from the <code>post_search</code> and <code>get_search</code> client methods.</p> <pre><code># before\nclass BadCoreClient(BaseCoreClient):\n    def post_search(\n        self, search_request: BaseSearchPostRequest, **kwargs\n    ) -&gt; stac.ItemCollection:\n        return {\"not\": \"a proper stac item\"}\n\n    def get_search(\n        self,\n        collections: Optional[List[str]] = None,\n        ids: Optional[List[str]] = None,\n        bbox: Optional[List[NumType]] = None,\n        intersects: Optional[str] = None,\n        datetime: Optional[Union[str, datetime]] = None,\n        limit: Optional[int] = 10,\n        **kwargs,\n    ) -&gt; stac.ItemCollection:\n        return {\"not\": \"a proper stac item\"}\n\n# now\nclass BadCoreClient(BaseCoreClient):\n    def post_search(\n        self, search_request: BaseSearchPostRequest, **kwargs\n    ) -&gt; stac.ItemCollection:\n        resp = {\"not\": \"a proper stac item\"}\n\n        # if `fields` extension is enabled, then we return a JSONResponse\n        # to avoid Item validation\n        if getattr(search_request, \"fields\", None):\n            return JSONResponse(content=resp)\n\n        return resp\n\n    def get_search(\n        self,\n        collections: Optional[List[str]] = None,\n        ids: Optional[List[str]] = None,\n        bbox: Optional[List[NumType]] = None,\n        intersects: Optional[str] = None,\n        datetime: Optional[Union[str, datetime]] = None,\n        limit: Optional[int] = 10,\n        **kwargs,\n    ) -&gt; stac.ItemCollection:\n        resp = {\"not\": \"a proper stac item\"}\n\n        # if `fields` extension is enabled, then we return a JSONResponse\n        # to avoid Item validation\n        if \"fields\" in kwargs:\n            return JSONResponse(content=resp)\n\n        return resp\n</code></pre>"},{"location":"migrations/v4.0.0/","title":"stac-fastapi v4.0 Migration Guide","text":"<p>This document aims to help you update your application from stac-fastapi 3.0 to 4.0</p>"},{"location":"migrations/v4.0.0/#changelog","title":"CHANGELOG","text":""},{"location":"migrations/v4.0.0/#changed","title":"Changed","text":"<ul> <li>use <code>string</code> type instead of python <code>datetime.datetime</code> for datetime parameter in <code>BaseSearchGetRequest</code>, <code>ItemCollectionUri</code> and <code>BaseCollectionSearchGetRequest</code> GET models</li> <li>rename <code>filter</code> to <code>filter_expr</code> for <code>FilterExtensionGetRequest</code> and <code>FilterExtensionPostRequest</code> attributes to avoid conflict with python filter method</li> <li>remove <code>post_request_model</code> attribute in <code>BaseCoreClient</code> and <code>AsyncBaseCoreClient</code></li> <li>remove <code>python3.8</code> support</li> </ul>"},{"location":"migrations/v4.0.0/#fixed","title":"Fixed","text":"<ul> <li>Support multiple proxy servers in the <code>forwarded</code> header in <code>ProxyHeaderMiddleware</code> (#782)</li> </ul>"},{"location":"migrations/v4.0.0/#datetime-type-in-get-request-models","title":"Datetime type in GET request models","text":"<p>While the POST request models are created using stac-pydantic, the GET request models are python <code>attrs</code> classes (~dataclasses). In 4.0, we've decided to change how the <code>datetime</code> attribute was defined in <code>BaseSearchGetRequest</code>, <code>ItemCollectionUri</code> and <code>BaseCollectionSearchGetRequest</code> models to match the <code>datetime</code> definition/validation done by the pydantic model. This mostly mean that the datetime attribute forwarded to the GET endpoints will now be of type string (forwarded from the user input).</p> <pre><code>from starlette.testclient import TestClient\nfrom stac_fastapi.api.app import StacApi\nfrom stac_fastapi.types.config import ApiSettings\nfrom stac_fastapi.types.core import BaseCoreClient\n\nclass DummyCoreClient(BaseCoreClient):\n    def all_collections(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def get_collection(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def get_item(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def get_search(self, *args, datetime = None, **kwargs):\n        # Return True if datetime is a string\n        return isinstance(datetime, str)\n\n    def post_search(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def item_collection(self, *args, **kwargs):\n        raise NotImplementedError\n\napi = StacApi(\n    settings=ApiSettings(enable_response_models=False),\n    client=DummyCoreClient(),\n    extensions=[],\n)\n\n\n# before\nwith TestClient(api.app) as client:\n    response = client.get(\n        \"/search\",\n        params={\n            \"datetime\": \"2020-01-01T00:00:00.00001Z\",\n        },\n    )\n    assert response.json() == False\n\n# now\nwith TestClient(api.app) as client:\n    response = client.get(\n        \"/search\",\n        params={\n            \"datetime\": \"2020-01-01T00:00:00.00001Z\",\n        },\n    )\n    assert response.json() == True\n</code></pre>"},{"location":"migrations/v4.0.0/#startend-dates","title":"Start/End dates","text":"<p>Following stac-pydantic's <code>Search</code> model, we've added class attributes to easily retrieve the <code>parsed</code> dates:</p> <pre><code>from stac_fastapi.types.search import BaseSearchGetRequest\n\n# Interval\nsearch = BaseSearchGetRequest(datetime=\"2020-01-01T00:00:00.00001Z/2020-01-02T00:00:00.00001Z\")\n\nsearch.parse_datetime()\n&gt;&gt;&gt; (datetime.datetime(2020, 1, 1, 0, 0, 0, 10, tzinfo=datetime.timezone.utc), datetime.datetime(2020, 1, 2, 0, 0, 0, 10, tzinfo=datetime.timezone.utc))\n\nsearch.start_date\n&gt;&gt;&gt; datetime.datetime(2020, 1, 1, 0, 0, 0, 10, tzinfo=datetime.timezone.utc)\n\nsearch.end_date\n&gt;&gt;&gt; datetime.datetime(2020, 1, 2, 0, 0, 0, 10, tzinfo=datetime.timezone.utc)\n\n# Single date\nsearch = BaseSearchGetRequest(datetime=\"2020-01-01T00:00:00.00001Z\")\n\nsearch.parse_datetime()\n&gt;&gt;&gt; datetime.datetime(2020, 1, 1, 0, 0, 0, 10, tzinfo=datetime.timezone.utc)\n\nsearch.start_date\n&gt;&gt;&gt; datetime.datetime(2020, 1, 1, 0, 0, 0, 10, tzinfo=datetime.timezone.utc)\n\nsearch.end_date\n&gt;&gt;&gt; None\n</code></pre>"},{"location":"migrations/v4.0.0/#filter-extension","title":"Filter extension","text":"<p>We've renamed the <code>filter</code> attribute to <code>filter_expr</code> in the <code>FilterExtensionGetRequest</code> and <code>FilterExtensionPostRequest</code> models to avoid any conflict with python <code>filter</code> method. This change means GET endpoints with the filter extension enabled will receive <code>filter_expr=</code> option instead of <code>filter=</code>. Same for POST endpoints where the <code>body</code> will now have a <code>.filter_expr</code> instead of a <code>filter</code> attribute.</p> <p>Note: This change does not affect the <code>input</code> because we use <code>aliases</code>.</p> <pre><code>from starlette.testclient import TestClient\nfrom stac_fastapi.api.app import StacApi\nfrom stac_fastapi.api.models import create_get_request_model, create_post_request_model\nfrom stac_fastapi.extensions.core import FilterExtension\nfrom stac_fastapi.types.config import ApiSettings\nfrom stac_fastapi.types.core import BaseCoreClient\n\nclass DummyCoreClient(BaseCoreClient):\n    def all_collections(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def get_collection(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def get_item(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def get_search(self, *args, **kwargs):\n        return kwargs\n\n    def post_search(self, *args, **kwargs):\n        return args[0].model_dump()\n\n    def item_collection(self, *args, **kwargs):\n        raise NotImplementedError\n\nextensions = [FilterExtension()]\napi = StacApi(\n    settings=ApiSettings(enable_response_models=False),\n    client=DummyCoreClient(),\n    extensions=extensions,\n    search_get_request_model=create_get_request_model(extensions),\n    search_post_request_model=create_post_request_model(extensions),\n)\n\n\n# before\nwith TestClient(api.app) as client:\n    response = client.post(\n        \"/search\",\n        json={\n            \"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"test_property\"}, \"test-value\"]},\n        },\n    )\n    assert response.json()[\"filter\"]\n\n    response = client.get(\n        \"/search\",\n        params={\n            \"filter\": \"id='item_id' AND collection='collection_id'\",\n        },\n    )\n    assert response.json()[\"filter\"]\n\n# now\nwith TestClient(api.app) as client:\n    response = client.post(\n        \"/search\",\n        json={\n            \"filter\": {\"op\": \"=\", \"args\": [{\"property\": \"test_property\"}, \"test-value\"]},\n        },\n    )\n    assert response.json()[\"filter_expr\"]\n\n    response = client.get(\n        \"/search\",\n        params={\n            \"filter\": \"id='item_id' AND collection='collection_id'\",\n        },\n    )\n    assert response.json()[\"filter_expr\"]\n</code></pre>"}]}